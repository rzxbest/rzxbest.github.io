---
title: jm调优
date: 2022-03-08 09:00:00
tags: [JAVA虚拟机]
categories: [JAVA虚拟机]
top: 100
---
# jm调优

## 遇到了什么问题需要调优？
生产环境新上线了一个系统，莫名其妙奔溃，错误日志报异常OOM

## 类加载过程
加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载

### 什么情况下会去加载一个类呢?
何时将“.class”字节码文件中加载这个类到JVM内存里来，代码中用到这个类的时候。


### 验证
来校验加载进来的“.class”文件中的内容，是否符合指定的jvm规范。

### 准备
类的类变量(static修饰的变量)分配内存空间，来一个默认的初始值，并非执行赋值

### 解析阶段
符号引用替换为直接引用

### 初始化
执行类变量的赋值语句，执行静态代码块

## 类加载器和双亲委派机制
### 类加载器
- 启动类加载器
Bootstrap ClassLoader，负责加载Java安装目录下的“lib”目录中的核心类库
- 扩展类加载器
Extension ClassLoader，负责加载Java安装目录“lib\ext”目录里面有一些类
- 应用程序类加载器
Application ClassLoader，负责去加载“ClassPath”环境变量所指定的路径中的类 理解为去加载自己写好的Java代码
- 自定义类加载器 除了上面那几种之外，还可以自定义类加载器，去根据自己的需求加载自己的类。
### 双亲委派机制
- JVM的类加载器是有亲子层级结构的，启动类加载器是最上层的，扩展类加载器在第二层，第三层是应用程序类加载器，最后一层是自定义类加载器。
- 双亲委派模型:先找父亲去加载，不行的话再由自己来加载。

## 内存划分
### 方法区（1.8之前） 元空间
将“.class”文件里加载进来的类
### 程序计数器
写好的Java代码会被翻译成字节码，对应各种字节码指令，JVM加载类信息到内存之后，会使用自己的字节码执行引擎执行字节码指令，执行时，JVM里就需要一个特殊的内存区域，那就是“程序计数器”，这个程序计数器就是用来记录当前执行的字节码指令的位置的
### Java虚拟机栈
- JVM必须有一块区域是来保存每个方法内的局部变量等数据的，这个区域就是Java虚拟机栈 
- 每个线程都有自己的Java虚拟机栈
- 如果线程执行了一个方法，就会对这个方法调用创建对应的一个栈帧，栈帧里就有这个方法的局部变量表 、操作数栈、动态链接、方法出口

### Java堆内存
存放代码中创建的各种对象的

## jvm
### jvm参数

- -Xms:Java堆内存的大小 、-Xmx:Java堆内存的最大大小 
- -Xms和-Xmx，分别用于设置Java堆内存的刚开始的大小，以及允许扩张到的最大大小。
- -Xmn:Java堆内存中的新生代大小，扣除新生代剩下的就是老年代的内存大小,默认不设置新生代大小时，大概老年代占2/3，新生代占1/3，eden和2个survivor 8:1:1  jvm参数"- XX:SurvivorRatio=8"
- -XX:PermSize:永久代大小、-XX:MaxPermSize:永久代最大大小
- jdk1.8 用这两个-XX:MetaspaceSize和-XX:MaxMetaspaceSize替换永久代大小
- -Xss:每个线程的栈内存大小

### 如何合理设置永久代大小?
一般你设置个几百MB，大体上都是够用的 因为里面主要就是存放一些类的信息
### 如何合理设置栈内存大小
一般默认就是比如512KB到1MB

### 如何确定对象是垃圾？可达性分析算法GCRoot根由那些对象组成？
对象无引用时会被确定为垃圾对象，方法的局部变量、类的静态变量都被看为GCRoot根
### 垃圾对象一定会被回收吗？
不一定，如果对象重写了Object类中的finialize()方法，并且在该方法建立起与静态变量的引用关系就可以不被回收
### 强引用、软引用、弱引用、虚引用
强引用：绝对不能回收的对象
软引用：有的对象可有可无，如果内存实在不够了，可以回收他。
弱引用：与没引用是类似的，如果发生垃圾回收，就会把这个对象回收掉
虚引用：暂时忽略，很少用。

### 垃圾回收算法
复制算法：内存区域划分为两块，对象就就会分配在其中一块内存空间，垃圾回收时，存活对象复制到另一块内存空间，同时原分配对象空间清除所有对象
缺点：内存使用率太低 优点：不会产生内存碎片，不浪费内存空间

复制算法做出如下优化：
- 把新生代内存区域划分为三块:1个Eden区，2个Survivor区，其中Eden区占80%内存空间，每一块Survivor区各占10%内存空间
- 刚开始对象都是分配在Eden区内的，如果Eden区快满了，此时就会触发垃圾回收，把Eden区中的存活对象都一次性转移到一块空着的Survivor区，接着Eden区就会被清空
- 然后再次分配新对象到Eden区里，此时，Eden区和一块Survivor区里是有对象的，其中Survivor区里放的是上一次Minor GC后存活的对象。如果下次再次Eden区满，那么再次触发Minor GC，Eden区和放着上一次Minor GC后存活对象的Survivor区内的存活对象，转移到另外一块Survivor区去。然后清空eden区和上一次的survivor区

### 对象何时从新生代转到老年代？
- 15次minor gc对象还存活。JVM参数“-XX:MaxTenuringThreshold”来设置，默认是15岁
- 动态对象年龄判断：假如说当前放对象的Survivor区域的一些对象大小和（按照年龄排正序）大于了这块Survivor区域的内存大小的50%，那么此时大于等于这批对象年龄的对象，就可以直接进入老年代。年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会把年龄n以上的对象都放入老年代。
- 大对象直接进入老年代。JVM参数，“-XX:PretenureSizeThreshold”，单位字节数，比如“1048576”字节，就是1MB。
- Minor GC后的对象太多无法放入Survivor区怎么办? 这个时候就必须得把这些对象直接转移到老年代去
- 老年代空间分配担保机制
    - 在执行任何一次Minor GC之前，JVM会先检查一下老年代可用的可用内存空间，是否大于新生代所有对象的总大小。避免Minor GC后老年代空间放不下存活对象
    - 如果老年代的内存大小是大于新生代所有对象的，此时就可以对新生代发起一次Minor GC了
    - 如果老年代的内存大小是小于新生代所有对象的，JVM“-XX:- HandlePromotionFailure”的参数是否设置,
        - 未设置 发生一次Full GC（对老年代进行垃圾回收，同时一般会对新生代进行垃圾回收）
        - 设置表示开启老年代空间担保，接着判断老年代的内存大小，是否大于之前每一次Minor GC后进入老年代的对象的平均大小，如果大于，则Minor GC,如果小于，FullGC
    - 如果要是Full GC过后，老年代还是没有足够的空间存放Minor GC过后的剩余存活对象，就会导致所谓的 “OOM”内存溢出

### 老年代采用的什么垃圾回收算法？
- 标记整理算法：首先标记出来老年代当前存活的对象，接着会让这些存活对象在内存里进行移动，把存活对象尽量都挪动到一边去
- 老年代的垃圾回收算法的速度至少比新生代的垃圾回收算法的速度慢10倍。
- 如果系统频繁出现老年代的Full GC垃圾回收，会导致系统性能被严重影响，出现频繁卡顿的情况。
### 垃圾收集器
- Serial和Serial Old垃圾回收器:分别用来回收新生代和老年代的垃圾对象，工作原理就是单线程运行，STW，一般几乎不用。
- ParNew和CMS垃圾回收器:ParNew现在一般用在新生代的，CMS是用在老年代的，都是多线程并发的机制，性能更好，一般是生产系统的标配组合。
- G1垃圾回收器:统一收集新生代和老年代，采用了更加优秀的算法和设计机制

### stw
直接停止Java系统的所有工作线程，让代码不再运行，让垃圾回收线程可以专心致志的进行垃圾回收的工作
    - 假设我们的Minor GC要运行100ms，那么可能就会导致系统直接停顿100ms不能处理任何请求
    - Full GC是最慢的，有的时候弄不好一次回收要进行几秒钟，甚至几十秒，有的极端场景几分钟都是有可能的。一旦频繁的Full GC，系统每一段时间就卡死个30秒吗?
    - 无论是新生代GC还是老年代GC，都尽量不要让频率过高，避免持续时间过长

### ParNew垃圾收集器
暂停系统程序的工作线程，禁止程序继续运行创建新的对象，用多个垃圾回收线程去进行垃圾回收，用复制算法回收
使用ParNew垃圾回收器 JVM参数 -XX:+UseParNewGC
ParNew垃圾回收器默认情况下的线程数量 垃圾回收线程的数量就是跟CPU的核数是一样。 JVM参数设置 - XX:ParallelGCThreads=n

### 服务器模式与客户端模式
- 启动系统的时候是可以区分服务器模式和客户端模式的，启动系统的时候加入“-server”就是服务器模式，如果加入“-cilent”就是客户端模式。
- 系统部署在比如4核8G的Linux服务器上那么就应该用服务器模式，如果你的系统是运行在比如Windows上的客户端程序，那么就应该是客户端模式。
- 服务器模式通常ParNew来进行垃圾回收，客户端模式使用采用Serial垃圾回收器，单CPU单线程垃圾回收

### CMS
CMS垃圾回收器采取的是垃圾回收线程和系统工作线程尽量同时执行的模式来处理的，使用标记-清理的算法
初始标记 ：stw 很快，仅仅标记出GC Root根
并发标记 ：对老年代所有对象进行GC Roots追踪，其实是最耗时的
重新标记 ：stw 很快,对在第二阶段中被系统程序运行变动过的少数对象进行标记
并发清理 ：很耗时

缺点： 
    - 会消耗CPU资源，在并发标记时，老年代存活对象多，追踪大量对象，耗时较高，并发清理，把垃圾对象从随机的内存位置清理掉，也比较耗时，CMS的垃圾回收线程是比较耗费CPU资源的。CMS默认启动的垃圾回收线程的数量是(CPU核数 + 3)/ 4。
    - 会产生浮动垃圾，并发清理同时随着系统运行让一些对象进入老年代，这种垃圾需要等到下一次GC才能回收掉


-XX:CMSInitiatingOccupancyFaction 用来设置老年代占用多少时触发CMS垃圾回收，JDK 1.6里面默认的值是 92%。
-XX:+UseCMSCompactAtFullCollection 默认开启 Full GC之后再次进行stw，碎片整理
-XX:CMSFullGCsBeforeCompaction 执行多少次Full GC之后执行一次内存碎片整理，默认是0，每次Full GC之后都会进行内存整理。

### 优化方案
- 评估Eden区进行Minor Gc 之后存活的对象大小，Suvivor区空间够不够，建议的是调整新生代和老年代的大小，让短期存活的对象在新生代就被垃圾回收
- 结合系统的运行模型，@Service、@Controller之类的注解那种需要长期存活的核心业务逻辑组件，降低“-XX:MaxTenuringThreshold”参数的值，避免对长期存活的对象在新生代Survivor区来回复制
- 大对象直接进入老年代，-XX:PretenureSizeThreshold=1M，避免对象在新生代Survivor区来回复制
一般启动参数：
-Xms3072M -Xmx3072M -Xmn2048M -Xss1M -XX:PermSize=256M -XX:MaxPermSize=256M - XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=1M -XX:+UseParNewGC - XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFaction=92 -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=0

### Concurrent Mode Failure
CMS在垃圾回收的时候，尤其是并发清理期间，系统程序是可以并发运行的，假设此时老年代空闲空间仅剩100MB，此时系统程序还在不停的创建对象，万一这个时候系统运行触发了某个条件，比如说有200MB对象要进入老年代，这个时候就会触发“Concurrent Mode Failure”问题，因为此时老年代没有足够内存来放这200MB对象，此时就会导致立马进入Stop the World，然后切换CMS为Serial Old收集器来单线程收集垃圾 

### G1
G1垃圾回收器把Java堆内存拆分为多个大小相等的Region，G1会有新生代和老年代的概念，但是只是逻辑上的概念
G1垃圾回收器可以设置一个垃圾回收的预期停顿时间
G1通过把内存拆分为大量小Region，以及追踪每个Region中可以回收的对象大小和预估时间，在垃圾回收的时候，尽量把垃圾回收对系统造成的影响控制在指定的时间范围内，同时在有限的时间内尽量回收尽可能多的垃圾对象
