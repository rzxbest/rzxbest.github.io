---
title: jm调优
date: 2022-03-08 09:00:00
tags: [JAVA虚拟机]
categories: [JAVA虚拟机]
top: 100
---
# jm调优

## 遇到了什么问题需要调优？
生产环境新上线了一个系统，莫名其妙奔溃，错误日志报异常OOM

## 类加载过程
加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载

### 什么情况下会去加载一个类呢?
何时将“.class”字节码文件中加载这个类到JVM内存里来，代码中用到这个类的时候。


### 验证
来校验加载进来的“.class”文件中的内容，是否符合指定的jvm规范。

### 准备
类的类变量(static修饰的变量)分配内存空间，来一个默认的初始值，并非执行赋值

### 解析阶段
符号引用替换为直接引用

### 初始化
执行类变量的赋值语句，执行静态代码块

## 类加载器和双亲委派机制
### 类加载器
- 启动类加载器
Bootstrap ClassLoader，负责加载Java安装目录下的“lib”目录中的核心类库
- 扩展类加载器
Extension ClassLoader，负责加载Java安装目录“lib\ext”目录里面有一些类
- 应用程序类加载器
Application ClassLoader，负责去加载“ClassPath”环境变量所指定的路径中的类 理解为去加载自己写好的Java代码
- 自定义类加载器 除了上面那几种之外，还可以自定义类加载器，去根据自己的需求加载自己的类。
### 双亲委派机制
- JVM的类加载器是有亲子层级结构的，启动类加载器是最上层的，扩展类加载器在第二层，第三层是应用程序类加载器，最后一层是自定义类加载器。
- 双亲委派模型:先找父亲去加载，不行的话再由自己来加载。

## 内存划分
### 方法区（1.8之前） 元空间
将“.class”文件里加载进来的类
### 程序计数器
写好的Java代码会被翻译成字节码，对应各种字节码指令，JVM加载类信息到内存之后，会使用自己的字节码执行引擎执行字节码指令，执行时，JVM里就需要一个特殊的内存区域，那就是“程序计数器”，这个程序计数器就是用来记录当前执行的字节码指令的位置的
### Java虚拟机栈
- JVM必须有一块区域是来保存每个方法内的局部变量等数据的，这个区域就是Java虚拟机栈 
- 每个线程都有自己的Java虚拟机栈
- 如果线程执行了一个方法，就会对这个方法调用创建对应的一个栈帧，栈帧里就有这个方法的局部变量表 、操作数栈、动态链接、方法出口

### Java堆内存
存放代码中创建的各种对象的

## jvm
### jvm参数

- -Xms:Java堆内存的大小 、-Xmx:Java堆内存的最大大小 
- -Xms和-Xmx，分别用于设置Java堆内存的刚开始的大小，以及允许扩张到的最大大小。
- -Xmn:Java堆内存中的新生代大小，扣除新生代剩下的就是老年代的内存大小,默认不设置新生代大小时，大概老年代占2/3，新生代占1/3，eden和2个survivor 8:1:1 
- -XX:PermSize:永久代大小、-XX:MaxPermSize:永久代最大大小
- jdk1.8 用这两个-XX:MetaspaceSize和-XX:MaxMetaspaceSize替换永久代大小
- -Xss:每个线程的栈内存大小

### 如何合理设置永久代大小?
一般你设置个几百MB，大体上都是够用的 因为里面主要就是存放一些类的信息
### 如何合理设置栈内存大小
一般默认就是比如512KB到1MB

### 如何确定对象是垃圾？可达性分析算法GCRoot根由那些对象组成？
对象无引用时会被确定为垃圾对象，方法的局部变量、类的静态变量都被看为GCRoot根
### 垃圾对象一定会被回收吗？
不一定，如果对象重写了Object类中的finialize()方法，并且在该方法建立起与静态变量的引用关系就可以不被回收
### 强引用、软引用、弱引用、虚引用
强引用：绝对不能回收的对象
软引用：有的对象可有可无，如果内存实在不够了，可以回收他。
弱引用：与没引用是类似的，如果发生垃圾回收，就会把这个对象回收掉
虚引用：暂时忽略，很少用。

### 垃圾回收算法
复制算法：内存区域划分为两块，对象就就会分配在其中一块内存空间，垃圾回收时，存活对象复制到另一块内存空间，同时原分配对象空间清除所有对象
缺点：内存使用率太低 优点：不会产生内存碎片，不浪费内存空间

复制算法做出如下优化：
- 把新生代内存区域划分为三块:1个Eden区，2个Survivor区，其中Eden区占80%内存空间，每一块Survivor区各占10%内存空间
- 刚开始对象都是分配在Eden区内的，如果Eden区快满了，此时就会触发垃圾回收，把Eden区中的存活对象都一次性转移到一块空着的Survivor区，接着Eden区就会被清空
- 然后再次分配新对象到Eden区里，此时，Eden区和一块Survivor区里是有对象的，其中Survivor区里放的是上一次Minor GC后存活的对象。如果下次再次Eden区满，那么再次触发Minor GC，Eden区和放着上一次Minor GC后存活对象的Survivor区内的存活对象，转移到另外一块Survivor区去。然后清空eden区和上一次的survivor区

### 对象何时从新生代转到老年代？
- 15次minor gc对象还存活。JVM参数“-XX:MaxTenuringThreshold”来设置，默认是15岁
- 动态对象年龄判断：假如说当前放对象的Survivor区域的一些对象大小和（按照年龄排正序）大于了这块Survivor区域的内存大小的50%，那么此时大于等于这批对象年龄的对象，就可以直接进入老年代。年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会把年龄n以上的对象都放入老年代。
- 大对象直接进入老年代。JVM参数，“-XX:PretenureSizeThreshold”，单位字节数，比如“1048576”字节，就是1MB。
- Minor GC后的对象太多无法放入Survivor区怎么办? 这个时候就必须得把这些对象直接转移到老年代去
- 老年代空间分配担保机制
    - 在执行任何一次Minor GC之前，JVM会先检查一下老年代可用的可用内存空间，是否大于新生代所有对象的总大小。避免Minor GC后老年代空间放不下存活对象
    - 如果老年代的内存大小是大于新生代所有对象的，此时就可以对新生代发起一次Minor GC了
    - 如果老年代的内存大小是小于新生代所有对象的，JVM“-XX:- HandlePromotionFailure”的参数是否设置,
        - 未设置 发生一次Full GC（对老年代进行垃圾回收，同时一般会对新生代进行垃圾回收）
        - 设置表示开启老年代空间担保，接着判断老年代的内存大小，是否大于之前每一次Minor GC后进入老年代的对象的平均大小，如果大于，则Minor GC,如果小于，FullGC
    - 如果要是Full GC过后，老年代还是没有足够的空间存放Minor GC过后的剩余存活对象，就会导致所谓的 “OOM”内存溢出

### 老年代采用的什么垃圾回收算法？
- 标记整理算法：首先标记出来老年代当前存活的对象，接着会让这些存活对象在内存里进行移动，把存活对象尽量都挪动到一边去
- 老年代的垃圾回收算法的速度至少比新生代的垃圾回收算法的速度慢10倍。
- 如果系统频繁出现老年代的Full GC垃圾回收，会导致系统性能被严重影响，出现频繁卡顿的情况。