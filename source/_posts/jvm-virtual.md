---
title: JAVA虚拟机
date: 2021-11-25 19:20:47
tags: [JAVA,JAVA虚拟机]
categories: [JAVA]

---

![image-20211126094454822](image-20211126094454822.png)

## 栈

- 每开启一个线程，就开辟一块栈内存区域
- 栈帧：遇到一方法就新建一块栈帧放入栈中
- 方法执行完，对应栈帧出栈销毁

#### 栈帧

- 局部变量表 ：存局部变量
- 操作数栈 ： 做运算
- 动态链接 ：方法入口地址 符号引用转为入口地址
- 方法出口

![image-20211126094254239](image-20211126094254239.png)

#### 反汇编查看字节码文件

javap -c ***.class

#### 单个栈空间大小设置参数

-Xss128k （默认1m）

栈空间满了会出现StackOverFlowError，调用链过长可能导致此位置，或者递归调用

## 堆

![image-20211126094600649](image-20211126094600649.png)

堆参数设置：

- -Xms  初始堆大小 例：-Xms256m
- -Xmx  最大堆大小 例：-Xms256m
- -Xmn  新生代大小     例：-Xmn1m

## 方法区(元空间)

主要存常量，静态变量，类元信息

jdk1.8类元数据放到了**本地内存**中，将**常量池**和**静态变量**放到了Java**堆**， jdk1.7 及以前存储堆中在持久代

方法区设置参数1.8

- -XX:MetaspaceSize:
- -XX:MetaspaceSize:

## 程序计数器

存储正在执行的语句的行号（地址），线程私有，当语句执行完成，字节码执行引擎对程序计数器进行修改

## GC

#### gc类型

- full gc 回收年轻代、老年代、方法区无引用对象
- minor gc 回收eden survivor区无引用对象

注意：gc回收过程中都会 stop the world (STW) 如果回收后仍没有空间放对象，OutOfMemoryError

minor gc 回收 eden区 from区 将存活对象移入to区

minor gc 回收eden区 to 区，将存活对象移入from区

#### 逃逸分析

##### jvm运行模式（java命令运行java类）

1. 解释模式：执行一行jvm字节码编译一行机器码执行 ，启动快执行慢

2. 编译模式：一次性编译成机器码一次性执行  启动慢 执行快

3. 混合模式：使用解释模式，热点代码使用编译模式

   

##### 逃逸分析参数

开启：-XX:+DoEscapeAnalysis

关闭：-XX:-DoEscapeAnalysis

jdk1.8默认开启

##### 逃逸分析说明

如果一个方法中的对象在方法结束时，这个对象就可以被回收，jvm会将这个对象分配栈帧里，如果栈空间不够，分配在堆里，栈帧弹出就回收，不需要等待内存满触发GC

#### 垃圾回收

1. 对象优先分配eden区

2. 大对象可以直接进入老年代，避免在年轻代来回复制，大对象复制比较耗时

3. minor gc后survivor区放不下的对象直接进入老年代

4. 动态年龄判断 ：年龄1+...年龄n > survivor区大小50% 那么年龄大于n的对象直接进入老年代

5. 老年代空间担保机制

   ![image-20211126100653589](image-20211126100653589.png)

#### 垃圾回收算法

- 引用计数器：计数为0 可以回收，存在问题就是循环依赖，A对象一属性依赖B B对象一属性依赖A

- 可达性分析算法：GCRoot根，遍历GCroot根

  - 线程栈局部变量
  - 静态变量
  - 本地方法栈变量

  



