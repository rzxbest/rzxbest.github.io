<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.imder.top","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.8.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="随记">
<meta property="og:url" content="https://blog.imder.top/index.html">
<meta property="og:site_name" content="随记">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ren zheng xiao">
<meta property="article:tag" content="JAVA开发">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://blog.imder.top/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>随记</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
  <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas>
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
   <script type="text/javascript" src="/js/fireworks.js"></script>
<link rel="alternate" href="/atom.xml" title="随记" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">随记</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记一记,所学,温故而知新</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ren zheng xiao"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Ren zheng xiao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">38</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.imder.top/2022/04/12/springboot-tomcat%E5%90%AF%E5%8A%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ren zheng xiao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="随记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/12/springboot-tomcat%E5%90%AF%E5%8A%A8/" class="post-title-link" itemprop="url">springboot-tomcat启动</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-12 14:59:29" itemprop="dateCreated datePublished" datetime="2022-04-12T14:59:29+00:00">2022-04-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2024-03-28 16:43:20" itemprop="dateModified" datetime="2024-03-28T16:43:20+00:00">2024-03-28</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/springboot/" itemprop="url" rel="index"><span itemprop="name">springboot</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <embed src="./tomcat启动.pdf" width="100%" height="1000" type="application/pdf">


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.imder.top/2022/04/22/zookeeper/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ren zheng xiao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="随记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/22/zookeeper/" class="post-title-link" itemprop="url">zookeeper</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-22 12:43:00" itemprop="dateCreated datePublished" datetime="2022-04-22T12:43:00+00:00">2022-04-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2024-03-28 16:43:20" itemprop="dateModified" datetime="2024-03-28T16:43:20+00:00">2024-03-28</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/zookeeper/" itemprop="url" rel="index"><span itemprop="name">zookeeper</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h1><h1 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h1><p>服务器节点状态 ： LOOKING 竞选状态,FOLLOWING 随从状态,LEADING 领导状态,OBSERVING 观察状态，不参与投票<br>服务器ID ：sid<br>事务ID ：zxid</p>
<p>规则：交换投票信息，对方事务id比自己大的，下一次投票投给对方节点，如果事务id相同，服务器id比自己大的，下一次投票给对方节点，多个取最大，投票给最大；当选票大于总节点一半时，选票多的机器变为leader,其余变成follow</p>
<p>假设5台机器<br>1.服务器1启动，投票给自己，（zxid=0,sid=1）,只有一票<br>2.服务器2启动，投票给自己，（zxid=0,sid=2）,并和服务器1交换信息，服务器1更改选票投给服务器2 ，服务器2只有两票<br>3.服务器3启动，投票给自己，（zxid=0,sid=3）,并和服务器1、2交换信息，服务器1、2更改选票投给服务器3 ，服务器3只有三票 》2.5 ，成为leader ，服务器1，2成功follow<br>4. 服务器4启动，投票给自己 ，（zxid=0,sid=4）, 并和服务器1，2，3交换选票，但是此时服务器1，2，3已经不是looking状态，服务器3 3票，服务器 4 1票，服务器4成为follow<br>5. 服务器5启动，投票给自己 ，（zxid=0,sid=3）, 并和服务器1，2，3，4交换选票，但是此时服务器1，2，3，4已经不是looking状态，服务器3 4票，服务器5 1票，服务器5成为follow</p>
<p>leader挂了选举新leader？<br>服务器投票给自己，服务器1 （zxid=99,sid=1）服务器2 （zxid=102,sid=2）服务器4 （zxid=99,sid=4）服务器5 （zxid=99,sid=5），并交换选票信息，接下来改投票给服务器2，服务器2成为leader</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.imder.top/2022/04/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ren zheng xiao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="随记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">多线程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-22 11:43:00" itemprop="dateCreated datePublished" datetime="2022-04-22T11:43:00+00:00">2022-04-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2024-03-28 16:43:20" itemprop="dateModified" datetime="2024-03-28T16:43:20+00:00">2024-03-28</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">多线程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h1 id="线程数量与cpu的关系"><a href="#线程数量与cpu的关系" class="headerlink" title="线程数量与cpu的关系"></a>线程数量与cpu的关系</h1><p>如果是CPU密集型应用，则线程池大小设置为N+1<br>如果是IO密集型应用，则线程池大小设置为2N+1（因为io读数据或者缓存的时候，线程等待，此时如果多开线程，能有效提高cpu利用率）</p>
<p>最佳线程数目 = （（线程等待时间（非CPU运行时间，比如IO）+线程CPU时间）/线程CPU时间 ）* CPU数目<br>线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。<br>最佳线程数目 = （线程等待时间与线程CPU时间之比 + 1）* CPU数目</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.imder.top/2022/04/12/%E6%B6%88%E9%87%91%E5%86%85%E9%83%A8%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E6%A1%86%E6%9E%B6sif/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ren zheng xiao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="随记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/12/%E6%B6%88%E9%87%91%E5%86%85%E9%83%A8%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E6%A1%86%E6%9E%B6sif/" class="post-title-link" itemprop="url">消金内部服务调用框架sif</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-12 14:59:29" itemprop="dateCreated datePublished" datetime="2022-04-12T14:59:29+00:00">2022-04-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2024-03-28 16:43:20" itemprop="dateModified" datetime="2024-03-28T16:43:20+00:00">2024-03-28</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">微服务</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="服务端流程"><a href="#服务端流程" class="headerlink" title="服务端流程"></a>服务端流程</h1><embed src="./Sif2.0.pdf" width="100%" height="1000" type="application/pdf">

<h1 id="客户端流程"><a href="#客户端流程" class="headerlink" title="客户端流程"></a>客户端流程</h1> <embed src="./sif2.0client.pdf" width="100%" height="1000" type="application/pdf">

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.imder.top/2022/03/31/spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ren zheng xiao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="随记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/31/spring/" class="post-title-link" itemprop="url">Spring</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-31 14:59:29" itemprop="dateCreated datePublished" datetime="2022-03-31T14:59:29+00:00">2022-03-31</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2024-03-28 16:43:20" itemprop="dateModified" datetime="2024-03-28T16:43:20+00:00">2024-03-28</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="注册组件方法"><a href="#注册组件方法" class="headerlink" title="注册组件方法"></a>注册组件方法</h2><ul>
<li>1.包扫描+组件标注注解（@Controller/@Service/@Repository/@Component）[自己写的类]</li>
<li>2.@Bean[导入的第三方包里面的组件]</li>
<li>3.@Import[快速给容器中导入一个组件]<pre><code>  1.@Import(要导入到容器中的组件)；容器中就会自动注册这个组件，id默认是全类名
  2.ImportSelector接口:返回需要导入的组件的全类名数组；
  3.ImportBeanDefinitionRegistrar接口:手动注册bean到容器中
</code></pre>
</li>
</ul>
<h2 id="spring-扩展点"><a href="#spring-扩展点" class="headerlink" title="spring 扩展点"></a>spring 扩展点</h2><h3 id="spring启动流程图"><a href="#spring启动流程图" class="headerlink" title="spring启动流程图"></a>spring启动流程图</h3><p><img src="/2022/03/31/spring/b.jpeg" alt="b"></p>
<h3 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h3><p>允许对Bean的定义进行修改，向ConfigurableListableBeanFactory里注册spring 的组件，比如添加 BeanPostProcessor、ApplicationListener、类型转换器等等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanFactoryPostProcessor &#123;</span><br><span class="line">    void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>应用<ul>
<li>单元测试懒加载<ul>
<li>有时候整个项目工程中bean的数量有上百个，而大部分单测依赖都是整个工程的xml，导致单测执行时需要很长时间（大部分时间耗费在xml中数百个单例非懒加载的bean的实例化及初始化过程）</li>
<li>解决方法：利用Spring提供的扩展点将xml中的bean设置为懒加载模式，省去了Bean的实例化与初始化时间</li>
</ul>
</li>
<li>BeanFactoryPostProcessor 来处理占位符 ${…}，关键的实现类是 PropertySourcesPlaceholderConfigurer，遍历所有的 BeanDefinition，如果 PropertyValue 存在这样的占位符，则会进行解析替换。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class LazyBeanFactoryProcessor implements BeanFactoryPostProcessor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">        DefaultListableBeanFactory fac = (DefaultListableBeanFactory) beanFactory;</span><br><span class="line">        Map&lt;String, AbstractBeanDefinition&gt; map = (Map&lt;String, AbstractBeanDefinition&gt;) ReflectionTestUtils.getField(fac, &quot;beanDefinitionMap&quot;);</span><br><span class="line">        for (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            //设置为懒加载</span><br><span class="line">            entry.getValue().setLazyInit(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PropertySourcesPlaceholderConfigurer extends PlaceholderConfigurerSupport implements EnvironmentAware &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">        // 省略对 PropertySources 的处理逻辑......</span><br><span class="line">        processProperties(beanFactory, new PropertySourcesPropertyResolver(this.propertySources));</span><br><span class="line">        this.appliedPropertySources = this.propertySources;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void processProperties(ConfigurableListableBeanFactory beanFactoryToProcess,</span><br><span class="line">            final ConfigurablePropertyResolver propertyResolver) throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">        propertyResolver.setPlaceholderPrefix(this.placeholderPrefix);</span><br><span class="line">        propertyResolver.setPlaceholderSuffix(this.placeholderSuffix);</span><br><span class="line">        propertyResolver.setValueSeparator(this.valueSeparator);</span><br><span class="line">        StringValueResolver valueResolver = new StringValueResolver() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public String resolveStringValue(String strVal) &#123;</span><br><span class="line">                String resolved = (ignoreUnresolvablePlaceholders ?</span><br><span class="line">                        propertyResolver.resolvePlaceholders(strVal) :</span><br><span class="line">                        propertyResolver.resolveRequiredPlaceholders(strVal));</span><br><span class="line">                if (trimValues) &#123;</span><br><span class="line">                    resolved = resolved.trim();</span><br><span class="line">                &#125;</span><br><span class="line">                return (resolved.equals(nullValue) ? null : resolved);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        // 调用父类 PlaceholderConfigurerSupport 进行 properties 处理</span><br><span class="line">        // 遍历每一个 BeanDefinition，并将其交给 BeanDefinitionVisitor 修改内部的属性</span><br><span class="line">        doProcessProperties(beanFactoryToProcess, valueResolver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="BeanDefinitionRegistryPostProcessor"><a href="#BeanDefinitionRegistryPostProcessor" class="headerlink" title="BeanDefinitionRegistryPostProcessor"></a>BeanDefinitionRegistryPostProcessor</h3><p>BeanDefinitionRegistryPostProcessor 是 BeanFactoryPostProcessor 的子类，可以通过编码的方式，改变、新增类的定义，甚至删除某些 bean 的定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor &#123;</span><br><span class="line">    void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 spring 初始化容器之后，解析Class 为一个BeanDefinition 之前的时候去执行， spring 中有一个开天辟地的类 ConfigurationClassPostProcessor 就是实现了该接口， ConfigurationClassPostProcessor 通过重写 这个方法</p>
<p>第一步：去扫描加了 @Configuration 注解的这些类，判断是否是AnnotatedBeanDefinition类型的，将这些类去打上 Lite/Full 的属性，以便后续使用 。<br>第二步：去实现扫描basePackage下的加了 @Service @Controller @Component 的这些类 将这些类变成为一个BeanDefinition 注册到 Spring 的BeanDefinitionMap中去 。<br>第三步： 去解析 @import，实现 ImportSelector接口的，实现 ImportBeanDefinitionRegistrar 接口的 这些类的方法，将对应的bean 解析为BeanDefinition，注册到BeanDefinitionMap 中<br>注意： 在新的Mybatis-spring 的框架中，也使用了到了这个接口 MapperScannerConfigurer 这个扫描配置类 也实现了这个接口！ 重写了postProcessBeanDefinitionRegistry() 用于创建扫描器对象，去扫描mybatis 里的那些接口转化为BeanDefinition到容器中去<br>作用： 有了参数 registry 的对象，就能手动向spring容器添加 自定义的BeanDefinition registry 提供了添加的 API，但是一般我们不调用 因为在spring里的执行顺序太早了</p>
<p>应用：</p>
<ul>
<li>spring 集成 mybatis，使用 spring 提供的扫描功能，为我们的Dao接口生成实现类而不需要编写具体的实现类，简化了大量的冗余代码          <ul>
<li>mybatis-spring 框架就是利用 BeanDefinitionRegistryPostProcessor通过编码的方式往spring容器中添加 bean。</li>
<li>MapperScannerConfigurer 重写了 postProcessBeanDefinitionRegistry方法，扫描Dao接口的BeanDefinition，并将BeanDefinition注册到 spring容器中。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class MapperScannerConfigurer implements BeanDefinitionRegistryPostProcessor, </span><br><span class="line">    InitializingBean, ApplicationContextAware, BeanNameAware &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">        if (this.processPropertyPlaceHolders) &#123;</span><br><span class="line">            processPropertyPlaceHolders();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // ClassPathMapperScanner 持有 BeanDefinitionRegistry 引用，可以添加 BeanDefinition</span><br><span class="line">        ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);</span><br><span class="line"></span><br><span class="line">        // 省略部分代码……，设置 ClassPathMapperScanner 各种属性</span><br><span class="line"></span><br><span class="line">        // 扫描并注册 Dao 接口的 BeanDefinition，当然是通过动态代理实现</span><br><span class="line">        scanner.scan(StringUtils.tokenizeToStringArray(this.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="InstantiationAwareBeanPostProcessor接口"><a href="#InstantiationAwareBeanPostProcessor接口" class="headerlink" title="InstantiationAwareBeanPostProcessor接口"></a>InstantiationAwareBeanPostProcessor接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface InstantiationAwareBeanPostProcessor extends BeanPostProcessor &#123;</span><br><span class="line">    Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) throws BeansException;</span><br><span class="line">    boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException;</span><br><span class="line">    PropertyValues postProcessPropertyValues(</span><br><span class="line">            PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>BeanPostProcessor的子接口，用于在实例化之后，但在设置显式属性或自动装配之前，设置实例化之前的回调函数。通常用于抑制特定目标bean的默认实例化，例如，创建具有特殊TargetSources（池化目标，延迟初始化目标等）的代理，或者实现其他注入策略，例如字段注入。注意：这个接口是一个专用接口，主要用于框架内的内部使用。 建议尽可能实现简单的BeanPostProcessor接口，或者从InstantiationAwareBeanPostProcessorAdapter派生，以便屏蔽此接口的扩展。</li>
<li>postProcessBeforeInstantiation方法，在目标bean实例化之前创建bean，如果在这里创建了bean，则不会走默认的实例化过程，通常用来创建代理。注意工厂方法生成的bean不会走这个方法。</li>
<li>postProcessAfterInstantiation方法，在目标bean实例化后，但是没有进行属性填充前执行的方法。</li>
<li>postProcessPropertyValues方法，在将给定属性值设置到到给定的bean后，对其进行后处理。 允许检查所有的依赖关系是否被满足，例如基于bean属性设置器上的“Required”注解。还允许替换要应用的属性值，通常通过创建基于原始PropertyValues的新MutablePropertyValues实例，添加或删除特定值。</li>
</ul>
<p>接口应用</p>
<ul>
<li>spring不建议用户直接实现，如果必须在这些扩展点应用自己的回调函数，spring建议继承InstantiationAwareBeanPostProcessorAdapter，重写相应的方法即可。</li>
<li>org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator，基于beanName创建代理，就是应用了这个接口，在生成bean前生成代理bean，从而替代默认的实例化。</li>
</ul>
<h3 id="SmartInstantiationAwareBeanPostProcessor"><a href="#SmartInstantiationAwareBeanPostProcessor" class="headerlink" title="SmartInstantiationAwareBeanPostProcessor"></a>SmartInstantiationAwareBeanPostProcessor</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface SmartInstantiationAwareBeanPostProcessor extends InstantiationAwareBeanPostProcessor &#123;</span><br><span class="line"> </span><br><span class="line">// 预测Bean的类型，返回第一个预测成功的Class类型，如果不能预测返回null</span><br><span class="line">    Class&lt;?&gt; predictBeanType(Class&lt;?&gt; beanClass, String beanName) throws BeansException;</span><br><span class="line">// 选择合适的构造器，比如目标对象有多个构造器，在这里可以进行一些定制化，选择合适的构造器</span><br><span class="line">// beanClass参数表示目标实例的类型，beanName是目标实例在Spring容器中的name</span><br><span class="line">// 返回值是个构造器数组，如果返回null，会执行下一个PostProcessor的determineCandidateConstructors方法；否则选取该PostProcessor选择的构造器</span><br><span class="line">    Constructor&lt;?&gt;[] determineCandidateConstructors(Class&lt;?&gt; beanClass, String beanName) throws BeansException;</span><br><span class="line">// 获得提前暴露的bean引用。主要用于解决循环引用的问题</span><br><span class="line">// 只有单例对象才会调用此方法</span><br><span class="line">    Object getEarlyBeanReference(Object bean, String beanName) throws BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getEarlyBeanReference调用时机</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) &#123;</span><br><span class="line">        Object exposedObject = bean;</span><br><span class="line">        if (bean != null &amp;&amp; !mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">            for (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">                if (bp instanceof SmartInstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                    SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                    exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">                    if (exposedObject == null) &#123;</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return exposedObject;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>determineCandidateConstructors调用时机</p>
<p>检测Bean的构造器，可以检测出多个候选构造器，再有相应的策略决定使用哪一个，如AutowiredAnnotationBeanPostProcessor实现将自动扫描通过@Autowired/@Value注解的构造器从而可以完成构造器注入</p>
<h3 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h3><p>BeanPostProcessor允许对bean的实例进行个些自定义的个性，比如检查标记接口、使用代理包装bean实例。spring可以自动检测容器中定义的 BeanPostProcessor，后续创建的bean便会被该BeanPostProcessor处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanPostProcessor &#123;</span><br><span class="line"></span><br><span class="line">    // 初始化之后被调用，已完成注入，但是尚未执行 InitializingBean#afterPropertiesSet() 方法，或者自定义的 init 方法</span><br><span class="line">    Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;</span><br><span class="line"></span><br><span class="line">    // 初始化之后被调用</span><br><span class="line">    Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用：</p>
<ul>
<li>注解注入、AOP <ul>
<li>AnnotationAwareAspectJAutoProxyCreator 在bean的实例化、或者初始化之后创建代理，从而实现 aop 功能。</li>
<li>spring 根据 BeanDefinition 对bean进行实例化之后，会遍历容器内部注册的 InstantiationAwareBeanPostProcessor(BeanPostProcessor的子类)进行属性填充。</li>
<li>AutowiredAnnotationBeanPostProcessor，它会处理 @Autowired、@Value 注解，从而完成注入的功能</li>
<li>CommonAnnotationBeanPostProcessor 也是如此，只是处理不同的注解而已</li>
<li>注解注入的检查机制RequiredAnnotationBeanPostProcessor，执行的优先级较低(通过 Ordered 控制)</li>
<li>ApplicationContextAwareProcessor</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class AspectJAutoProxyBeanDefinitionParser implements BeanDefinitionParser &#123;</span><br><span class="line"> @Override</span><br><span class="line"> public BeanDefinition parse(Element element, ParserContext parserContext) &#123;</span><br><span class="line">    //注册特殊的bean</span><br><span class="line">  AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);</span><br><span class="line">  extendBeanDefinition(element, parserContext);</span><br><span class="line">  return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AnnotationAwareAspectJAutoProxyCreator extends AspectJAwareAdvisorAutoProxyCreator &#123;</span><br><span class="line">  public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">        if (bean != null) &#123;</span><br><span class="line">          Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">          if (!this.earlyProxyReferences.containsKey(cacheKey)) &#123;</span><br><span class="line">            //如果该类需要被代理，返回动态代理对象；反之，返回原对象</span><br><span class="line">            return wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return bean;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class ApplicationContextAwareProcessor implements BeanPostProcessor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object postProcessBeforeInitialization(final Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">        // 省略 AccessControlContext 处理的代码</span><br><span class="line">        invokeAwareInterfaces(bean);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void invokeAwareInterfaces(Object bean) &#123;</span><br><span class="line">        if (bean instanceof Aware) &#123;</span><br><span class="line">            if (bean instanceof ApplicationEventPublisherAware) &#123;</span><br><span class="line">                ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);</span><br><span class="line">            &#125;</span><br><span class="line">            // 省略部分代码……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">以@Resource为例，看看这个特殊的bean做了什么</span><br><span class="line"></span><br><span class="line">public class CommonAnnotationBeanPostProcessor extends InitDestroyAnnotationBeanPostProcessor</span><br><span class="line">  implements InstantiationAwareBeanPostProcessor, BeanFactoryAware, Serializable &#123;</span><br><span class="line">     </span><br><span class="line">      public PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, </span><br><span class="line">      Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">          InjectionMetadata metadata = findResourceMetadata(beanName, bean.getClass());</span><br><span class="line">          try &#123;</span><br><span class="line">            //属性注入</span><br><span class="line">            metadata.inject(bean, beanName, pvs);</span><br><span class="line">          &#125;</span><br><span class="line">          catch (Throwable ex) &#123;</span><br><span class="line">            throw new BeanCreationException(beanName, &quot;Injection of resource dependencies failed&quot;, ex);</span><br><span class="line">          &#125;</span><br><span class="line">          return pvs;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="invokeAware"><a href="#invokeAware" class="headerlink" title="invokeAware"></a>invokeAware</h3><p>实现BeanFactoryAware接口的类，会由容器执行setBeanFactory方法将当前的容器BeanFactory注入到类中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">class BeanFactoryHolder implements BeanFactoryAware&#123;</span><br><span class="line">   </span><br><span class="line">    private static BeanFactory beanFactory;</span><br><span class="line">    </span><br><span class="line">    public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">        this.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="afterPropertySet-和init-method"><a href="#afterPropertySet-和init-method" class="headerlink" title="afterPropertySet()和init-method"></a>afterPropertySet()和init-method</h3><p>目前很多Java中间件都是基本Spring Framework搭建的，而这些中间件经常把入口放到afterPropertySet或者自定义的init中</p>
<h3 id="destroy-和destroy-method"><a href="#destroy-和destroy-method" class="headerlink" title="destroy()和destroy-method"></a>destroy()和destroy-method</h3><p>bean生命周期的最后一个扩展点，该方法用于执行一些bean销毁前的准备工作，比如将当前bean持有的一些资源释放掉</p>
<h3 id="ApplicationListener"><a href="#ApplicationListener" class="headerlink" title="ApplicationListener"></a>ApplicationListener</h3><p>用于接收spring的事件通知，比如常用的ContextRefreshedEvent事件，spring 在成功完成refresh动作之后便会发出该事件，代表spring容器已经完成初始化了，可以做一些额外的处理了，比如开启 spring 定时任务、拉取 MQ 消息，等等。<br>spring 处理 @Scheduled 注解的部分实现，在收到 Refresh 事件之后对 ScheduledTaskRegistrar 进行额外的设置，并开启定时任务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ScheduledAnnotationBeanPostProcessor</span><br><span class="line">        implements MergedBeanDefinitionPostProcessor, DestructionAwareBeanPostProcessor,</span><br><span class="line">        Ordered, EmbeddedValueResolverAware, BeanNameAware, BeanFactoryAware, ApplicationContextAware,</span><br><span class="line">        SmartInitializingSingleton, ApplicationListener&lt;ContextRefreshedEvent&gt;, DisposableBean &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onApplicationEvent(ContextRefreshedEvent event) &#123;</span><br><span class="line">        if (event.getApplicationContext() == this.applicationContext) &#123;</span><br><span class="line">            finishRegistration();   // 对 ScheduledTaskRegistrar 进行额外的设置，并开启定时任务</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 其它代码......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FactoryBean-扩展点"><a href="#FactoryBean-扩展点" class="headerlink" title="FactoryBean 扩展点"></a>FactoryBean 扩展点</h3><p>FactoryBean主要用来定制化Bean的创建逻辑。</p>
<p>FactoryBean 接口提供了三个方法：</p>
<ul>
<li>Object getObject()：返回这个 FactoryBean 所创建的对象。</li>
<li>boolean isSingleton()：返回 FactoryBean 所创建的对象是否为单例，默认返回 true。</li>
<li>Class getObjectType()：返回这个 FactoryBean 所创建的对象的类型，如果我们能确认返回对象的类型的话，我们应该正常对这个方法做出实现，而不是返回 null。</li>
</ul>
<p>假设定义了一个FactoryBean，名为MyFactoryBean，当我们调用 getBean(“MyFactoryBean”)方法时返回的并不是这个FactoryBean，而是这个FactoryBean所创建的 Bean，如果我们想获取到这个FactoryBean 需要在名字前面拼接”&amp;”，例如这种形式：getBean(“&amp;MyFactoryBean”)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">public static boolean isFactoryDereference(@Nullable String name) &#123;</span><br><span class="line">    return name != null &amp;&amp; name.startsWith(&quot;&amp;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected Object getObjectForBeanInstance(Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) &#123;</span><br><span class="line">    //判断beanName是不是&amp;开头</span><br><span class="line">    if (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">        if (beanInstance instanceof NullBean) &#123;</span><br><span class="line">            return beanInstance;</span><br><span class="line">        &#125; else if (!(beanInstance instanceof FactoryBean)) &#123;</span><br><span class="line">            throw new BeanIsNotAFactoryException(beanName, beanInstance.getClass());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (mbd != null) &#123;</span><br><span class="line">                mbd.isFactoryBean = true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return beanInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;//判断beanInstance 不是factory bean的子类直接返回 </span><br><span class="line">    else if (!(beanInstance instanceof FactoryBean)) &#123;</span><br><span class="line">        return beanInstance;</span><br><span class="line">    &#125; </span><br><span class="line">    // beanname非&amp;开头，且factory bean的子类</span><br><span class="line">    else &#123;</span><br><span class="line">        Object object = null;</span><br><span class="line">        if (mbd != null) &#123;</span><br><span class="line">            mbd.isFactoryBean = true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //从缓存里取对象</span><br><span class="line">            object = this.getCachedObjectForFactoryBean(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        //缓存没有取到</span><br><span class="line">        if (object == null) &#123;</span><br><span class="line">            FactoryBean&lt;?&gt; factory = (FactoryBean)beanInstance;</span><br><span class="line">            if (mbd == null &amp;&amp; this.containsBeanDefinition(beanName)) &#123;</span><br><span class="line">                mbd = this.getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            boolean synthetic = mbd != null &amp;&amp; mbd.isSynthetic();</span><br><span class="line">            //调用factorybean getobject方法</span><br><span class="line">            object = this.getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">protected Object getObjectFromFactoryBean(FactoryBean&lt;?&gt; factory, String beanName, boolean shouldPostProcess) &#123;</span><br><span class="line">        if (factory.isSingleton() &amp;&amp; this.containsSingleton(beanName)) &#123;</span><br><span class="line">            synchronized(this.getSingletonMutex()) &#123;</span><br><span class="line">                Object object = this.factoryBeanObjectCache.get(beanName);</span><br><span class="line">                if (object == null) &#123;</span><br><span class="line">                    //调用factorybean getobject方法</span><br><span class="line">                    object = this.doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">                    Object alreadyThere = this.factoryBeanObjectCache.get(beanName);</span><br><span class="line">                </span><br><span class="line">                if (alreadyThere != null) &#123;</span><br><span class="line">                        object = alreadyThere;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        if (shouldPostProcess) &#123;</span><br><span class="line">                            if (this.isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">                                return object;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            this.beforeSingletonCreation(beanName);</span><br><span class="line"></span><br><span class="line">                            try &#123;</span><br><span class="line">                                object = this.postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">                            &#125; catch (Throwable var14) &#123;</span><br><span class="line">                                throw new BeanCreationException(beanName, &quot;Post-processing of FactoryBean&#x27;s singleton object failed&quot;, var14);</span><br><span class="line">                            &#125; finally &#123;</span><br><span class="line">                                this.afterSingletonCreation(beanName);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        //判断是否单例，存缓存里</span><br><span class="line">                        if (this.containsSingleton(beanName)) &#123;</span><br><span class="line">                            this.factoryBeanObjectCache.put(beanName, object);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="扩展点之间的调用顺序"><a href="#扩展点之间的调用顺序" class="headerlink" title="扩展点之间的调用顺序"></a>扩展点之间的调用顺序</h3><p><img src="/2022/03/31/spring/a.png" alt="a"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.imder.top/2022/03/31/redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ren zheng xiao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="随记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/31/redis/" class="post-title-link" itemprop="url">redis</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-31 09:10:00" itemprop="dateCreated datePublished" datetime="2022-03-31T09:10:00+00:00">2022-03-31</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2024-03-28 16:43:20" itemprop="dateModified" datetime="2024-03-28T16:43:20+00:00">2024-03-28</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><h2 id="aof重写"><a href="#aof重写" class="headerlink" title="aof重写"></a>aof重写</h2><h3 id="aof重写原因"><a href="#aof重写原因" class="headerlink" title="aof重写原因"></a>aof重写原因</h3><ul>
<li>AOF 持久化是通过保存被执行的写命令来记录数据库状态的，所以AOF文件的大小随着时间的流逝一定会越来越大；影响包括但不限于：对于Redis服务器，计算机的存储压力；AOF还原出数据库状态的时间增加；</li>
<li>为了解决AOF文件体积膨胀的问题，Redis提供了AOF重写功能：Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个文件所保存的数据库状态是相同的，但是新的AOF文件不会包含任何浪费空间的冗余命令，通常体积会较旧AOF文件小很多。</li>
</ul>
<h3 id="AOF重写功能的实现原理"><a href="#AOF重写功能的实现原理" class="headerlink" title="AOF重写功能的实现原理"></a>AOF重写功能的实现原理</h3><p>AOF重写功能的实现原理：从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录该键值对的多个命令;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">def AOF_REWRITE(tmp_tile_name):</span><br><span class="line"></span><br><span class="line">  f = create(tmp_tile_name)</span><br><span class="line"></span><br><span class="line">  # 遍历所有数据库</span><br><span class="line">  for db in redisServer.db:</span><br><span class="line"></span><br><span class="line">    # 如果数据库为空，那么跳过这个数据库</span><br><span class="line">    if db.is_empty(): continue</span><br><span class="line"></span><br><span class="line">    # 写入 SELECT 命令，用于切换数据库</span><br><span class="line">    f.write_command(&quot;SELECT &quot; + db.number)</span><br><span class="line"></span><br><span class="line">    # 遍历所有键</span><br><span class="line">    for key in db:</span><br><span class="line"></span><br><span class="line">      # 如果键带有过期时间，并且已经过期，那么跳过这个键</span><br><span class="line">      if key.have_expire_time() and key.is_expired(): continue</span><br><span class="line"></span><br><span class="line">      if key.type == String:</span><br><span class="line"></span><br><span class="line">        # 用 SET key value 命令来保存字符串键</span><br><span class="line"></span><br><span class="line">        value = get_value_from_string(key)</span><br><span class="line"></span><br><span class="line">        f.write_command(&quot;SET &quot; + key + value)</span><br><span class="line"></span><br><span class="line">      elif key.type == List:</span><br><span class="line"></span><br><span class="line">        # 用 RPUSH key item1 item2 ... itemN 命令来保存列表键</span><br><span class="line"></span><br><span class="line">        item1, item2, ..., itemN = get_item_from_list(key)</span><br><span class="line"></span><br><span class="line">        f.write_command(&quot;RPUSH &quot; + key + item1 + item2 + ... + itemN)</span><br><span class="line"></span><br><span class="line">      elif key.type == Set:</span><br><span class="line"></span><br><span class="line">        # 用 SADD key member1 member2 ... memberN 命令来保存集合键</span><br><span class="line"></span><br><span class="line">        member1, member2, ..., memberN = get_member_from_set(key)</span><br><span class="line"></span><br><span class="line">        f.write_command(&quot;SADD &quot; + key + member1 + member2 + ... + memberN)</span><br><span class="line"></span><br><span class="line">      elif key.type == Hash:</span><br><span class="line"></span><br><span class="line">        # 用 HMSET key field1 value1 field2 value2 ... fieldN valueN 命令来保存哈希键</span><br><span class="line"></span><br><span class="line">        field1, value1, field2, value2, ..., fieldN, valueN =\</span><br><span class="line">        get_field_and_value_from_hash(key)</span><br><span class="line"></span><br><span class="line">        f.write_command(&quot;HMSET &quot; + key + field1 + value1 + field2 + value2 +\</span><br><span class="line">                        ... + fieldN + valueN)</span><br><span class="line"></span><br><span class="line">      elif key.type == SortedSet:</span><br><span class="line"></span><br><span class="line">        # 用 ZADD key score1 member1 score2 member2 ... scoreN memberN</span><br><span class="line">        # 命令来保存有序集键</span><br><span class="line"></span><br><span class="line">        score1, member1, score2, member2, ..., scoreN, memberN = \</span><br><span class="line">        get_score_and_member_from_sorted_set(key)</span><br><span class="line"></span><br><span class="line">        f.write_command(&quot;ZADD &quot; + key + score1 + member1 + score2 + member2 +\</span><br><span class="line">                        ... + scoreN + memberN)</span><br><span class="line"></span><br><span class="line">      else:</span><br><span class="line"></span><br><span class="line">        raise_type_error()</span><br><span class="line"></span><br><span class="line">      # 如果键带有过期时间，那么用 EXPIREAT key time 命令来保存键的过期时间</span><br><span class="line">      if key.have_expire_time():</span><br><span class="line">        f.write_command(&quot;EXPIREAT &quot; + key + key.expire_time_in_unix_timestamp())</span><br><span class="line"></span><br><span class="line">    # 关闭文件</span><br><span class="line">    f.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="aof子线程重写"><a href="#aof子线程重写" class="headerlink" title="aof子线程重写"></a>aof子线程重写</h3><ul>
<li><p>aof子线程重写原因</p>
<ul>
<li>aof_rewrite函数创建新文件并进行大量写入操作，调用这个函数的线程将被长时间的阻塞</li>
<li>Redis服务器使用单线程来处理命令请求，如果直接是服务器进程调用AOF_REWRITE函数的话，重写AOF期间，服务器将无法处理客户端发送来的命令请求</li>
<li>Redis不希望AOF重写会造成服务器无法处理请求，所以Redis决定将AOF重写程序放到子进程（后台）里执行。</li>
</ul>
</li>
<li><p>使用子进程进行AOF重写的问题</p>
<ul>
<li>子进程在进行AOF重写期间，服务器进程还要继续处理命令请求，而新的命令可能对现有的数据进行修改，这会让当前数据库的数据和重写后的AOF文件中的数据不一致。</li>
</ul>
</li>
<li><p>解决数据不一致问题</p>
<ul>
<li>Redis增加了一个AOF重写缓存，这个缓存在fork出子进程之后开始启用</li>
<li>Redis服务器主进程在执行完写命令之后，会同时将这个写命令追加到AOF缓冲区和AOF重写缓冲区</li>
<li>当子进程完成对AOF文件重写之后，会向父进程发送一个完成信号，父进程接到该完成信号之后，会调用一个信号处理函数<ul>
<li>将AOF重写缓存中的内容全部写入到新的AOF文件中；这个时候新的AOF文件所保存的数据库状态和服务器当前的数据库状态一致；</li>
<li>新的AOF文件进行改名，原子的覆盖原有的AOF文件；完成新旧两个AOF文件的替换。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h3><ul>
<li>从服务器连接主服务器，发送SYNC命令； </li>
<li>主服务器接收到SYNC命名后，开始执行BGSAVE命令子线程生成RDB文件并使用缓冲区记录此后执行的所有写命令； </li>
<li>主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令； </li>
<li>从服务器收到快照文件后丢弃所有旧数据，载入收到的快照； </li>
<li>主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令； </li>
<li>从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令； </li>
</ul>
<h3 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h3><ul>
<li>Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。 </li>
<li>增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令</li>
</ul>
<h3 id="Redis主从同步策略"><a href="#Redis主从同步策略" class="headerlink" title="Redis主从同步策略"></a>Redis主从同步策略</h3><p>主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</p>
<h3 id="主从同步存在的问题"><a href="#主从同步存在的问题" class="headerlink" title="主从同步存在的问题"></a>主从同步存在的问题</h3><ul>
<li>数据不一致，网络传输延迟，读数据读取从库</li>
<li>读取过期时间的key,从库读取,3.2之前的不检查过期, 会返回数据, 3.2之后虽然不删除过期数据, 但是返回空值</li>
</ul>
<h2 id="主从切换"><a href="#主从切换" class="headerlink" title="主从切换"></a>主从切换</h2><h3 id="切换方式"><a href="#切换方式" class="headerlink" title="切换方式"></a>切换方式</h3><ul>
<li>手动切换<ul>
<li>手动将从节点设置成主节点。命令：redis-cli -h &lt;从节点ip&gt; -p &lt;从节点端口号&gt; slaveof no one</li>
</ul>
</li>
<li>哨兵模式<ul>
<li>Sentinel实例可以自动的将主节点下的其中一个从节点升级为新的主节点</li>
<li>Sentinel实例会不断检测主从节点是否正常运</li>
<li>当某个节点出现异常宕机时，Sentinel实例会向管理员或者其他应用发送提醒</li>
<li>当主节点宕机时，Sentinel实例会将该主节点下的其中一个从节点升级为新的主节点，并且原先其他从节点重新发起socket请求成为新的主节点的从节点</li>
<li>向客户端返回新主节点的地址，就可以正常上使用新的主节点来处理请求</li>
</ul>
</li>
</ul>
<h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>只开启一个Sentinel实例进行监视，容易出现问题，一般情况下会开启多个Sentinel实例进行监控，一般情况下至少需要3个Sentinel实例。<br>主节点宕机状态<br>    - 只有一个哨兵认为这个主节点宕机了，则成为主观宕机。<br>    - 如果达到一定数量的节点认为该主节点宕机，则成为客观宕机。</p>
<p>为什么至少需要3个Sentinel实例？</p>
<ul>
<li>当指定时间内一定哨兵数量（哨兵数量 / 2 + 1）都认为主节点宕机则称为客观宕机，如果数量为2，出现一个哨兵宕机的情况，在需要主从切换的时候因为无法达到认为主节点宕机的哨兵数量为2，所以在主节点出现宕机时无法进行主从切换。所以说部署哨兵至少需要3个Sentinel实例来保证健壮性。</li>
</ul>
<h3 id="哨兵模式引发数据丢失问题"><a href="#哨兵模式引发数据丢失问题" class="headerlink" title="哨兵模式引发数据丢失问题"></a>哨兵模式引发数据丢失问题</h3><p>哨兵模式 + Redis主从复制这种部署结构，无法保证数据不会出现丢失。<br>哨兵模式下数据丢失主要有两种情况：<br>因为主从复制是异步操作，可能主从复制还没成功，主节点宕机了。这时候还没成功复制的数据就会丢失了。<br>如果主节点无法与其他从节点连接，但是实际上还在运行。这时候哨兵会将一个从节点切换成新的主节点，但是在这个过程中实际上主节点还在运行，所以继续向这个主节点写入的数据会被丢失。</p>
<h3 id="解决数据丢失方案"><a href="#解决数据丢失方案" class="headerlink" title="解决数据丢失方案"></a>解决数据丢失方案</h3><p>使用命令：<br>min-slaves-to-write 1<br>min-slaves-max-lag 10<br>使用这组命令可以设置至少有一个从节点数据复制延迟不能超过10S，也就是说如果一个直接点下所有从节点数据复制延迟都超过10S，则停止主节点继续接收处理新的请求。这样可以保证数据丢失最多只会丢失10S内的数据。</p>
<h2 id="redis-持久化方案"><a href="#redis-持久化方案" class="headerlink" title="redis 持久化方案"></a>redis 持久化方案</h2><p>数据库的恢复<br>服务器启动时，如果没有开启AOF持久化功能，则会自动载入RDB文件，期间会阻塞主进程。如果开启了AOF持久化功能，服务器则会优先使用AOF文件来还原数据库状态，因为AOF文件的更新频率通常比RDB文件的更新频率高，保存的数据更完整。</p>
<h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><ul>
<li>RDB持久化即通过创建快照（压缩的二进制文件）的方式进行持久化，保存某个时间点的全量数据。RDB持久化是Redis默认的持久化方式。</li>
<li>触发方式<ul>
<li>手动触发<ul>
<li>save， 在命令行执行save命令，将以同步的方式创建rdb文件保存快照，会阻塞服务器的主进程，生产环境中不要用    </li>
<li>bgsave, 在命令行执行bgsave命令，将通过fork一个子进程以异步的方式创建rdb文件保存快照，除了fork时有阻塞，子进程在创建rdb文件时，主进程可继续处理请求</li>
</ul>
</li>
<li>自动触发<ul>
<li>在redis.conf中配置 save m n 定时触发，如 save 900 1表示在900s内至少存在一次更新就触发</li>
<li>主从复制时，如果从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从节点</li>
<li>执行debug reload命令重新加载Redis时</li>
<li>执行shutdown且没有开启AOF持久化</li>
<li>redis.conf中RDB持久化配置<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 只要满足下列条件之一，则会执行bgsave命令</span><br><span class="line">save 900 1 # 在900s内存在至少一次写操作</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"># 禁用RBD持久化，可在最后加 save &quot;&quot;</span><br><span class="line"></span><br><span class="line"># 当备份进程出错时主进程是否停止写入操作</span><br><span class="line">stop-writes-on-bgsave-error yes  </span><br><span class="line"># 是否压缩rdb文件 推荐no 相对于硬盘成本cpu资源更贵</span><br><span class="line">rdbcompression no</span><br></pre></td></tr></table></figure>
<h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3>AOF（Append-Only-File）持久化即记录所有变更数据库状态的指令，以append的形式追加保存到AOF文件中。在服务器下次启动时，通过载入和执行AOF文件中保存的命令，来还原服务器关闭前的数据库状态。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>redis.conf中AOF持久化配置如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 默认关闭AOF，若要开启将no改为yes</span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"># append文件的名字</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"># 每隔一秒将缓存区内容写入文件 默认开启的写入方式</span><br><span class="line">appendfsync everysec </span><br><span class="line"></span><br><span class="line"># 当AOF文件大小的增长率大于该配置项时自动开启重写（这里指超过原大小的100%）。</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"></span><br><span class="line"># 当AOF文件大小大于该配置项时自动开启重写</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>AOF持久化的实现包括3个步骤:</p>
<p>命令追加：将命令追加到AOF缓冲区<br>文件写入：缓冲区内容写到AOF文件<br>文件保存：AOF文件保存到磁盘<br>其中后两步的频率通过appendf sync来配置，appendfsync的选项包括</p>
<p>always， 每执行一个命令就保存一次，安全性最高，最多只丢失一个命令的数据，但是性能也最低（频繁的磁盘IO）<br>everysec，每一秒保存一次，推荐使用，在安全性与性能之间折中，最多丢失一秒的数据<br>no， 依赖操作系统来执行（一般大概30s一次的样子），安全性最低，性能最高，丢失操作系统最后一次对AOF文件触发SAVE操作之后的数据</p>
<h3 id="RDB-vs-AOF"><a href="#RDB-vs-AOF" class="headerlink" title="RDB vs AOF"></a>RDB vs AOF</h3><p>RDB与AOF两种方式各有优缺点。</p>
<p>RDB的优点：与AOF相比，RDB文件相对较小，恢复数据比较快（原因见数据恢复部分）<br>RDB的缺点：服务器宕机，RBD方式会丢失掉上一次RDB持久化后的数据；使用bgsave fork子进程时会耗费内存。</p>
<p>AOF的优点： AOF只是追加文件，对服务器性能影响较小，速度比RDB快，消耗内存也少，同时可读性高。<br>AOF的缺点：生成的文件相对较大，即使通过AOF重写，仍然会比较大；恢复数据的速度比RDB慢。</p>
<h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><p><img src="/2022/03/31/redis/qidong.png" alt="qidong.png"></p>
<h3 id="RDB、AOF混合持久化"><a href="#RDB、AOF混合持久化" class="headerlink" title="RDB、AOF混合持久化"></a>RDB、AOF混合持久化</h3><p>Redis从4.0版开始支持RDB与AOF的混合持久化方案。首先由RDB定期完成内存快照的备份，然后再由AOF完成两次RDB之间的数据备份，由这两部分共同构成持久化文件。该方案的优点是充分利用了RDB加载快、备份文件小及AOF尽可能不丢数据的特性。缺点是兼容性差，一旦开启了混合持久化，在4.0之前的版本都不识别该持久化文件，同时由于前部分是RDB格式，阅读性较低。</p>
<ul>
<li>开启混合持久化 aof-use-rdb-preamble yes</li>
<li>数据恢复加载过程就是先按照RDB进行加载，然后把AOF命令追加写入。</li>
</ul>
<h3 id="持久化方案的建议"><a href="#持久化方案的建议" class="headerlink" title="持久化方案的建议"></a>持久化方案的建议</h3><p>Redis只用来做缓存服务器，比如数据库查询数据后缓存，可以不用考虑持久化，因为缓存服务失效还能再从数据库获取恢复。<br>提供很高的数据保障性，建议你同时使用两种持久化方式。如果可以接受灾难带来的几分钟的数据丢失，那么可以仅使用RDB。<br>通常的设计思路是利用主从复制机制来弥补持久化时性能上的影响。即Master上RDB、AOF都不做，保证Master的读写性能，而Slave上则同时开启RDB和AOF（或4.0以上版本的混合持久化方式）来进行持久化，保证数据的安全性。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.imder.top/2022/03/08/%08JM%E8%B0%83%E4%BC%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ren zheng xiao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="随记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/08/%08JM%E8%B0%83%E4%BC%98/" class="post-title-link" itemprop="url">jm调优</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-08 09:00:00" itemprop="dateCreated datePublished" datetime="2022-03-08T09:00:00+00:00">2022-03-08</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2024-03-28 16:43:20" itemprop="dateModified" datetime="2024-03-28T16:43:20+00:00">2024-03-28</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">JAVA虚拟机</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="jm调优"><a href="#jm调优" class="headerlink" title="jm调优"></a>jm调优</h1><h2 id="遇到了什么问题需要调优？"><a href="#遇到了什么问题需要调优？" class="headerlink" title="遇到了什么问题需要调优？"></a>遇到了什么问题需要调优？</h2><p>生产环境新上线了一个系统，莫名其妙奔溃，错误日志报异常OOM</p>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 -&gt; 使用 -&gt; 卸载</p>
<h3 id="什么情况下会去加载一个类呢"><a href="#什么情况下会去加载一个类呢" class="headerlink" title="什么情况下会去加载一个类呢?"></a>什么情况下会去加载一个类呢?</h3><p>何时将“.class”字节码文件中加载这个类到JVM内存里来，代码中用到这个类的时候。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>来校验加载进来的“.class”文件中的内容，是否符合指定的jvm规范。</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>类的类变量(static修饰的变量)分配内存空间，来一个默认的初始值，并非执行赋值</p>
<h3 id="解析阶段"><a href="#解析阶段" class="headerlink" title="解析阶段"></a>解析阶段</h3><p>符号引用替换为直接引用</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>执行类变量的赋值语句，执行静态代码块</p>
<h2 id="类加载器和双亲委派机制"><a href="#类加载器和双亲委派机制" class="headerlink" title="类加载器和双亲委派机制"></a>类加载器和双亲委派机制</h2><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul>
<li>启动类加载器<br>Bootstrap ClassLoader，负责加载Java安装目录下的“lib”目录中的核心类库</li>
<li>扩展类加载器<br>Extension ClassLoader，负责加载Java安装目录“lib\ext”目录里面有一些类</li>
<li>应用程序类加载器<br>Application ClassLoader，负责去加载“ClassPath”环境变量所指定的路径中的类 理解为去加载自己写好的Java代码</li>
<li>自定义类加载器 除了上面那几种之外，还可以自定义类加载器，去根据自己的需求加载自己的类。<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3></li>
<li>JVM的类加载器是有亲子层级结构的，启动类加载器是最上层的，扩展类加载器在第二层，第三层是应用程序类加载器，最后一层是自定义类加载器。</li>
<li>双亲委派模型:先找父亲去加载，不行的话再由自己来加载。</li>
</ul>
<h2 id="内存划分"><a href="#内存划分" class="headerlink" title="内存划分"></a>内存划分</h2><h3 id="方法区（1-8之前）-元空间"><a href="#方法区（1-8之前）-元空间" class="headerlink" title="方法区（1.8之前） 元空间"></a>方法区（1.8之前） 元空间</h3><p>将“.class”文件里加载进来的类</p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>写好的Java代码会被翻译成字节码，对应各种字节码指令，JVM加载类信息到内存之后，会使用自己的字节码执行引擎执行字节码指令，执行时，JVM里就需要一个特殊的内存区域，那就是“程序计数器”，这个程序计数器就是用来记录当前执行的字节码指令的位置的</p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><ul>
<li>JVM必须有一块区域是来保存每个方法内的局部变量等数据的，这个区域就是Java虚拟机栈 </li>
<li>每个线程都有自己的Java虚拟机栈</li>
<li>如果线程执行了一个方法，就会对这个方法调用创建对应的一个栈帧，栈帧里就有这个方法的局部变量表 、操作数栈、动态链接、方法出口</li>
</ul>
<h3 id="Java堆内存"><a href="#Java堆内存" class="headerlink" title="Java堆内存"></a>Java堆内存</h3><p>存放代码中创建的各种对象的</p>
<h2 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h2><h3 id="jvm参数"><a href="#jvm参数" class="headerlink" title="jvm参数"></a>jvm参数</h3><ul>
<li>-Xms:Java堆内存的大小 、-Xmx:Java堆内存的最大大小 </li>
<li>-Xms和-Xmx，分别用于设置Java堆内存的刚开始的大小，以及允许扩张到的最大大小。</li>
<li>-Xmn:Java堆内存中的新生代大小，扣除新生代剩下的就是老年代的内存大小,默认不设置新生代大小时，大概老年代占2/3，新生代占1/3，eden和2个survivor 8:1:1  jvm参数”- XX:SurvivorRatio=8”</li>
<li>-XX:PermSize:永久代大小、-XX:MaxPermSize:永久代最大大小</li>
<li>jdk1.8 用这两个-XX:MetaspaceSize和-XX:MaxMetaspaceSize替换永久代大小</li>
<li>-Xss:每个线程的栈内存大小</li>
</ul>
<h3 id="如何合理设置永久代大小"><a href="#如何合理设置永久代大小" class="headerlink" title="如何合理设置永久代大小?"></a>如何合理设置永久代大小?</h3><p>一般你设置个几百MB，大体上都是够用的 因为里面主要就是存放一些类的信息</p>
<h3 id="如何合理设置栈内存大小"><a href="#如何合理设置栈内存大小" class="headerlink" title="如何合理设置栈内存大小"></a>如何合理设置栈内存大小</h3><p>一般默认就是比如512KB到1MB</p>
<h3 id="如何确定对象是垃圾？可达性分析算法GCRoot根由那些对象组成？"><a href="#如何确定对象是垃圾？可达性分析算法GCRoot根由那些对象组成？" class="headerlink" title="如何确定对象是垃圾？可达性分析算法GCRoot根由那些对象组成？"></a>如何确定对象是垃圾？可达性分析算法GCRoot根由那些对象组成？</h3><p>对象无引用时会被确定为垃圾对象，方法的局部变量、类的静态变量都被看为GCRoot根</p>
<h3 id="垃圾对象一定会被回收吗？"><a href="#垃圾对象一定会被回收吗？" class="headerlink" title="垃圾对象一定会被回收吗？"></a>垃圾对象一定会被回收吗？</h3><p>不一定，如果对象重写了Object类中的finialize()方法，并且在该方法建立起与静态变量的引用关系就可以不被回收</p>
<h3 id="强引用、软引用、弱引用、虚引用"><a href="#强引用、软引用、弱引用、虚引用" class="headerlink" title="强引用、软引用、弱引用、虚引用"></a>强引用、软引用、弱引用、虚引用</h3><p>强引用：绝对不能回收的对象<br>软引用：有的对象可有可无，如果内存实在不够了，可以回收他。<br>弱引用：与没引用是类似的，如果发生垃圾回收，就会把这个对象回收掉<br>虚引用：暂时忽略，很少用。</p>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>复制算法：内存区域划分为两块，对象就就会分配在其中一块内存空间，垃圾回收时，存活对象复制到另一块内存空间，同时原分配对象空间清除所有对象<br>缺点：内存使用率太低 优点：不会产生内存碎片，不浪费内存空间</p>
<p>复制算法做出如下优化：</p>
<ul>
<li>把新生代内存区域划分为三块:1个Eden区，2个Survivor区，其中Eden区占80%内存空间，每一块Survivor区各占10%内存空间</li>
<li>刚开始对象都是分配在Eden区内的，如果Eden区快满了，此时就会触发垃圾回收，把Eden区中的存活对象都一次性转移到一块空着的Survivor区，接着Eden区就会被清空</li>
<li>然后再次分配新对象到Eden区里，此时，Eden区和一块Survivor区里是有对象的，其中Survivor区里放的是上一次Minor GC后存活的对象。如果下次再次Eden区满，那么再次触发Minor GC，Eden区和放着上一次Minor GC后存活对象的Survivor区内的存活对象，转移到另外一块Survivor区去。然后清空eden区和上一次的survivor区</li>
</ul>
<h3 id="对象何时从新生代转到老年代？"><a href="#对象何时从新生代转到老年代？" class="headerlink" title="对象何时从新生代转到老年代？"></a>对象何时从新生代转到老年代？</h3><ul>
<li>15次minor gc对象还存活。JVM参数“-XX:MaxTenuringThreshold”来设置，默认是15岁</li>
<li>动态对象年龄判断：假如说当前放对象的Survivor区域的一些对象大小和（按照年龄排正序）大于了这块Survivor区域的内存大小的50%，那么此时大于等于这批对象年龄的对象，就可以直接进入老年代。年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会把年龄n以上的对象都放入老年代。</li>
<li>大对象直接进入老年代。JVM参数，“-XX:PretenureSizeThreshold”，单位字节数，比如“1048576”字节，就是1MB。</li>
<li>Minor GC后的对象太多无法放入Survivor区怎么办? 这个时候就必须得把这些对象直接转移到老年代去</li>
<li>老年代空间分配担保机制<ul>
<li>在执行任何一次Minor GC之前，JVM会先检查一下老年代可用的可用内存空间，是否大于新生代所有对象的总大小。避免Minor GC后老年代空间放不下存活对象</li>
<li>如果老年代的内存大小是大于新生代所有对象的，此时就可以对新生代发起一次Minor GC了</li>
<li>如果老年代的内存大小是小于新生代所有对象的，JVM“-XX:- HandlePromotionFailure”的参数是否设置,<ul>
<li>未设置 发生一次Full GC（对老年代进行垃圾回收，同时一般会对新生代进行垃圾回收）</li>
<li>设置表示开启老年代空间担保，接着判断老年代的内存大小，是否大于之前每一次Minor GC后进入老年代的对象的平均大小，如果大于，则Minor GC,如果小于，FullGC（年轻代+老年代+永久代）</li>
</ul>
</li>
<li>如果要是Full GC过后，老年代还是没有足够的空间存放Minor GC过后的剩余存活对象，就会导致所谓的 “OOM”内存溢出</li>
</ul>
</li>
</ul>
<h3 id="老年代采用的什么垃圾回收算法？"><a href="#老年代采用的什么垃圾回收算法？" class="headerlink" title="老年代采用的什么垃圾回收算法？"></a>老年代采用的什么垃圾回收算法？</h3><ul>
<li>标记整理算法：首先标记出来老年代当前存活的对象，接着会让这些存活对象在内存里进行移动，把存活对象尽量都挪动到一边去</li>
<li>老年代的垃圾回收算法的速度至少比新生代的垃圾回收算法的速度慢10倍。</li>
<li>如果系统频繁出现老年代的Full GC垃圾回收，会导致系统性能被严重影响，出现频繁卡顿的情况。<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3></li>
<li>Serial和Serial Old垃圾回收器:分别用来回收新生代和老年代的垃圾对象，工作原理就是单线程运行，STW，一般几乎不用。</li>
<li>ParNew和CMS垃圾回收器:ParNew现在一般用在新生代的，CMS是用在老年代的，都是多线程并发的机制，性能更好，一般是生产系统的标配组合。</li>
<li>G1垃圾回收器:统一收集新生代和老年代，采用了更加优秀的算法和设计机制</li>
</ul>
<h3 id="stw"><a href="#stw" class="headerlink" title="stw"></a>stw</h3><p>直接停止Java系统的所有工作线程，让代码不再运行，让垃圾回收线程可以专心致志的进行垃圾回收的工作<br>    - 假设我们的Minor GC要运行100ms，那么可能就会导致系统直接停顿100ms不能处理任何请求<br>    - Full GC是最慢的，有的时候弄不好一次回收要进行几秒钟，甚至几十秒，有的极端场景几分钟都是有可能的。一旦频繁的Full GC，系统每一段时间就卡死个30秒吗?<br>    - 无论是新生代GC还是老年代GC，都尽量不要让频率过高，避免持续时间过长</p>
<h3 id="ParNew垃圾收集器"><a href="#ParNew垃圾收集器" class="headerlink" title="ParNew垃圾收集器"></a>ParNew垃圾收集器</h3><p>暂停系统程序的工作线程，禁止程序继续运行创建新的对象，用多个垃圾回收线程去进行垃圾回收，用复制算法回收<br>使用ParNew垃圾回收器 JVM参数 -XX:+UseParNewGC<br>ParNew垃圾回收器默认情况下的线程数量 垃圾回收线程的数量就是跟CPU的核数是一样。 JVM参数设置 - XX:ParallelGCThreads=n</p>
<h3 id="服务器模式与客户端模式"><a href="#服务器模式与客户端模式" class="headerlink" title="服务器模式与客户端模式"></a>服务器模式与客户端模式</h3><ul>
<li>启动系统的时候是可以区分服务器模式和客户端模式的，启动系统的时候加入“-server”就是服务器模式，如果加入“-cilent”就是客户端模式。</li>
<li>系统部署在比如4核8G的Linux服务器上那么就应该用服务器模式，如果你的系统是运行在比如Windows上的客户端程序，那么就应该是客户端模式。</li>
<li>服务器模式通常ParNew来进行垃圾回收，客户端模式使用采用Serial垃圾回收器，单CPU单线程垃圾回收</li>
</ul>
<h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>CMS垃圾回收器采取的是垃圾回收线程和系统工作线程尽量同时执行的模式来处理的，使用标记-清理的算法<br>初始标记 ：stw 很快，仅仅标记出GC Root根<br>并发标记 ：对老年代所有对象进行GC Roots追踪，其实是最耗时的<br>重新标记 ：stw 很快,对在第二阶段中被系统程序运行变动过的少数对象进行标记<br>并发清理 ：很耗时</p>
<p>缺点：<br>    - 会消耗CPU资源，在并发标记时，老年代存活对象多，追踪大量对象，耗时较高，并发清理，把垃圾对象从随机的内存位置清理掉，也比较耗时，CMS的垃圾回收线程是比较耗费CPU资源的。CMS默认启动的垃圾回收线程的数量是(CPU核数 + 3)/ 4。<br>    - 会产生浮动垃圾，并发清理同时随着系统运行让一些对象进入老年代，这种垃圾需要等到下一次GC才能回收掉</p>
<p>-XX:CMSInitiatingOccupancyFaction 用来设置老年代占用多少时触发CMS垃圾回收，JDK 1.6里面默认的值是 92%。<br>-XX:+UseCMSCompactAtFullCollection 默认开启 Full GC之后再次进行stw，碎片整理<br>-XX:CMSFullGCsBeforeCompaction 执行多少次Full GC之后执行一次内存碎片整理，默认是0，每次Full GC之后都会进行内存整理。</p>
<h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><ul>
<li>评估Eden区进行Minor Gc 之后存活的对象大小，Suvivor区空间够不够，建议的是调整新生代和老年代的大小，让短期存活的对象在新生代就被垃圾回收</li>
<li>结合系统的运行模型，@Service、@Controller之类的注解那种需要长期存活的核心业务逻辑组件，降低“-XX:MaxTenuringThreshold”参数的值，避免对长期存活的对象在新生代Survivor区来回复制</li>
<li>大对象直接进入老年代，-XX:PretenureSizeThreshold=1M，避免对象在新生代Survivor区来回复制<br>一般启动参数：</li>
<li>Xms3072M -Xmx3072M -Xmn2048M -Xss1M -XX:PermSize=256M -XX:MaxPermSize=256M - XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=1M -XX:+UseParNewGC - XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFaction=92 -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=0</li>
</ul>
<h3 id="Concurrent-Mode-Failure"><a href="#Concurrent-Mode-Failure" class="headerlink" title="Concurrent Mode Failure"></a>Concurrent Mode Failure</h3><p>CMS在垃圾回收的时候，尤其是并发清理期间，系统程序是可以并发运行的，假设此时老年代空闲空间仅剩100MB，此时系统程序还在不停的创建对象，万一这个时候系统运行触发了某个条件，比如说有200MB对象要进入老年代，这个时候就会触发“Concurrent Mode Failure”问题，因为此时老年代没有足够内存来放这200MB对象，此时就会导致立马进入Stop the World，然后切换CMS为Serial Old收集器来单线程收集垃圾 </p>
<h3 id="G1-垃圾收集器（针对大内存机器通常建议采用G1垃圾回收器）"><a href="#G1-垃圾收集器（针对大内存机器通常建议采用G1垃圾回收器）" class="headerlink" title="G1 垃圾收集器（针对大内存机器通常建议采用G1垃圾回收器）"></a>G1 垃圾收集器（针对大内存机器通常建议采用G1垃圾回收器）</h3><ul>
<li>G1垃圾回收器把Java堆内存拆分为多个大小相等的Region，G1会有新生代和老年代的概念，但是只是逻辑上的概念</li>
<li>G1垃圾回收器可以设置一个垃圾回收的预期停顿时间</li>
<li>G1通过把内存拆分为大量小Region，以及追踪每个Region中可以回收的对象大小和预估时间，在垃圾回收的时候，尽量把垃圾回收对系统造成的影响控制在指定的时间范围内，同时在有限的时间内尽量回收尽可能多的垃圾对象</li>
<li>使用“-XX:+UseG1GC”来指定使用G1垃圾回收器，会自动用堆大小除以2048得到每个region的大小，可以使用-XX:G1HeapRegionSize指定region的大小<br>G1中新生代（Eden、Survivor）、老年代的逻辑概念，-XX:G1NewSizePercent来设置新生代初始占比的，随着对象的不停创建，属于新生代的Region会不断增加，Eden和Survivor对应的Region也会不断增加。一旦新生代达到了设定的占据堆内存的最大大小60%，会触发新生代的GC，G1就会用复制算法来进行垃圾回收，进入一个“Stop the World”状态，然后把Eden对应的Region中的存活对象放入S1对应的Region中，接着回收掉Eden对应的Region中的垃圾对象   </li>
<li>G1是可以设定目标GC停顿时间的，G1执行GC的时候最多可以让系统停顿多长时间，可以通过“-XX:MaxGCPauseMills”参数来设定，默认值是200ms。</li>
<li>年轻代何时进入老年代？跟之前几乎是一样的<ul>
<li>对象在新生代gc多次仍然存活 -XX:MaxTenuringThreshold</li>
<li>年龄为1岁，2岁，3岁，n岁的对象的大小总和超过了Survivor的50%，n+1岁进入老年代</li>
<li>在G1中，大对象的判定规则：一个大对象超过了一个Region大小的50%，会被放入大对象专门的Region</li>
</ul>
</li>
<li>G1有“-XX:InitiatingHeapOccupancyPercent”，默认值是45%：老年代占据了堆内存的45%的Region的时候，尝试触发一个新生代+老年代一起回收的混合回收阶段。</li>
<li>G1垃圾收集几个阶段（混合回收可以执行多次）<ul>
<li>初始标记 stw 标记一下GC Roots直接能引用的对象 很快</li>
<li>并发标记，允许系统程序的运行，同时进行GC Roots追踪，从GC Roots开始追踪所有的存活，同时记录并发标记系统运行导致哪些对象的改变</li>
<li>最终标记阶段，stw 对并发标记阶段记录的对象进行标记，最终标记一下有哪些存活对象，有哪些是垃圾对象</li>
<li>混合回收，从新生代和老年代里都回收一些Region，先停止工作，执行一次混合回收回收掉一些Region，接着恢复系统运行，然后再次停止系统运行，再执行一次混合回收回收掉一些Region。-XX:G1MixedGCCountTarget  混合回收的过程中，最后一个阶段执行几次混合 回收，默认值是8次</li>
</ul>
</li>
</ul>
<h3 id="G1调优"><a href="#G1调优" class="headerlink" title="G1调优"></a>G1调优</h3><ul>
<li>-Xms4096M -Xmx4096M -Xss1M -XX:PermSize=256M -XX:MaxPermSize=256M -XX:+UseG1GC</li>
<li>-XX:G1NewSizePercent参数是用来设置新生代初始占比的，不用设置，维持默认值为5%即可</li>
<li>-XX:G1MaxNewSizePercent参数是用来设置新生代最大占比的，也不用设置，维持默认值为60%即可</li>
<li>-XX:MaxGCPauseMills 默认值是200毫秒 垃圾回收时最大停顿时间 </li>
<li>G1里是很动态灵活的，根据你设定的gc停顿时间给你的新生代不停分配更多Region，到一定程度，就会触发新生代gc，保证新生代gc的时候导致的系统停顿时间在预设范围内。</li>
<li>新生代的GC优化：合理设置“-XX:MaxGCPauseMills”参数，设置小了，Gc频繁，设置大了，GC停顿时间长</li>
<li>mixed gc优化：默认老年代占据了堆内存的45%的Region的时候，发生Gc,如果-XX:MaxGCPauseMills设置过大，就会导致新生代GC后更多的对象进入老年代，加速mixed gc 发生</li>
</ul>
<h3 id="日处理上亿数据案例"><a href="#日处理上亿数据案例" class="headerlink" title="日处理上亿数据案例"></a>日处理上亿数据案例</h3><ul>
<li>分布式系统，4核心8G，JVM给了4G，新生代和老年代各1.5G（1.2G Eden区Survivor区150M）,每台机器每分钟计算100条数据，每秒取10000条数据，需要10秒计算完成<ul>
<li>预估每条数据20个字段，每个字段4B，大约1条数据100B,10000条数据1M，系统运行产生其他对象*10，10M</li>
<li>每次运行产生10M，一分钟产生1G，大概1分钟就要产生一次年轻代垃圾</li>
<li>每次年轻代垃圾回收，会有大概17～20次还在计算中，这些数据都是存活的对象，占用空间170M～200M </li>
<li>每次年轻代垃圾回收，Survivor区无法放入存活的对象，放老年代，在7～9次年轻代垃圾回收后，老年代就满了，触发Fullgc 耗时</li>
<li>将年轻代分配2G eden1.6G surviro 200m</li>
</ul>
</li>
</ul>
<h3 id="BI系统案例"><a href="#BI系统案例" class="headerlink" title="BI系统案例"></a>BI系统案例</h3><ul>
<li>10台机器来部署BI系统，4核8G的配置，堆内存中的新生代分配的内存都在1.5G左右，Eden区大概也就1G左右的空间，几万商家作为你的系统用户，很可能同一时间打开那个实时报表的商家就有几千个，然后每个商家打开实时报表之后，前端页面都会每隔几秒钟发送请求到后台来加载最新数据BI系统部署的每台机器每秒的请求会达到几百个，假设5000个商家同时在线，每秒刷新一次，每秒5000个请求，每台机器分摊500个请求<ul>
<li>预算每个请求大概需要加载出来10kb的数据进行计算，每秒需要加载出来5MB的数据到内存中进行计算</li>
<li>200s 就会触发年轻代GC，存活的对象估计几十m</li>
<li>估计50次年轻代gc 会发生老年代Gc</li>
</ul>
</li>
<li>每秒十万并发，那么就要部署上百台机器来，扩大机器内存，使用G1收集器，采用10台机器</li>
</ul>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="打印gc日志"><a href="#打印gc日志" class="headerlink" title="打印gc日志"></a>打印gc日志</h3><ul>
<li>-XX:+PrintGCDetils:打印详细的gc日志 </li>
<li>-XX:+PrintGCTimeStamps:这个参数可以打印出来每次GC发生的时间 </li>
<li>-Xloggc:gc.log:这个参数可以设置将gc日志写入一个磁盘文件</li>
</ul>
<h3 id="Jvm-命令"><a href="#Jvm-命令" class="headerlink" title="Jvm 命令"></a>Jvm 命令</h3><ul>
<li>jps 查看jvm进程ID</li>
<li>jstat -gc jvm进程ID 查看jvm进程内存使用情况<ul>
<li>S0C:From Survivor区的大小</li>
<li>S1C:To Survivor区的大小</li>
<li>S0U:From Survivor区当前使用的内存大小 </li>
<li>S1U:To Survivor区当前使用的内存大小 </li>
<li>EC:Eden区的大小</li>
<li>EU:Eden区当前使用的内存大小</li>
<li>OC:老年代的大小</li>
<li>OU:老年代当前使用的内存大小 </li>
<li>MC:方法区(永久代、元数据区)的大小 </li>
<li>MU:方法区(永久代、元数据区)的当前使用的内存大小 </li>
<li>YGC:Young GC次数 </li>
<li>YGCT:Young GC的耗时 </li>
<li>FGC:Full GC次数</li>
<li>FGCT:Full GC的耗时</li>
<li>GCT:所有GC的总耗时</li>
</ul>
</li>
<li>jstat -gc jvm进程ID 1000 10  1秒输出一次 输出10次 用于观察环境上内存变化</li>
<li>jmap -heap jvm进程ID 查看堆内存信息</li>
<li>jmap -histo:live jvm进程ID 查看内存对象信息</li>
<li>jmap -dump:live,file=/filename.hprof jvm进程ID  dump出内存信息</li>
<li>jhat -port 7000 filename.hprof 将dump文件加载出来以网页方式呈现</li>
</ul>
<h2 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h2><h3 id="调优方案"><a href="#调优方案" class="headerlink" title="调优方案"></a>调优方案</h3><p>尽量让每次Young GC后的存活对象小于Survivor区域的50%，都留存在年轻代里。<br>尽量别让对象进入老年代。<br>尽量减少Full GC的频率，避免频繁Full GC对JVM性能的影响。</p>
<h3 id="社交app，QPS-十万"><a href="#社交app，QPS-十万" class="headerlink" title="社交app，QPS 十万"></a>社交app，QPS 十万</h3><ul>
<li>老年代频繁Gc 压缩碎片，避免每次GC间隔越来越短 -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=5<h3 id="垂直电商app-每小时总会有卡顿"><a href="#垂直电商app-每小时总会有卡顿" class="headerlink" title="垂直电商app 每小时总会有卡顿"></a>垂直电商app 每小时总会有卡顿</h3></li>
<li>垂直电商APP的各个系统通过jstat分析JVM GC之后发现，基本上高峰期的时候，Full GC每小时都会发生好几次</li>
<li>通用JVM参数 -Xms4096M -Xmx4096M -Xmn3072M -Xss1M -XX:PermSize=256M -XX:MaxPermSize=256M -XX:+UseParNewGC - XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFaction=92 -XX:+UseCMSCompactAtFullCollection - XX:CMSFullGCsBeforeCompaction=0</li>
<li>优化fullgc的效率<ul>
<li>-XX:+CMSParallelInitialMarkEnabled CMS垃圾回收器的“初始标记”阶段开启多线程并发执行</li>
<li>-XX:+CMSScavengeBeforeRemark 会在CMS的重新标记阶段之前，尽量执行一次Young GC。</li>
</ul>
</li>
</ul>
<h3 id="频繁的fullgc-观察后发现元空间的满了"><a href="#频繁的fullgc-观察后发现元空间的满了" class="headerlink" title="频繁的fullgc 观察后发现元空间的满了"></a>频繁的fullgc 观察后发现元空间的满了</h3><ul>
<li>代码里写了大量反射代码，JVM会动态的去生成一些类放入Metaspace区域里的，JVM自己创建的奇怪的类Class对象是SoftReference</li>
<li>软引用，只有内存不够才会回收，怎么判断要不要回收？clock - timestamp &lt;= freespace * SoftRefLRUPolicyMSPerMB，clock - timestamp代表了一个软引用对象他有多久没被访问过了，freespace代表JVM中的空闲内存空间，SoftRefLRUPolicyMSPerMB代表每一MB空闲内存空间可以允许SoftReference对象存活多久</li>
<li>SoftRefLRUPolicyMSPerMB 设置为0 导致</li>
<li>在有大量反射代码的场景下 -XX:SoftRefLRUPolicyMSPerMB=0 可以设置个1000，2000，3000，或者5000毫秒 默认1000</li>
</ul>
<h3 id="线上fullgc频繁"><a href="#线上fullgc频繁" class="headerlink" title="线上fullgc频繁"></a>线上fullgc频繁</h3><ul>
<li>机器配置:2核4G，JVM堆内存大小:2G，系统运行时间:6天，系统运行6天内发生的Full GC次数和耗时:250次，70多秒，系统运行6天内发生的Young GC次数和耗时:2.6万次，1400秒，每天会发生4000多次Young GC，每分钟会发生3次，每次Young GC在50毫秒左右</li>
<li>未优化前 -Xms1536M -Xmx1536M -Xmn512M -Xss256K -XX:SurvivorRatio=5 -XX:+UseParNewGC -XX:+UseConcMarkSweepGC - XX:CMSInitiatingOccupancyFraction=68 -XX:+CMSParallelRemarkEnabled -XX:+UseCMSInitiatingOccupancyOnly - XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC</li>
<li>通过jstat的观察，每次Young GC过后升入老年代里的对象很少 ， 每次Young GC过后大概就存活几十MB而已，那么Survivor区域因为就70MB，所以经常会触发动态年龄判断规则，导致偶尔一次Young GC过后有几十MB对象进入老年代</li>
<li>大对象 jstat工具观察系统，发现老年代里突然进入了几百MB的大对象,就是特殊场景全表查了数据库，量比较大</li>
<li>优化方案<ul>
<li>去除查大数据量的bug</li>
<li>年轻代变大，避免触发动态年龄判断，部分垃圾对象进入老年代</li>
<li>-Xms1536M -Xmx1536M -Xmn1024M -Xss256K -XX:SurvivorRatio=5 -XX:PermSize=256M -XX:MaxPermSize=256M - XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=92 - XX:+CMSParallelRemarkEnabled -XX:+UseCMSInitiatingOccupancyOnly -XX:+PrintGCDetails -XX:+PrintGCTimeStamps - XX:+PrintHeapAtGC<h3 id="线上fullgc每秒一次"><a href="#线上fullgc每秒一次" class="headerlink" title="线上fullgc每秒一次"></a>线上fullgc每秒一次</h3></li>
</ul>
</li>
<li>排查是不是代码里使用System.gc()会指挥JVM去尝试执行一次Full GC</li>
<li>推荐使用参数禁用-XX:+DisableExplicitGC 不允许通过代码触发GC</li>
</ul>
<h3 id="mat-内存泄漏分析利器"><a href="#mat-内存泄漏分析利器" class="headerlink" title="mat 内存泄漏分析利器"></a>mat 内存泄漏分析利器</h3><ul>
<li>频繁Full GC的原因：<ul>
<li> 内存分配不合理，导致对象频繁进入老年代，进而引发频繁的Full GC; </li>
<li>存在内存泄漏等问题，就是内存里驻留了大量的对象塞满了老年代，导致稍微有一些对象进入老年代就会引发Full GC; </li>
<li>永久代里的类太多，触发了Full GC</li>
</ul>
</li>
<li>大促系统 突然卡顿严重<ul>
<li>线程太多 负载重</li>
<li>JVM fullgc</li>
</ul>
</li>
<li>jstat 分析得出fullgc频繁 jstat -gc pid 1000 1000</li>
<li>jmap -dump:live,file=/data.hprof  pid dump文件导入visualvm可视化图形界面分析</li>
<li>mat工具分析<ul>
<li><a target="_blank" rel="noopener" href="https://www.eclipse.org/mat/downloads.php">https://www.eclipse.org/mat/downloads.php</a></li>
<li>MAT上有一个工具栏，Leak Suspects，内存泄漏的分析</li>
</ul>
</li>
</ul>
<h3 id="处理数据量巨大的系统前端页面卡顿"><a href="#处理数据量巨大的系统前端页面卡顿" class="headerlink" title="处理数据量巨大的系统前端页面卡顿"></a>处理数据量巨大的系统前端页面卡顿</h3><ul>
<li>jstat -gc pid 1000 1000 发现fullgc 耗时10s</li>
<li>堆分配了20G的内存，其中10G给了年轻代，10G给了老年代</li>
<li>Eden区大概1分钟左右就会塞满，young gc 每次都会有几个g进入老年代</li>
<li>系统运行的时候在产生大量的对象，而且处理的极其的慢</li>
</ul>
<h3 id="调优到底该怎么做"><a href="#调优到底该怎么做" class="headerlink" title="调优到底该怎么做"></a>调优到底该怎么做</h3><ul>
<li>原则:尽可能让每次Young GC后存活对象远远小于Survivor区域，避免对象频繁进入老年代触发Full GC。</li>
<li>新上线系统进行压测，模拟生产环境压力，用jstat观察jvm内存变化</li>
<li>频繁gc表现：<ul>
<li>机器cpu负载过高</li>
<li>fullgc报警</li>
<li>无法处理请求或者响应慢</li>
</ul>
</li>
<li>频繁gc的原因<ul>
<li>一次性加载过多数据进入内存，很多大对象，导致大对象进入老年代  打内存快照 mat分析</li>
<li>系统高并发导致频繁young gc，每次young gc 存活的对象太多，内存分配不合理，survivor区太小，导致对象进入老年代，频繁触发fullgc jstat观察，然后调大survivor区，调大年轻代</li>
<li>永久代因为加载类过多触发fullgc  打内存快照 mat分析</li>
<li>调用System.gc()  代码优化</li>
<li>内存泄漏，无法被回收   代码优化</li>
</ul>
</li>
</ul>
<h3 id="应该如何在面试中回答JVM生产优化问题"><a href="#应该如何在面试中回答JVM生产优化问题" class="headerlink" title="应该如何在面试中回答JVM生产优化问题?"></a>应该如何在面试中回答JVM生产优化问题?</h3><ul>
<li><p>归纳总结出来一套通用的方法付论</p>
<ul>
<li><p>堆内存大小设置 </p>
<ul>
<li>-Xms3G -Xmx3G  最大最小堆设置相同，避免内存伸缩时造成gc导致卡顿</li>
<li>-Xmn2G 设置新生代的大小 -XX:SurvivorRatio=8设置eden与survivor区比例</li>
</ul>
</li>
<li><p>元空间</p>
<ul>
<li>-XX:MetaspaceSize=512m</li>
<li>-XX:MaxMetaspaceSize=512m</li>
</ul>
</li>
<li><p>gc日志</p>
<ul>
<li> -XX:+PrintGCDetails -XX:+PrintGCTimeStamps  -Xloggc:/gc.log</li>
</ul>
</li>
<li><p>栈大小</p>
<ul>
<li>-Xss1M</li>
</ul>
</li>
<li><p>垃圾收集器设置</p>
<ul>
<li>-XX:+UseParNewGC</li>
<li>-XX:+UseConcMarkSweepGC</li>
<li>-XX:+UseG1GC</li>
</ul>
</li>
<li><p>垃圾收集器相关参数设置</p>
<ul>
<li>-XX:CMSInitiatingOccupancyFaction=92 cms老年代内存大小发生fullgc,可以设置稍微小，降低发生fullgc的时间</li>
<li>-XX:+UseCMSCompactAtFullCollection - XX:CMSFullGCsBeforeCompaction=0 压缩碎片，每次都压缩吗</li>
<li>-XX:+CMSParallelInitialMarkEnabled CMS垃圾回收器的“初始标记”阶段开启多线程并发执行</li>
<li>-XX:+CMSScavengeBeforeRemark 会在CMS的重新标记阶段之前，尽量执行一次Young GC</li>
<li>-XX:+UseCMSInitiatingOccupancyOnly 只使用指定的值，避免伸缩</li>
</ul>
</li>
<li><p>oom的参数设置</p>
<ul>
<li>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/local/app/oom</li>
</ul>
</li>
<li><p>预防System.gc()</p>
<ul>
<li>-XX:+DisableExplicitGC 不容许代码控制gc</li>
</ul>
</li>
</ul>
</li>
<li><p>负责的系统，假设数据量和访问量暴增10倍，或者100倍，此时会不会出现频繁Full GC的 问题?如果会的话，那么一旦发生了，如何定位、分析和解决?</p>
<ul>
<li>负责的系统主要的业务借款，用户量大概有2000万，日活500万，集中在下午4～6点会进行借款</li>
<li>目前生产机器4核8G配置给jvm4G</li>
<li>借款的接口并发 每秒进入借款页面5000，借款相关接口并发10000 </li>
<li>核心接口 产生新对象平均20 字段数平均20个  4<em>20B</em>20=2k 扩大10倍～20倍 20k</li>
<li>部署8台机器 接口并发1000接口/s 一秒产生20m对象  平均80s就会young gc一次 </li>
</ul>
</li>
<li><p>说自己的系统可能在哪些情况下发生频繁Full GC，在压测的时候就发现了这 些问题，然后你是如何进行JVM性能优化的!</p>
</li>
</ul>
<h3 id="oom"><a href="#oom" class="headerlink" title="oom"></a>oom</h3><ul>
<li>元空间<ul>
<li>-XX:MetaspaceSize=512m -XX:MaxMetaspaceSize=512m</li>
<li>元空间gc的条件：类的类加载器先要被回收，类的所有对象实例都要被回收</li>
<li>在上线系统的时候对Metaspace区域直接用默认的参数,默认的太小</li>
<li>用cglib之类的技术动态生成一些类，一旦代码中没有控制好，导致生成的类过多，导致元空间满，从而引发oom</li>
</ul>
</li>
<li>栈内存<ul>
<li>递归调用</li>
</ul>
</li>
<li>堆内存<ul>
<li>高并发场景，导致ygc后很多请求还没处理完毕，存活对象太多，可能就在Survivor区域放不下了，只能进入到老年代，老年代很快就会放满。又有一批对象生成后younggc后仍有大量存活对象，需要放到老年代，此时老年代满了，就要触发fullgc,fullgc之后仍然放不下对象就会oom</li>
</ul>
</li>
</ul>
<h3 id="大型计算系统oom了"><a href="#大型计算系统oom了" class="headerlink" title="大型计算系统oom了"></a>大型计算系统oom了</h3><ul>
<li>从数据存储系统读出并计算，计算完成推送Kafka</li>
<li>发送Kafka失败就要重试</li>
<li>假设Kafka宕机，系统计算结果越来越多，最终oom</li>
<li>解决方案，当Kafka宕机时，写本地存储</li>
</ul>
<h3 id="oom监控方案"><a href="#oom监控方案" class="headerlink" title="oom监控方案"></a>oom监控方案</h3><ul>
<li>主动监控：监控系统，监控cpu,内存，监控fullgc次数</li>
<li>被动监控：<ul>
<li>系统宕机，通知</li>
<li>每天观察系统日志<h3 id="系统宕机时dump"><a href="#系统宕机时dump" class="headerlink" title="系统宕机时dump"></a>系统宕机时dump</h3></li>
</ul>
</li>
<li>XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/local/app/oom</li>
</ul>
<h3 id="netty-nio-堆外内存溢出"><a href="#netty-nio-堆外内存溢出" class="headerlink" title="netty nio 堆外内存溢出"></a>netty nio 堆外内存溢出</h3><p>当堆外内存都被大量的DirectByteBuffer对象关联使用了，再要使用更多的堆外内存，那么就会报内存溢出了<br>系统承载的是超高并发，复杂压力很高，瞬时大量请求过来，创建了过多的DirectByteBuffer占用了大量的堆外内存，此时再继续想要使用堆外内存，就会内存溢出</p>
<h3 id="rpc-oom"><a href="#rpc-oom" class="headerlink" title="rpc oom"></a>rpc oom</h3><p>rpc传输需要将对象序列化成字节，比如服务A的Request类有15个字段，序列化成字节流给你发送过来了，服务B的Request类只有10个字段，有的字段名字还不一 样，那么反序列化的时候就会失败，代码中写的逻辑是，一旦反序列化失败了，此时就会开辟一个byte[]数组，默认大小是4GB，然后把对方的字节流原封不动的放进 去。<br>垃圾处理逻辑，序列化失败应该返回错误的响应码</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.imder.top/2022/02/28/%E5%AD%A6MQ%E6%89%80%E5%BE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ren zheng xiao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="随记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/28/%E5%AD%A6MQ%E6%89%80%E5%BE%97/" class="post-title-link" itemprop="url">学MQ所得</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 22:22:22" itemprop="dateCreated datePublished" datetime="2022-02-28T22:22:22+00:00">2022-02-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2024-03-28 16:43:20" itemprop="dateModified" datetime="2024-03-28T16:43:20+00:00">2024-03-28</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="梳理出来自己负责的系统的核心业务流程，核心功能模块，跟其他系统是如何交互的，数据是如何存储，当前已经使用了哪些中间件技术。"><a href="#梳理出来自己负责的系统的核心业务流程，核心功能模块，跟其他系统是如何交互的，数据是如何存储，当前已经使用了哪些中间件技术。" class="headerlink" title="梳理出来自己负责的系统的核心业务流程，核心功能模块，跟其他系统是如何交互的，数据是如何存储，当前已经使用了哪些中间件技术。"></a>梳理出来自己负责的系统的核心业务流程，核心功能模块，跟其他系统是如何交互的，数据是如何存储，当前已经使用了哪些中间件技术。</h3><h3 id="系统与系统之间的耦合性体现"><a href="#系统与系统之间的耦合性体现" class="headerlink" title="系统与系统之间的耦合性体现"></a>系统与系统之间的耦合性体现</h3><p>来思考一个问题，假设促销系统现在有一个接口，专门是让你调用了以后派发优惠券的，现在这个接口接收的参数有 5个，你要是调用这个接口，就必须给他传递5个参数过去，这个是没的说的。<br>现在问题来了，负责促销系统的工程师某一天突然有一个新的想法，他希望改一改这个接口，在接口调用的时候需要传递7个参数！<br>一旦他的这个新接口上线了，你还是给他传5个参数，那么他那里就会报错，这个派发优惠券的行为就会失败！<br>那在这样的一个情况下应该怎么办？<br>    很简单，你作为订单系统的负责人，必须要配合促销系统去修改代码，既然他要7个参数，那么你就必须得在代码里调用他的接口的时候传递7个参数。<br>并且你还得配合他的新接口去进行测试以及部署上线，你必须得围绕着他转，配合他。<br>在这种情况下，就说明你的订单系统跟促销系统是强耦合的</p>
<h3 id="订单系统存在的问题"><a href="#订单系统存在的问题" class="headerlink" title="订单系统存在的问题"></a>订单系统存在的问题</h3><p><img src="/2022/02/28/%E5%AD%A6MQ%E6%89%80%E5%BE%97/aimg.png" alt="img.png"></p>
<h3 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h3><p>异步化提升性能，降低系统耦合，流量削峰</p>
<ul>
<li>解耦异步<br>  引入MQ之前,a系统调用b系统<br>  <img src="/2022/02/28/%E5%AD%A6MQ%E6%89%80%E5%BE%97/aimg_2.png" alt="img_2.png"><br>  引入MQ之后<br>  <img src="/2022/02/28/%E5%AD%A6MQ%E6%89%80%E5%BE%97/aimg_3.png" alt="img_3.png"></li>
<li>削峰<br>  MQ这个技术抗高并发的能力远远高于数据库，同样的机器配置下，如果数据库可以抗每秒6000请求，MQ至少可以抗每秒几万请求。<br>  <img src="/2022/02/28/%E5%AD%A6MQ%E6%89%80%E5%BE%97/aimg_1.png" alt="img_1.png"><br>  MQ进行流量削峰的效果，系统A发送过来的每秒1万请求是一个流量洪峰，然后MQ直接给扛下来了，都存储自己本地磁盘，这个过程就是流量削峰的过程，瞬间把一个洪峰给削下来了，让系统B后续慢慢获取消息来处理。</li>
</ul>
<h3 id="kafka-rabbitmq-rocketmq"><a href="#kafka-rabbitmq-rocketmq" class="headerlink" title="kafka rabbitmq rocketmq"></a>kafka rabbitmq rocketmq</h3><ul>
<li><p>kafka优点<br>  Kafka的吞吐量几乎是行业里最优秀的，在常规的机器配置下，一台机器 可以达到每秒十几万的QPS<br>  Kafka性能也很高，发送消息给Kafka都是毫秒级的性能。<br>  可用性也很高，Kafka是可以支持集群部署的，其中部分机器宕机是可以继续运行的。</p>
</li>
<li><p>kafka缺点<br>  丢数据方面的问题，Kafka收到消息之后会写入一个磁盘缓冲区里，并没有直接落地到物理磁盘上去，要是机器本身故障，可能会导致磁盘缓冲区里的数据丢失。<br>  功能非常的单一，主要是支持发送消息给他，然后从里面消费消息</p>
</li>
<li><p>kafka使用场景<br>  Kafka用在用户行为日志的采集和传输上，比如大数据团队要收集APP上用户的一些行为日志，这种日志就是用Kafka来收集和传输的。<br>  因为那种日志适当丢失数据是没有关系的，而且一般量特别大，要求吞吐量要高，一般就是收发消息，不需要太多的高级功能，所以<br>Kafka是非常适合这种场景的。</p>
</li>
<li><p>RabbitMQ优点<br>  保证数据不丢失<br>  保证高可用性，集群部署的时候部分机器宕机可以继续运行<br>  支持部分高级功 能，比如说死信队列，消息重试之类的</p>
</li>
<li><p>RabbitMQ缺点<br>  RabbitMQ的吞吐量是比较低的，一般就是每秒几万的级别<br>  集群扩展的时候（也就是加机器部署），还比较麻烦。<br>  开发语言是erlang，国内很少有精通erlang语言的工程师，没办法去阅读他的源代码</p>
</li>
<li><p>RocketMQ 优点<br>  RocketMQ是阿里开源的消息中间件，几乎同时解决了Kafka和RabbitMQ的缺陷。<br>  RocketMQ的吞吐量很高，单机可以达到10万QPS以上<br>  保证高可用性，性能很高，而且支持通过配置保证数据绝对不丢失，部署大规模的集群<br>  支持各种高级的功能，比如说延迟消息、事务消息、消息回溯、死信队列、消息积压<br>  RocketMQ是基于Java开发的，符合国内大多数公司的技术栈，可以阅读源码或者修改源码。</p>
</li>
<li><p>RocketMQ 缺点<br>  RocketMQ的官方文档相对简单，但是Kafka和RabbitMQ的官方文档就非常的全面和详细，这可能是RocketMQ目前唯一的缺点。</p>
</li>
<li><p>活跃的社区和广泛的运用<br>  基本上Kafka、RabbitMQ和RocketMQ的社区都还算活跃，更新频率都还可以，而且基本运用都非常的广泛。<br>  目前Kafka几乎是国内大数据领域日志采集传输的标准,RabbitMQ在各种中小公司里运用极为广泛,RocketMQ也是开始在一些大公司和其他公司里快速推行中。</p>
</li>
</ul>
<h3 id="RocketMQ-相关问题"><a href="#RocketMQ-相关问题" class="headerlink" title="RocketMQ 相关问题"></a>RocketMQ 相关问题</h3><ul>
<li>RocketMQ是如何集群化部署来承载高并发访问的？<br>  假设RocketMQ部署在一台机器上，即使这台机器配置很高，一般来说一台机器也就是支撑10万+的并发访问。 RocketMQ是可以集群化部署的，可以部署在多台机器上，假设每台机器都能抗10万并发，然后你只要让几十万请求分散到多 台机器上就可以了，让每台机器承受的QPS不超过10万不就行了</li>
<li>如果RocketMQ中要存储海量消息，如何实现分布式存储架构？<br>  MQ会收到大量的消息，这些消息并不是立马就会被所有的消费方获取过去消费的，所以一般MQ都得把消息在自己本地磁盘存储起来，然后等待消费方获取消息去处理。</li>
<li>RocketMQ是如何分布式存储海量消息的呢？<br>  每台机器上部署的RocketMQ进程一般称之为Broker，每个Broker都会收到不同的消息，然后就会把这批消息存储在自己本地的磁盘文件里</li>
<li>高可用保障:万一Broker宕机了怎么办？<br>  Broker主从架构以及多副本策略<br>  <img src="/2022/02/28/%E5%AD%A6MQ%E6%89%80%E5%BE%97/bimg.png" alt="img.png"><br>  Master Broker收到消息后会同步给Slave Broker,这个时候如果任何一个Master Broker出现故障，还有一个Slave Broker上有一份数据副本，可以保证数据不丢失，还能继续对外提供服务，保证了MQ的可靠性和高可用性</li>
<li>数据路由:怎么知道访问哪个Broker？<br>  有一个NameServer的概念，他也是独立部署在几台机器上的，然后所有的Broker都会把自己注册到NameServer上去，NameServer不就知道集群里有哪些Broker了？</li>
</ul>
<h3 id="RocketMQ-NameServer设计原理"><a href="#RocketMQ-NameServer设计原理" class="headerlink" title="RocketMQ NameServer设计原理"></a>RocketMQ NameServer设计原理</h3><ul>
<li>NameServer到底可以部署几台机器？<br>  NameServer支持部署多台机器的,NameServer可以集群化部署的，<br>  那为什么NameServer要集群化部署？ 最主要的一个原因，就是高可用性。<br>  NameServer是集群里非常关键的一个角色，管理Broker信息，别人都要通过他才知道跟哪个Broker通信。<br>  NameServer多机器部署，集群，高可用，保证任何一台机器宕机,其他机器上的NameServer可以继续对外提供服务 </li>
<li>Broker在启动的时候是把自己的信息注册到哪个NameServer上去的？<br>  每个Broker启动都得向所有的NameServer进行注册<br>  比如一共有10台Broker机器，2个NameServer机器，然后其中5台Broker会把自己的信息注册到1个NameServer上去，另外5台Broker会把自己的信息注册到另外1个NameServer上去。这样搞有一个最大的问题，如果1台NameServer上有5个Broker的信息，另外1个NameServer上有另外5个Broker的信息，那么此时 任何一个NameServer宕机了，不就导致5个Broker的信息就没了吗</li>
<li>扮演生产者和消费者的系统们，如何从NameServer那儿获取到集群的Broker信息呢？<br>知道集群里有哪些Broker，根据一定的算法挑选一个Broker去发送消息或者获取消息<br>第一种办法是这样，NameServer那儿会主动发送请求给所有的系统，告诉他们Broker信息。<br>  NameServer无法知道要推送Broker信息给哪些系统<br>第二种办法是这样的，每个系统自己每隔一段时间，定时发送请求到NameServer去拉取最新的集群Broker信息。<br>  RocketMQ中的生产者和消费者就是这样，自己主动去NameServer拉取Broker信息</li>
<li>如果Broker挂了，NameServer是怎么感知到的？<br>  Broker跟NameServer之间的心跳机制，Broker会每隔30s给所有的NameServer发送心跳，告诉每个NameServer自己目前还活着。<br>  NameServer会每隔10s运行一个任务，去检查一下各个Broker的最近一次心跳时间，如果某个Broker超过120s都没发送心跳了，则认为这个Broker挂掉了</li>
<li>Broker挂了，系统是怎么感知到的？<br>  可能某个系统就会发送消息到那个已经挂掉的Broker上去，此时是绝对不可能成功发送消息的<br>  可以考虑不发送消息到那台Broker，改成发到其他Broker上去。<br>  你必须要发送消息给那台Broker，Slave机器是一个备份，可以继续使用，可以考虑Slave进行通信<br>  系统又会重新从NameServer拉取最新的路由信息了，此时就会知道有一个Broker已经宕机了。<br><img src="/2022/02/28/%E5%AD%A6MQ%E6%89%80%E5%BE%97/cimg.png" alt="img.png"></li>
</ul>
<h3 id="RocketMQ-Broker原理分析"><a href="#RocketMQ-Broker原理分析" class="headerlink" title="RocketMQ Broker原理分析"></a>RocketMQ Broker原理分析</h3><ul>
<li><p>Master Broker是如何将消息同步给Slave Broker的？<br>  Master Broker主动推送给Slave Broker？还是Slave Broker发送请求到Master Broker去拉取？<br>  RocketMQ的Master-Slave模式采取的是Slave Broker不停的发送请求到Master Broker去拉取消息<br>  RocketMQ自身的Master-Slave模式采取的是Pull模式拉取消息</p>
</li>
<li><p>RocketMQ 实现读写分离了吗？<br>  Master Broker主要是接收系统的消息写入，然后会同步给Slave Broker<br>  作为消费者的系统在获取消息的时候，是从Master Broker获取的？还是从Slave Broker获取的？<br>  有可能从Master Broker获取消息，也有可能从Slave Broker获取消息<br>  Master Broker在返回消息给消费者系统的时候，会根据当时Master Broker的负载情况和Slave Broker的同步情况，向消费者系 统建议下一次拉取消息的时候是从Master Broker拉取还是从Slave Broker拉取。<br>  举个例子，Master Broker负载很重, 所以此时Master Broker就会建议你从Slave Broker去拉取消息。<br>  举另外一个例子，本身这个时候Master Broker上都已经写入了100万条数据了，结果Slave Broke同步的特别慢， 才同步了96万条数据，落后了整整4万条消息的同步，这个时候你作为消费者系统可能都获取到96万条数据了，那么下次还是只能从Master Broker去拉取消息。 </p>
</li>
<li><p>如果Slave Broke挂掉了有什么影响？<br>  有一点影响，但是影响不太大<br>  消息写入全部是发送到Master Broker的，消息获取也可以走Master Broker，只不过有一些消息获取可能是从Slave Broker 去走的。所以如果Slave Broker挂了，那么此时无论消息写入还是消息拉取，还是可以继续从Master Broke去走，对整体运行不影响。<br>  只不过少了Slave Broker，会导致所有读写压力都集中在Master Broker上。 </p>
</li>
<li><p>如果Master Broker挂掉了该怎么办？<br>  对消息的写入和获取都有一定的影响了。但是其实本质上而言，Slave Broker也是跟Master Broker一样有一份数据在的，<br>  只不过Slave Broker上的数据可能有部分没来得及从Master Broker同步。<br>  此时RocketMQ可以实现直接自动将Slave Broker切换为Master Broker吗？不能<br>  Master-Slave模式不是彻底的高可用模式，他没法实现自动把Slave切换为Master</p>
</li>
<li><p>基于Dledger实现RocketMQ高可用自动切换<br>RocketMQ 4.5之后，RocketMQ支持了一种基于Raft协议实现的一个机制，叫做Dledger,,Dledger融入RocketMQ之后，可以让一个Master Broker对应多个Slave Broker，也就是说一份数据可以有多份副本，比如一个Master Broker对应两个Slave Broker。<br>此时一旦Master Broker宕机了，就可以在多个副本，也就是多个Slave中，通过Dledger技术和Raft协议算法进行leader选举，直接将一个Slave Broker选举为新的Master Broker，然后这个新的Master Broker就可以对外提供服务了。整个过程也许只要10秒或者几十秒的时间就可以完成，这样的话，就可以实现Master Broker挂掉之后，自动从多个Slave Broker中选举出来一个新的Master Broker，继续对外服务，一切都是自动的。<br><img src="/2022/02/28/%E5%AD%A6MQ%E6%89%80%E5%BE%97/dimg.png" alt="img.png"></p>
</li>
</ul>
<h3 id="高可用部署方案"><a href="#高可用部署方案" class="headerlink" title="高可用部署方案"></a>高可用部署方案</h3><ul>
<li>NameServer集群化部署，保证高可用，建议3台机器</li>
<li>基于Dledger的Broker主从架构<ul>
<li>Dledger技术是要求至少得是一个Master带两个Slave，这样有三个Broke组成一个Group，也就是作为一个分组来运行。一旦 Master宕机，他就可以从剩余的两个Slave中选举出来一个新的Master对外提供服务</li>
</ul>
</li>
<li>Broker是如何跟NameServer进行通信的?<ul>
<li>Broker会跟每个NameServer都建立一个TCP长连接，然后定时通过TCP长连接发送心跳请求过去，30s心跳一次，120秒检查一次是否一直没有心跳包</li>
</ul>
</li>
<li>使用MQ的系统都要多机器集群部署<ul>
<li>生产者 消费者</li>
</ul>
</li>
<li>MQ的核心数据模型:Topic到底是什么?<ul>
<li>Topic不能直译，表达的意思就是一个数据集合的意思，不同类型的数据你得放不同的Topic</li>
</ul>
</li>
<li>Topic作为一个数据集合是怎么在Broker集群里存储的?<ul>
<li>分布式存储 多个master</li>
<li>创建Topic的时候指定数据分散存储在多台Broker机器<br><img src="/2022/02/28/%E5%AD%A6MQ%E6%89%80%E5%BE%97/fimg.png" alt="img.png"></li>
</ul>
</li>
<li>生产者系统是如何将消息发送给Broker的?<ul>
<li>在发送消息之前，得先有一个Topic，然后在发送消息的时候你得指定你要发送到哪个Topic里面去。</li>
<li>生产者跟nameserver建立长连接，拉取路由信息找到要投递消息的Topic分布在哪几台Broker上，根据负载均衡算法，从里面选择一台Broke机器出来</li>
<li>选择一台Broker，跟这个Broker建立一个TCP长连接，通过长连接向Broker发送消息</li>
</ul>
</li>
<li>消费者是如何从Broker上拉取消息的?<ul>
<li>消费者跟nameserver建立长连接，拉取路由信息,接着找到自己要获取消息的 Topic在哪几台Broker上，就可以跟Broker建立长连接，从里面拉取消息</li>
</ul>
</li>
</ul>
<h3 id="rocket-mq可视化界面管理工具"><a href="#rocket-mq可视化界面管理工具" class="headerlink" title="rocket mq可视化界面管理工具"></a>rocket mq可视化界面管理工具</h3><ul>
<li>git clone <a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq-externals.git">https://github.com/apache/rocketmq-externals.git</a> </li>
<li>进入rocketmq-console的目录<br>  cd rocketmq-externals/rocketmq-console </li>
<li>执行以下命令对rocketmq-cosole进行打包，把他做成一个jar包:<br>  mvn package -DskipTests</li>
<li>进入target目录下，可以看到一个jar包，接着执行下面的命令启动工作台:<br>  java -jar rocketmq-console-ng-1.0.1.jar –server.port=8080 –rocketmq.config.namesrvAddr=127.0.0.1:9876</li>
</ul>
<h3 id="中间件系统，对os内核参数调整"><a href="#中间件系统，对os内核参数调整" class="headerlink" title="中间件系统，对os内核参数调整"></a>中间件系统，对os内核参数调整</h3><p>vm.overcommit_memory 有三个值可以选择，0、1、2</p>
<ul>
<li>0，在中间件系统申请内存的时候，os内核会检查可用内存是否足够，如果足够的话就分配内存给你，如果感觉剩余内存不是太够了，干脆就拒绝你的申请，导致你申请内存失败，进而导致中间件系统异常出错。</li>
<li>1，把所有可用的物理内存都允许分配给你，只要有内存就给你来用，可以避免申请内存失败的问题。<br>因此一般需要将这个参数的值调整为1<br>比如我们曾经线上环境部署的Redis就因为这个参数是0，导致在save数据快照到磁盘文件的时候，需要申请大内存的时候被拒绝了，进而导致了异常报错。<br>用如下命令修改:echo ‘vm.overcommit_memory=1’ &gt;&gt; /etc/sysctl.conf。</li>
</ul>
<p>vm.max_map_count 默认值是65536</p>
<ul>
<li>会影响中间件系统可以开启的线程的数量</li>
<li>默认值有时候是不够的，比如我们大数据团队的生产环境部署的Kafka集群曾经有一次就报出过这个异常，说无法开启足够多的线程，直接导致Kafka宕机了。<br>建议可以把这个参数调大10倍，比如655360这样的值，保证中间件可以开启足够多的线程。<br>用如下命令修改:echo ‘vm.max_map_count=655360’ &gt;&gt; /etc/sysctl.conf。</li>
</ul>
<p>vm.swappiness<br>用来控制进程的swap行为，os会把一部分磁盘空间作为swap区域，有的进程现在可能不是太活跃，就会被操作系统把进程调整为睡眠状态，把进程中的数据放入磁盘上的swap区域，然后让这个进程把原来占用的内存空间腾出来，交给其他活跃运行的进程来使用。</p>
<ul>
<li>如果这个参数的值设置为0，意思就是尽量别把任何一个进程放到磁盘swap区域去，尽量大家都用物理内存。</li>
<li>如果这个参数的值是100，那么意思就是尽量把一些进程给放到磁盘swap区域去，内存腾出来给活跃的进程使用。 </li>
<li>默认这个参数的值是60，有点偏高了，可能会导致我们的中间件运行不活跃的时候被迫腾出内存空间然后放磁盘swap区域去。</li>
<li>生产环境建议把这个参数调整小一些，比如设置为10，尽量用物理内存，别放磁盘swap区域去。<br>用如下命令修改:echo ‘vm.swappiness=10’ &gt;&gt; /etc/sysctl.conf。</li>
</ul>
<p>ulimit<br>用来控制linux上的最大文件链接数的，默认值可能是1024，一般肯定是不够的，因为你在大量频繁的读写磁盘文件的时候，或者是进行网络通信的时候，都会跟这个参数有关系</p>
<ul>
<li>对于一个中间件系统而言肯定是不能使用默认值的，如果你采用默认值，很可能在线上会出现如下错误:error: too many open files。<br>因此通常建议用如下命令修改这个值:echo ‘ulimit -n 1000000’ &gt;&gt; /etc/profile。</li>
</ul>
<h3 id="中间件系统，对jvm参数调整"><a href="#中间件系统，对jvm参数调整" class="headerlink" title="中间件系统，对jvm参数调整"></a>中间件系统，对jvm参数调整</h3><ul>
<li>-server:服务器模式启动</li>
<li>-Xms8g -Xmx8g -Xmn4g:默认的堆大小是8g内存，新生代是4g内存</li>
<li>-XX:+UseG1GC -XX:G1HeapRegionSize=16m:用了G1垃圾回收器来做分代回收，对新生代和老年代都是用G1来回收，G1的region大小设置为了16m，这个因-为机器内存比较多，所以region大小可以调大一些给到16m，不然用2m的region，会导致致region数量过多的</li>
<li>-XX:G1ReservePercent=25:G1管理的老年代里预留25%的空闲内存，保证新生代对象晋升到老年代的时候有足够空间，避免老年代内存都满了，新生代有对象要进入老年代没有充足内存了，默认值是10%，偏少，调大</li>
<li>-XX:InitiatingHeapOccupancyPercent=30:当堆内存的使用率达到30%之后就会自动启动G1的并发垃圾回收，开始尝试回收一些垃圾对象<br>默认值是45%，调低，提高了GC的频率，避免了垃圾对象过多，一次垃圾回收耗时过长的问题</li>
<li>-XX:SoftRefLRUPolicyMSPerMB=0:建议这个参数不要设置为0，避免频繁回收一些软引用的Class对象，调整为比如1000</li>
<li>-verbose:gc -Xloggc:/dev/shm/mq_gc_%p.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps - XX:+PrintGCApplicationStoppedTime -XX:+PrintAdaptiveSizePolicy -XX:+UseGCLogFileRotation - XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=30m:控制GC日志打印输出的，gc日志文件的地址，打印哪些详细信息，每个gc日志文件的大小是30m，最多保留5个gc日志文件。</li>
<li>-XX:-OmitStackTraceInFastThrow:有时候JVM会抛弃一些异常堆栈信息，这个参数设置之后，禁用这个特性，要把完整的异常堆栈信息打印出来</li>
<li>-XX:+AlwaysPreTouch:刚开始指定JVM用多少内存，不会真正分配给他，会在实际需要使用的时候再分配给他，使用这个参数之后，就是强制让JVM启动的时候直接分配我们指定的内存，不要等到使用内存的时候再分配</li>
<li>-XX:MaxDirectMemorySize=15g:RocketMQ里大量用了NIO中的direct buffer，限定了direct buffer最多申请多少， 如果你机器内存比较大，可以适当调大这个值</li>
<li>-XX:-UseLargePages -XX:-UseBiasedLocking:这两个参数的意思是禁用大内存页和偏向锁<br>RocketMQ默认的JVM参数是采用了G1垃圾回收器，默认堆内存大小是8G 可以根据机器内存来调整，增大一些也是没有问题的，然后就是一些G1的垃圾回收的行为参数做了调整，<h3 id="对RocketMQ核心参数进行调整"><a href="#对RocketMQ核心参数进行调整" class="headerlink" title="对RocketMQ核心参数进行调整"></a>对RocketMQ核心参数进行调整</h3>sendMessageThreadPoolNums=16 RocketMQ内部用来发送消息的线程池的线程数量，默认是16</li>
<li>根据你的机器的CPU核数进行适当增加，比如机器CPU是24核的，可以增加这个线程数量到24或者30</li>
</ul>
<h3 id="压测"><a href="#压测" class="headerlink" title="压测"></a>压测</h3><p>在RocketMQ的TPS和机器的资源使用率和负载之间取得一个平衡。<br>例如：两个Producer不停的往RocketMQ集群发送消息，每个Producer所在机器启动了80个线程，相当于每台机器有80个线程并发的往RocketMQ集群写入消息。RocketMQ集群是1主2从组成的一个dledger模式的高可用集群，只有一个Master Broker会接收消息的写入，有2个Cosumer不停的从RocketMQ集群消费数据。<br>每条数据的大小是500个字节。</p>
<ul>
<li>cpu负载情况 top</li>
<li>内存使用率 free </li>
<li>JVM GC频率 gc日志 </li>
<li>磁盘IO负载 top</li>
<li>网卡流量 服务器使用的是千兆网卡，千兆网卡的理论上限是每秒传输128M数据，但是一般实际最大值是每秒传输100M数据<br>  sar -n DEV 1 2<br>  RocketMQ处理到每秒7万消息的时候，每条消息500字节左右的大小的情况下，每秒网卡传输数据量已经达到100M了，就是已经达到了网卡的一个极限值</li>
</ul>
<h3 id="订单系统改造"><a href="#订单系统改造" class="headerlink" title="订单系统改造"></a>订单系统改造</h3><p><img src="/2022/02/28/%E5%AD%A6MQ%E6%89%80%E5%BE%97/gimg.png" alt="img.png"></p>
<h3 id="发消息的几种方式（生产者）"><a href="#发消息的几种方式（生产者）" class="headerlink" title="发消息的几种方式（生产者）"></a>发消息的几种方式（生产者）</h3><ul>
<li><p>同步发送消息到MQ<br>  通过代码发送消息到MQ去，SendResult sendResult = producer.send(msg)，然后等待mq返回一个结果继续往下执行</p>
</li>
<li><p>异步发送消息到MQ<br>  消息发送出去，不会等待MQ返回结果，当MQ返回结果给你的时候，Producer会回调你的SendCallback里的函数，发送成功回调onSuccess函数，发送失败了回调onExceptino函数。</p>
</li>
<li><p>发送单向消息到RocketMQ<br>  发送一个消息给MQ，不会等待mq返回结果，不会关注MQ有没有返回结果，不管发送的消息是成功还是失败</p>
<h3 id="收消息的几种方式（消费者）"><a href="#收消息的几种方式（消费者）" class="headerlink" title="收消息的几种方式（消费者）"></a>收消息的几种方式（消费者）</h3></li>
<li><p>push模式<br>  Broker会主动把消息发送给消费者，消费者是被动的接收Broker推送给过来的消息，然后进行处理</p>
</li>
<li><p>pull模式<br>  消费者主动发送请求到Broker去拉取消息并处理</p>
</li>
</ul>
<h3 id="对其他团队要获取你们核心数据的问题，应该如何解决"><a href="#对其他团队要获取你们核心数据的问题，应该如何解决" class="headerlink" title="对其他团队要获取你们核心数据的问题，应该如何解决?"></a>对其他团队要获取你们核心数据的问题，应该如何解决?</h3><ul>
<li>定时同步 统计数据按天，周可以定时同步</li>
<li>实时同步<ul>
<li>发mq，其他团队消费，容许延迟</li>
<li>调接口 告知 </li>
</ul>
</li>
<li>其他团队拉数据<ul>
<li>提供接口给他们</li>
</ul>
</li>
</ul>
<h3 id="秒杀场景下？"><a href="#秒杀场景下？" class="headerlink" title="秒杀场景下？"></a>秒杀场景下？</h3><p>高并发读,抢购商品界面 </p>
<ul>
<li>cdn + nginx + redis  提前将商品数据放入redis, 使用nginx + lua 本地缓存和redis缓存加载商品页面<br>高并发写 </li>
<li>独立于订单系统，新建秒杀订单系统，避免秒杀时影响普通订单的下订单</li>
<li>客户端页面需要新增答题功能，防止作弊</li>
<li>nginx + lua 判断库存为0拦截下单接口，避免更多的请求直接打到下单接口</li>
<li>调用下单接口，商品库存存redis,扣减库存</li>
<li>下单接口 采用将数据写入mq，从而避免瞬间高并发数据库，使数据库宕机,订单系统拉取mq数据进行下单</li>
</ul>
<h3 id="Topic、MessageQueue和Broker之间的关系是什么"><a href="#Topic、MessageQueue和Broker之间的关系是什么" class="headerlink" title="Topic、MessageQueue和Broker之间的关系是什么?"></a>Topic、MessageQueue和Broker之间的关系是什么?</h3><ul>
<li>在创建Topic的时候需要指定一个很关键的参数，就是MessageQueue,指定你的这个Topic对应了多少个队列，也就是多少个MessageQueue</li>
<li>每个MessageQueue中会平均分配Topic的数据,每个Broker机器上都存储一些MessageQueue，MessageQueue是RocketMQ中非常关键的一个数据分片机制，通过这个方法，就可以实现Topic数据的分布式存储!</li>
<li>生产者会跟NameServer进行通信获取Topic的路由数据，生产者从NameServer中就知道一个Topic有几个MessageQueue，哪些MessageQueue在哪台Broker机器上，基于写入MessageQueue的策略，从而使消息分散在多个broker上</li>
<li>Master Broker挂了，此时正在等待的其他Slave Broker自动热切换为Master Broker，那么这个时候对这一组Broker就没有Master Broker可以写入了<br>按照之前的策略来均匀把数据写入各个Broker上的MessageQueue，那么会导致你在一段时间内，每次访问到这个挂掉的 Master Broker都会访问失败，在Producer中开启一个开关，sendLatencyFaultEnable 一个自动容错机制，某次访问一个Broker发现网络延迟有500ms，无法访问，自动回避访问这个Broker一段时间</li>
</ul>
<h3 id="broker如何存数据？"><a href="#broker如何存数据？" class="headerlink" title="broker如何存数据？"></a>broker如何存数据？</h3><ul>
<li>commitlog 顺序写文件<br>  当生产者的消息发送到一个Broker上的时候，broker接收到了一条消息，将这个消息直接写入磁盘上的一个日志文件，叫做CommitLog，直接顺序写入这个文件，CommitLog是很多磁盘文件，每个文件限定最多1GB，Broker收到消息之后就直接追加写入这个文件的末尾，如果一个CommitLog写满了1GB，就会创建一个新的CommitLog文件。</li>
<li>MessageQueue在数据存储中是体现在哪里呢?<ul>
<li>在Broker中，对Topic下的每个MessageQueue都会有一系列的ConsumeQueue文件。</li>
<li>在Broker的磁盘上，这种格式的一系列文件: $HOME/store/consumequeue/{topic}/{queueId}/{fileName}<br>  {topic}指代的就是某个Topic，{queueId}指代的就是某个MessageQueue，有很多的ConsumeQueue文件，ConsumeQueue文件里存储的是一条消息对应在CommitLog文件中的offset偏移量，还包含了消息的长度，以及tag hashcode，一条数据是20个字节<br><img src="/2022/02/28/%E5%AD%A6MQ%E6%89%80%E5%BE%97/abc.png" alt="img.png"></li>
</ul>
</li>
<li>如何让消息写入CommitLog文件近乎内存写性能的?<ul>
<li>Broker是基于OS操作系统的PageCache和顺序写两个机制</li>
<li>数据写入CommitLog文件的时候，不是直接写入底层的物理磁盘文件，先写入OS的PageCache内存缓存中，然后由OS的后台线程选一个时间，异步化的将OS PageCache内存缓冲中的数据刷入底层的磁盘文件。</li>
<li>磁盘文件顺序写+OS PageCache写入+OS异步刷盘的策略，基本上可以让消息写入CommitLog的性能 跟你直接写入内存里是差不多的</li>
<li>异步刷盘模式，消息写入吞吐量非常高，可能会有数据丢失的风险 （Broker将消息写入OS PageCache中，就直接返回ACK，尚未刷入磁盘，宕机丢数据）</li>
<li>同步刷盘模式 必须强制把消息刷入底层的物理磁盘文件中，然后才会返回ack给producer</li>
</ul>
</li>
</ul>
<h3 id="基于Dledger的高可用broker如何运行？"><a href="#基于Dledger的高可用broker如何运行？" class="headerlink" title="基于Dledger的高可用broker如何运行？"></a>基于Dledger的高可用broker如何运行？</h3><ul>
<li><p>基于DLedger技术管理CommitLog </p>
<ul>
<li>用DLedger先替换掉原来Broker 自己管理的CommitLog，由DLedger来管理CommitLog</li>
<li>Broker基于DLedger管理的CommitLog 去构建出来机器上的各个ConsumeQueue磁盘文件</li>
</ul>
</li>
<li><p>Broker集群启动时，基于DLedger技术和Raft协议完成Leader选举</p>
<ul>
<li>每个节点都投票给自己</li>
<li>选举失败后，每个节点随机休眠，先醒的机器投票给自己并发送投票信息给其他节点，其他节点醒了收到先醒机器的投票，会投票给先醒的节点</li>
<li>选票 大于等于（机器数/2+1）,选为master节点</li>
</ul>
</li>
<li><p>Leader Broker写入之后，基于DLedger技术和Raft协议同步给Follower Broker </p>
<ul>
<li>数据同步会分为两个阶段，一个是uncommitted阶段，一个是commited阶段</li>
<li>首先Leader Broker上的DLedger收到一条数据之后，会标记为uncommitted状态，通过自己的DLedgerServer组件把这个uncommitted数据发送给Follower Broker的DLedgerServer。Follower Broker的DLedgerServer收到uncommitted消息之后，必须返回一个ack给Leader Broker的DLedgerServer，然后如果Leader Broker收到超过半数的Follower Broker返回ack之后，就会将消息标记为committed状态。Leader Broker上的DLedgerServer就会发送commited消息给Follower Broker机器的DLedgerServer，让他们也把消息标记为 comitted状态。</li>
</ul>
</li>
<li><p>如果Leader Broker崩溃，则基于DLedger和Raft协议重新选举Leader<br>  基于DLedger还是采用Raft协议的算法，去选举出来一个新的Leader Broker继续对外提供服务，而且会对没有完成的数据同步进行一些恢复性的操作，保证数据不会丢失。</p>
</li>
</ul>
<h3 id="消费者是如何获取消息并处理？"><a href="#消费者是如何获取消息并处理？" class="headerlink" title="消费者是如何获取消息并处理？"></a>消费者是如何获取消息并处理？</h3><ul>
<li><p>消费者组概念<br>  一组消费者的简称，集群模式下，一个消费组获取到一条消息，只会交给组内的一台机器去处理，广播模式下，消费组获取到的一条消息，组内每台机器都可以获取到这条消息</p>
</li>
<li><p>重温MessageQueue、CommitLog、ConsumeQueue之间的关系<br>  MessageQueue会分散在多个Broker上，在每个Broker机器上，一 个MessageQueue就对应了一个ConsumeQueue，在物理磁盘上其实是对应了多个ConsumeQueue文件的，</p>
</li>
<li><p>MessageQueue与消费者的关系<br>  均匀的将MessageQueue分配给消费组的多台机器来消费</p>
</li>
<li><p>Push模式 vs Pull模式</p>
<ul>
<li>两个消费模式本质都是消费者机器主动发送请求到Broker机器去拉取一批消息下来。</li>
<li>Push是Broker会尽可能实时的把新消息交给消费者机器来进行处理，消息时效性会更好。<br>  一般我们使用RocketMQ的时候，消费模式通常都是基于他的Push模式来做的，因为Pull模式的代码写起来更加的复杂和繁琐</li>
<li>Push当消费者发送请求到Broker去拉取消息，有新的消息可以消费那么就会立马返回一批消息到消费机器去处理，处理完之后会接着立刻发送请求到Broker机器去拉取下一批消息。</li>
<li>Push模式下有一个请求挂起和长轮询的机制<br>  当消费者的请求发送到Broker，没有新的消息给你处理的时候，就会让请求线程挂起，默认是挂起15秒，后台线程每隔一会儿检查一下是否有的新的消息，在这个挂起过程中，有新的消息到达了会主动唤醒挂起的线程，然后把消息返回给消费者。</li>
</ul>
</li>
<li><p>Broker是如何将消息读取出来返回给消费机器的?<br>  要消费的MessageQueue以及开始消费的位置，去找到对应的ConsumeQueue读取里面对应位置的消息在CommitLog中的物理offset偏移量，然后到CommitLog中根</p>
</li>
<li><p>消费者机器如何处理消息、进行ACK以及提交消费进度?<br>  处理完这批消息之后，消费者机器就会提交我们目前的一个消费进度到Broker上去，然后Broker就会存储我们的消费进度</p>
</li>
<li><p>如果消费组中出现机器宕机或者扩容加机器，会怎么处理?<br>  如果消费组中出现机器宕机或者扩容加机器的情况，他会怎么处理?这个时候其实会进入一个rabalance的环节，也就是说重新给各个消费机器分配他们要处理的MessageQueue。</p>
</li>
</ul>
<h3 id="消费者根据什么策略从master还是slave拉取消息？"><a href="#消费者根据什么策略从master还是slave拉取消息？" class="headerlink" title="消费者根据什么策略从master还是slave拉取消息？"></a>消费者根据什么策略从master还是slave拉取消息？</h3><ul>
<li><p>ConsumeQueue文件也是基于os cache的</p>
<ul>
<li>os读取一个磁盘文件时，自动把磁盘文件里的数据缓存到os cache中</li>
<li>ConsumeQueue文件主要是存放消息的offset，文件小，30万条消息的offset就只有5.72MB。实际上ConsumeQueue文件是不占用多少磁盘空间的，整体数据量很小，几乎可以完全被os缓存在内存cache里。</li>
</ul>
</li>
<li><p>根据你读取到的offset去CommitLog里读取消息的完整数据<br>  os cache对于CommitLog而言，主要是提升文件写入性能，当你不停的写入的时候，很多最新写入的数据都会先停留在os cache里，比如这可能有10GB~20GB的数据。os会自动把cache里的比较旧的一些数据刷入磁盘里，腾出来空间给更新写入的数据放在os cache里</p>
<ul>
<li>如果你读取的是那种刚刚写入CommitLog的数据，大概率停留在os cache中，可以直接从os cache里读取CommitLog中的数据，这个就是内存读取，性能是很高的。</li>
<li>读取的是比较早之前写入CommitLog的数据，数据被刷入磁盘，不存在os cache里了，只能从磁盘上的文件里读取，性能是比较差</li>
</ul>
</li>
<li><p>Master Broker什么时候会让你从Slave Broker拉取数据?<br>  对比你当前没有拉取消息的数量和大小，以及最多可以存放在os cache内存里的消息的大小，如果没拉取的消息超过了最大能使用的内存的量，那么说明你后续会频繁从磁盘加载数据，此时就让你从slave broker去加载数据了</p>
</li>
</ul>
<h3 id="基于mmap技术实现磁盘高性能读写"><a href="#基于mmap技术实现磁盘高性能读写" class="headerlink" title="基于mmap技术实现磁盘高性能读写"></a>基于mmap技术实现磁盘高性能读写</h3><ul>
<li>传统文件读写：<br>  普通的IO操作的一个弊端，必然涉及到两次数据拷贝操作，对磁盘读写性能是有影响的。 <pre><code>  - 从磁盘上把数据读取到内核IO缓冲区里，再从内核IO缓存区里读取到用户进程私有空间，才能拿到这个文件里的数据
  - 必须先把数据写入到用户进程私有空间里去，再进入内核IO缓冲区，最后进入磁盘文件里去。
</code></pre>
</li>
<li>mmap技术<br>  建立用户进程私有空间的虚拟内存和文件物理磁盘地址映射，此时并没有任何的数据拷贝操作，JDK NIO包下的MappedByteBuffer的map()函数 将文件映射到内存。mmap技术在进行文件映射的时候，一般有大小限制，在1.5GB~2GB之间</li>
<li>mmap + page cache<br>  接下来MappedByteBuffer执行写入操作，写入的时候直接进入PageCache中，过一段时间之后，由os的线程异步刷入磁盘中<br>  判断要读取的数据是否在PageCache里?如果在的话，直接从PageCache里读取。如果不在PageCache，会从磁盘文件里加载数据到PageCache中，PageCache技术在加载数据的时候，会将你加载的数据块的临近的其他数据块一起加载到PageCache中。</li>
</ul>
<h3 id="丢数据场景"><a href="#丢数据场景" class="headerlink" title="丢数据场景"></a>丢数据场景</h3><ul>
<li>生产者往broker发送数据，网络异常没有发送成功</li>
<li>broker正常接受到数据，写入page cache ，异步刷盘策略，未刷盘机器宕机</li>
<li>leader故障，slave切换leader过程中，这个过程出现异常</li>
<li>磁盘坏了</li>
<li>消费者读取消息策略自动提交offset，数据未处理完宕机</li>
</ul>
<h3 id="解决丢数据"><a href="#解决丢数据" class="headerlink" title="解决丢数据"></a>解决丢数据</h3><ul>
<li>RocketMQ的事务消息机制确定生产者发送的消息到达broker<ul>
<li>首先要让生产者去发送一条half消息到MQ去，这个half消息本质就是一个业务执行成功的消息，可以理解这个消息的状态是half状态，这时消费者系统是看不见这个half消息的，生产者等待接收half消息写入成功的响应通知</li>
<li>half消息给MQ失败了，报错了，可能mq挂了，可能网络故障了，这时执行回滚操作</li>
<li>half消息成功，生产者系统完成自己的任务</li>
<li>生产者系统做自己的任务时发生异常，需要发rollback给mq,让mq删除half消息</li>
<li>生产者系统完成自己的任务，需要commit half消息，发一个commit请求给mq</li>
<li>rocketmq 有一个补偿，扫描自己的half消息，如果一直没有commit或rollback 会回调生产者系统的接口，询问这个消息是commit还是rollback<br><img src="/2022/02/28/%E5%AD%A6MQ%E6%89%80%E5%BE%97/d.png" alt="img.png"></li>
</ul>
</li>
<li>异步刷盘改为同步刷盘<br>  调整broker的配置文件，将其中的flushDiskType配置设置为:SYNC_FLUSH，默认他的值是ASYNC_FLUSH，即默认是异步刷盘的。</li>
<li>消费端 改为不自动提交offset<br>  RocketMQ的消费者中会注册一个监听器，MessageListenerConcurrently，当你的消费者获取到一批消息之后，回调你的这个监听器函数，让消费者系统处理这一批消息。<br>  默认的Consumer的消费模式，处理完一批消息了，才会返回 ConsumeConcurrentlyStatus.CONSUME_SUCCESS状态标识消息都处理结束，去提交offset到broker去<br>  <img src="/2022/02/28/%E5%AD%A6MQ%E6%89%80%E5%BE%97/f.png" alt="img.png"></li>
</ul>
<h3 id="事务机制底层实现原理"><a href="#事务机制底层实现原理" class="headerlink" title="事务机制底层实现原理"></a>事务机制底层实现原理</h3><ul>
<li>half消息写入到rocketmq内部的“RMQ_SYS_TRANS_HALF_TOPIC”这个Topic对应的一个ConsumeQueue里，此时就会认为half消息写入成功，响应给生产者系统</li>
<li>定时任务会去扫描RMQ_SYS_TRANS_HALF_TOPIC中的half消息，超过一定时间还是half消息，回调生产者的接口，让系统判断这个half消息是要rollback还是commit</li>
<li>执行rollback操作，RocketMQ就会在OP_TOPIC里写入一条记录，标记half消息已经是rollback状态</li>
<li>执行commit操作之后，RocketMQ就会在OP_TOPIC里写入一条记录，标记half消息已经是commit状态，接着需要把放在RMQ_SYS_TRANS_HALF_TOPIC中的half消息给写入到业务topic的ConsumeQueue里去，然后消费者系统可以看见</li>
<li>一直没有执行commit/rollback，RocketMQ会回调订单系统的接口去判断half消息的状态，最多就是回调15次，如果15次之后没法告知他half消息的状态，自动把消息标记为rollback。</li>
</ul>
<h3 id="同步发送-反复重试发送的缺陷"><a href="#同步发送-反复重试发送的缺陷" class="headerlink" title="同步发送+反复重试发送的缺陷"></a>同步发送+反复重试发送的缺陷</h3><ul>
<li>反复重试耗时，影响接口返回</li>
<li>反复重试失败，回滚业务代码不方便，本地事务容易会滚，但是操作中间件的不容易会滚</li>
<li>反复重试失败，未会滚业务代码，导致系统之间数据不一致，未收到消息的系统与发送消息的系统数据不一致</li>
</ul>
<h3 id="消息重复消费原因？"><a href="#消息重复消费原因？" class="headerlink" title="消息重复消费原因？"></a>消息重复消费原因？</h3><ul>
<li>生产者接口由于意外原因被调用多次</li>
<li>反复重试代码有概率重复发送</li>
<li>消费者消费未提交offset之前系统重启</li>
</ul>
<h3 id="幂等性，保证数据不会重复消费"><a href="#幂等性，保证数据不会重复消费" class="headerlink" title="幂等性，保证数据不会重复消费"></a>幂等性，保证数据不会重复消费</h3><ul>
<li>生产者保证幂等性<ul>
<li>利用rocket mq 可查询已发送消息判断</li>
<li>利用redis 存储已发过的消息，存在缺陷，消息已推送mq，未写入redis，系统重启</li>
<li>RocketMQ支持你查询某个消息是否存在的，性能也不是太好，会影响接口的性能。基于Redis的消息发送状态的方案，在极端情况下还是没法100%保证幂等性</li>
</ul>
</li>
<li>消费者保证幂等性<ul>
<li>推荐业务判断法，直接根据你的数据存储中的记录来判断这个消息是否处理过， 如果处理过，那就别再次处理</li>
</ul>
</li>
</ul>
<h3 id="消息消费过程异常怎么办？"><a href="#消息消费过程异常怎么办？" class="headerlink" title="消息消费过程异常怎么办？"></a>消息消费过程异常怎么办？</h3><ul>
<li>重试流程？<ul>
<li>RocketMQ会有一个针对你这个ConsumerGroup的重试队列，如果消费消息返回RECONSUME_LATER状态，就会把这个消息放到这个消费者组的重试队列中，消费组的名称是“VoucherConsumerGroup”，一个消费者组，那么会有一个 “%RETRY%VoucherConsumerGroup”的重试队列</li>
<li>过一段时间，重试队列中的消息会再次给消费者处理，如果再次失败，又返回了RECONSUME_LATER，那么会再过一段时间让我们来进行处理，默认最多是重试16次!</li>
<li>重试时间间隔 messageDelayLevel=1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</li>
</ul>
</li>
<li>重试失败了怎么办？<ul>
<li>重试了16次还一直没处理成功，就不要继续重试这批消息，同时消息会自动进入死信队列。</li>
<li>死信队列的名字是“%DLQ%VoucherConsumerGroup”</li>
<li>可以开一个后台线程，订阅“%DLQ%VoucherConsumerGroup”死信队列， 对死信队列中的消息，一直不停的处理</li>
</ul>
</li>
</ul>
<h3 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h3><p>发送消息时，给消息设置tag或者属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Message msg = new Message(&quot;topic&quot;,&quot;tag&quot;,data.getBytes()); 指定tag</span><br><span class="line">msg.putUserProperty(&quot;props&quot;,10);添加属性</span><br></pre></td></tr></table></figure>

<p>消费数据的时候根据tag和属性进行过滤</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">consumer.subscribe(&quot;topic&quot;,&quot;tag1||tag2&quot;);</span><br><span class="line">或</span><br><span class="line">consumer.subscribe(&quot;topic&quot;,MessageSelector.bySql(&quot;props &gt; 10s&quot;))</span><br></pre></td></tr></table></figure>
<p> RocketMQ还是支持比较丰富的数据过滤语法的，如下所示:<br>(1)数值比较，比如: &gt;，&gt;=，&lt;，&lt;=，BETWEEN，=;<br>(2)字符比较，比如: =，&lt;&gt;，IN;<br>(3)IS NULL 或者 IS NOT NULL;<br>(4)逻辑符号 AND，OR，NOT;<br>(5)数值，比如:123，3.1415;<br>(6)字符，比如:’abc’，必须用单引号包裹起来;<br>(7)NULL，特殊的常量<br>(8)布尔值，TRUE 或 FALSE</p>
<h3 id="延迟消息"><a href="#延迟消息" class="headerlink" title="延迟消息"></a>延迟消息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Message msg = new Message(&quot;topic&quot;,&quot;tag&quot;,data.getBytes()); 指定tag</span><br><span class="line">msg.setDelayTimeLevel(3);添加延迟级别</span><br></pre></td></tr></table></figure>
<p>发送延迟消息的核心，就是设置消息的delayTimeLevel延迟级别<br>RocketMQ默认支持延迟级别:1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h<br>代码中设置延迟级别为3，意思就是延迟10s，发送出去的消息，会过10s被消费者获取到。</p>
<h3 id="基于消息key来定位消息是否丢失"><a href="#基于消息key来定位消息是否丢失" class="headerlink" title="基于消息key来定位消息是否丢失"></a>基于消息key来定位消息是否丢失</h3><p>可以基于消息key来实现，通过如下方式设置一个消息的key为订单id:message.setKeys(orderId)<br>接着这个消息到broker上，会基于key构建hash索引，这个hash索引就存放在IndexFile索引文件里。<br>通过MQ提供的命令去根据key查询这个消息:mqadmin queryMsgByKey -n 127.0.0.1:9876 - t SCANRECORD -k orderId</p>
<h3 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h3><p>Broker的配置文件里需要设置aclEnable=true这个配置，开启权限控制<br>Broker部署机器的${ROCKETMQ_HOME}/store/config目录下，可以放一个plain_acl.yml的配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 这个参数就是全局性的白名单</span><br><span class="line"># 这里定义的ip地址，都是可以访问Topic的</span><br><span class="line">globalWhiteRemoteAddresses:</span><br><span class="line">- 13.21.33.*</span><br><span class="line">- 192.168.0.*</span><br><span class="line"># 这个accounts就是说，你在这里可以定义很多账号</span><br><span class="line"># 每个账号都可以在这里配置对哪些Topic具有一些操作权限</span><br><span class="line">accounts:</span><br><span class="line"># 这个accessKey其实就是用户名的意思，比如我们这里叫做“订单技术团队” - accessKey: OrderTeam</span><br><span class="line"># 这个secretKey其实就是这个用户名的密码</span><br><span class="line">secretKey: 123456</span><br><span class="line"># 下面这个是当前这个用户名下哪些机器要加入白名单的</span><br><span class="line">whiteRemoteAddress:</span><br><span class="line"># admin指的是这个账号是不是管理员账号</span><br><span class="line">admin: false</span><br><span class="line"># 这个指的是默认情况下这个账号的Topic权限和ConsumerGroup权限</span><br><span class="line">defaultGroupPerm: SUB</span><br><span class="line"># 这个就是这个账号具体的堆一些账号的权限</span><br><span class="line"># 下面就是说当前这个账号对两个Topic，都具备PUB|SUB权限，就是发布和订阅的权限 # PUB就是发布消息的权限，SUB就是订阅消息的权限</span><br><span class="line"># DENY就是拒绝你这个账号访问这个Topic</span><br><span class="line">topicPerms:</span><br><span class="line">- CreateOrderInformTopic=PUB|SUB - PaySuccessInformTopic=PUB|SUB</span><br><span class="line"># 下面就是对ConsumerGroup的权限，也是同理的 groupPerms:</span><br><span class="line">- groupA=DENY</span><br><span class="line">- groupB=PUB|SUB</span><br><span class="line">- groupC=SUB</span><br><span class="line"># 下面就是另外一个账号了，比如是商品技术团队的账号 - accessKey: ProductTeam</span><br><span class="line">secretKey: 12345678 whiteRemoteAddress: 192.168.1.*</span><br><span class="line"># 如果admin设置为true，就是具备一切权限 admin: true</span><br></pre></td></tr></table></figure>

<h3 id="消息消费链路"><a href="#消息消费链路" class="headerlink" title="消息消费链路"></a>消息消费链路</h3><ul>
<li>broker的配置文件里开启traceTopicEnable=true开启消息轨迹追踪。</li>
<li>当启动这个Broker的时候会自动创建出来一个内部的Topic，RMQ_SYS_TRACE_TOPIC，用来存储所有的消息轨迹追踪的数据的。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQProducer producer = new DefaultMQProducer(&quot;topic&quot;,true); //第二个参数enableMsgTrace= true表示对消息开启轨迹追踪</span><br></pre></td></tr></table></figure>
<ul>
<li><p>RocketMQ控制台里，在导航栏里就有一个消息轨迹，在里面可以创建查询任务， 根据messageId、message key或者Topic来查询，Producer、Broker、Consumer上报的一些轨迹数据</p>
</li>
<li><p>Broker记录消息的轨迹数据，包括如下:消息存储的Topic、消息存储的位置、消息的key、消息的 tags。</p>
</li>
<li><p>Consumer端上报信息， 包括：Consumer的信息、投递消息的时间、这是第几轮投递消息、消息消费是否成功、消费这条消息的耗时</p>
<h3 id="消息积压了怎么办？"><a href="#消息积压了怎么办？" class="headerlink" title="消息积压了怎么办？"></a>消息积压了怎么办？</h3><p>4台机器20个message queue 消息积压了</p>
</li>
<li><p>临时申请16台机器多部署16个消费者系统的实例，然后20个消费者系统同时消费，每个人消费一个MessageQueue的 消息</p>
</li>
<li><p>消费者系统底层依赖的数据库必须要能抗住临时增加了5倍的读写压力</p>
</li>
</ul>
<h3 id="mq故障了怎么办？-异常重试、失败存储、恢复发送"><a href="#mq故障了怎么办？-异常重试、失败存储、恢复发送" class="headerlink" title="mq故障了怎么办？ 异常重试、失败存储、恢复发送"></a>mq故障了怎么办？ 异常重试、失败存储、恢复发送</h3><ul>
<li>针对这种场景，生产者系统中设计高可用的降级方案，发送消息到MQ代码里去try catch捕获异常，有异常进行重试。</li>
<li>连续重试了超过n次还是失败，说明MQ集群可能彻底崩溃，这时消息写入到本地存储（数据库、本地磁盘文件、NoSQL存储）</li>
<li>不停的尝试发送消息到MQ去，一旦发现MQ集群恢复，有一个后台线程可以把之前持久化存储的消息都查询出来，依次按照顺序发送到MQ集群里</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.imder.top/2022/02/22/%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB%E5%88%92%E5%88%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ren zheng xiao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="随记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/22/%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB%E5%88%92%E5%88%86/" class="post-title-link" itemprop="url">逻辑关系划分</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-22 22:22:22" itemprop="dateCreated datePublished" datetime="2022-02-22T22:22:22+00:00">2022-02-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2024-03-28 16:43:20" itemprop="dateModified" datetime="2024-03-28T16:43:20+00:00">2024-03-28</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">逻辑</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="逻辑关系划分"><a href="#逻辑关系划分" class="headerlink" title="逻辑关系划分"></a>逻辑关系划分</h1><h2 id="带”除非”的句子一共有3种情况"><a href="#带”除非”的句子一共有3种情况" class="headerlink" title="带”除非”的句子一共有3种情况"></a>带”除非”的句子一共有3种情况</h2><ul>
<li><p>除非和否则一起使用， 除非A，否则B，等同于 非A-&gt;B<br>【范例】除非你去，否则我不去。用逻辑表述为：  你不去-&gt;我不去</p>
</li>
<li><p>“除非”单独出现，没有其他逻辑连词，默认省略了“否则”。<br>比如说：（否则）B，除非A，等同于，除非A，否则B<br>【范例】他这次死定了，除非出现奇迹。等于除非出现奇迹，否则他死定了逻辑表述：非死定-&gt;出现奇迹，不出现奇迹-&gt;死定了</p>
</li>
<li><p>带有逻辑连词”除非”的句子，还有其他的逻辑连词“若”“如果”“才”<br>类似于“除非。。。才”，“如果…，除非…”，在带有其他逻辑连词的句子里，在这些句子里”除非”就是“必须的意思”除非A，才B，等同于必须A，才B，逻辑表述为 A&lt;-B 如果（若）A，除非B，等同于如果A，必须B，逻辑表述为  A-&gt;B</p>
</li>
</ul>
<p>【第一家】把若A，除非B，理解为除非A,否则不B，就等同于非A-&gt;非B，逆否后还是B-&gt;A。<br>除非天上掉馅饼，否则不嫁给你，非天上掉馅饼==》不嫁给你 【第二家】若A，除非B，理解为如果A，那么B，逻辑表示还是A==》B，所以这三种理解从逻辑的本质来说，最终是相同的。<br>【范例】如果我嫁给你了，除非天上掉馅饼<br>（1）除非替换为必须我嫁给你，必须天上掉馅饼，等同于，天上不掉馅饼==》不嫁给你<br>（2）“如果”，理解为“否则不”除非天上掉馅饼，否则不嫁给你，等同于，非天上掉馅饼=》不嫁给你<br>（3）理解为，如果，那么,如果嫁给你，那么天上掉馅饼，等同于，嫁给你==》掉馅饼，逆否后：不掉馅饼==》不嫁给你这三种理解，最中得出的逻辑本质是完全相同的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.imder.top/2022/02/22/springcloudconfig/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ren zheng xiao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="随记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/22/springcloudconfig/" class="post-title-link" itemprop="url">Springcloud-config</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-22 11:59:29" itemprop="dateCreated datePublished" datetime="2022-02-22T11:59:29+00:00">2022-02-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2024-03-28 16:43:20" itemprop="dateModified" datetime="2024-03-28T16:43:20+00:00">2024-03-28</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Springcloud/" itemprop="url" rel="index"><span itemprop="name">Springcloud</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="config"><a href="#config" class="headerlink" title="config"></a>config</h1><h2 id="Config-server"><a href="#Config-server" class="headerlink" title="Config server"></a>Config server</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Application-properties配置"><a href="#Application-properties配置" class="headerlink" title="Application.properties配置"></a>Application.properties配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring.cloud.config.server.git.uri=https://gitee.com/rzxbest/springcloud-config.git</span><br><span class="line">spring.cloud.config.server.git.username=********</span><br><span class="line">spring.cloud.config.server.git.password=********</span><br><span class="line">spring.cloud.config.server.git.search-paths=config</span><br><span class="line">spring.cloud.config.server.default-label=master</span><br><span class="line"></span><br><span class="line">eureka.instance.hostname=localhost</span><br><span class="line">eureka.client.registerWithEureka=true</span><br><span class="line">eureka.client.fetchRegistry=true</span><br><span class="line">eureka.client.serviceUrl.defaultZone:http://$&#123;eureka.instance.hostname&#125;:8761/eureka/</span><br></pre></td></tr></table></figure>

<h2 id="访问配置文件"><a href="#访问配置文件" class="headerlink" title="访问配置文件"></a>访问配置文件</h2><h3 id="访问配置信息的URL与配置文件的映射关系如下所示："><a href="#访问配置信息的URL与配置文件的映射关系如下所示：" class="headerlink" title="访问配置信息的URL与配置文件的映射关系如下所示："></a>访问配置信息的URL与配置文件的映射关系如下所示：</h3><ul>
<li>/{ application } / {profile} [/{label}]</li>
<li>/{ application }-{profile}. yml</li>
<li>/{ label }/{ application }-{profile}.yml</li>
<li>/{ application }-{profile}.properties</li>
<li>/{ label }/{ application }-{profile}.properties<br>上面的 url 会映射 {application}-{profile} .properties 对应的配置文件，其中 {label} 对应Git上不同的分支，默认为 master 。我们可以尝试构造不同的 url 来访问不同的配置内容， 例如：<a target="_blank" rel="noopener" href="http://localhost:8888/%7BapplicationName%7D/%7Bprofile%7D/%7Blabel%7D">http://localhost:8888/{applicationName}/{profile}/{label}</a> , label分支，不传的话默认master。</li>
</ul>
<h2 id="Config-client"><a href="#Config-client" class="headerlink" title="Config client"></a>Config client</h2><h3 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="添加配置-bootstrap-properties"><a href="#添加配置-bootstrap-properties" class="headerlink" title="添加配置 bootstrap.properties"></a>添加配置 bootstrap.properties</h3><p>server.port=8769</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=CLOUD-CONFIG-CLIENT</span><br><span class="line">eureka.instance.hostname=localhost</span><br><span class="line">eureka.client.registerWithEureka=true</span><br><span class="line">eureka.client.fetchRegistry=true</span><br><span class="line">eureka.client.serviceUrl.defaultZone:http://$&#123;eureka.instance.hostname&#125;:8761/eureka/</span><br><span class="line">spring.cloud.config.profile=dev</span><br><span class="line">spring.cloud.config.name=client-app</span><br><span class="line">spring.cloud.config.discovery.serviceId=CLOUD-CONFIG-SERVER</span><br><span class="line">spring.cloud.config.discovery.enabled=true</span><br></pre></td></tr></table></figure>


<h2 id="配置刷新"><a href="#配置刷新" class="headerlink" title="配置刷新"></a>配置刷新</h2><h3 id="手动调用config-client的refresh接口"><a href="#手动调用config-client的refresh接口" class="headerlink" title="手动调用config-client的refresh接口"></a>手动调用config-client的refresh接口</h3><ul>
<li><p>添加依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.6.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>添加配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.web.exposure.include=refresh</span><br><span class="line">management.endpoints.web.discovery.enabled=true</span><br></pre></td></tr></table></figure></li>
<li><p>需用使用配置的类加@RefreshScope<br><img src="/2022/02/22/springcloudconfig/img_3.png" alt="img_3.png"></p>
</li>
<li><p>Post请求接口<br><img src="/2022/02/22/springcloudconfig/img_2.png" alt="img_2.png"></p>
</li>
</ul>
<h2 id="自动刷新-利用git-webhook"><a href="#自动刷新-利用git-webhook" class="headerlink" title="自动刷新,利用git webhook"></a>自动刷新,利用git webhook</h2><ul>
<li>安装rabbitmq</li>
<li>configserver添加依赖<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.6.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
<li>configserver添加配置<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.host=localhost</span><br><span class="line">spring.rabbitmq.port=5672</span><br><span class="line">spring.rabbitmq.username=guest</span><br><span class="line">spring.rabbitmq.password=guest</span><br><span class="line"></span><br><span class="line">management.endpoints.web.exposure.include=*</span><br></pre></td></tr></table></figure></li>
<li>Configclient 添加依赖 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> &lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.6.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li>ConfigClient 添加配置<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.host=localhost</span><br><span class="line">spring.rabbitmq.port=5672</span><br><span class="line">spring.rabbitmq.username=guest</span><br><span class="line">spring.rabbitmq.password=guest</span><br></pre></td></tr></table></figure></li>
<li>需要刷新的配置类加@RefreshScope</li>
<li>配置configserver bus-refresh webhook<br><img src="/2022/02/22/springcloudconfig/img.png" alt="img.png"><br><a target="_blank" rel="noopener" href="http://localhost:8768/actuator/bus-refresh">http://localhost:8768/actuator/bus-refresh</a><br><img src="/2022/02/22/springcloudconfig/img_1.png" alt="img_1.png"></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">苏ICP备14022081号-4 </a>
  </div>

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ren zheng xiao</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
