<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.imder.top","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.8.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="mysql优化聚集索引和非聚集索引 聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个  聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续 聚集索引:物理存储按照索引排序；聚集索引是一种索引组织形式，索引的键值逻辑顺序决定了表数据行的物理存储顺序。非聚集索引:物理存储不按照索引排序；非聚集索引则就是普通索引，仅仅只是对数据列创建相应的索引，不影响整个表的物理存储">
<meta property="og:type" content="article">
<meta property="og:title" content="mysql优化">
<meta property="og:url" content="https://blog.imder.top/2022/02/28/mysql%E4%BC%98%E5%8C%96/index.html">
<meta property="og:site_name" content="随记">
<meta property="og:description" content="mysql优化聚集索引和非聚集索引 聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个  聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续 聚集索引:物理存储按照索引排序；聚集索引是一种索引组织形式，索引的键值逻辑顺序决定了表数据行的物理存储顺序。非聚集索引:物理存储不按照索引排序；非聚集索引则就是普通索引，仅仅只是对数据列创建相应的索引，不影响整个表的物理存储">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.imder.top/2022/02/28/mysql%E4%BC%98%E5%8C%96/img.png">
<meta property="og:image" content="https://blog.imder.top/2022/02/28/mysql%E4%BC%98%E5%8C%96/img_1.png">
<meta property="article:published_time" content="2022-02-28T14:59:29.000Z">
<meta property="article:modified_time" content="2024-03-28T16:43:20.063Z">
<meta property="article:author" content="Ren zheng xiao">
<meta property="article:tag" content="Mysql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.imder.top/2022/02/28/mysql%E4%BC%98%E5%8C%96/img.png">


<link rel="canonical" href="https://blog.imder.top/2022/02/28/mysql%E4%BC%98%E5%8C%96/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://blog.imder.top/2022/02/28/mysql%E4%BC%98%E5%8C%96/","path":"2022/02/28/mysql优化/","title":"mysql优化"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>mysql优化 | 随记</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
  <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas>
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
   <script type="text/javascript" src="/js/fireworks.js"></script>
<link rel="alternate" href="/atom.xml" title="随记" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">随记</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记一记,所学,温故而知新</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#mysql%E4%BC%98%E5%8C%96"><span class="nav-number">1.</span> <span class="nav-text">mysql优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="nav-number">1.1.</span> <span class="nav-text">聚集索引和非聚集索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mysql%E7%9A%84myisam%E5%92%8Cinnodb%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.</span> <span class="nav-text">mysql的myisam和innodb区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#b-tree%E5%92%8Cb-tree"><span class="nav-number">1.3.</span> <span class="nav-text">b-tree和b+tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="nav-number">1.4.</span> <span class="nav-text">执行计划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#explain%E4%B8%A4%E4%B8%AA%E5%8F%98%E7%A7%8D"><span class="nav-number">1.4.1.</span> <span class="nav-text">explain两个变种</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#explain%E4%B8%AD%E7%9A%84%E5%88%97"><span class="nav-number">1.4.2.</span> <span class="nav-text">explain中的列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E4%BC%98"><span class="nav-number">1.5.</span> <span class="nav-text">调优</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%AE%9E%E8%B7%B5"><span class="nav-number">1.5.1.</span> <span class="nav-text">索引实践</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90%E5%BB%BA%E8%A1%A8%E6%97%B6%E5%AD%97%E6%AE%B5%E4%B8%BAnot-null"><span class="nav-number">1.5.2.</span> <span class="nav-text">为什么推荐建表时字段为not null?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96"><span class="nav-number">1.5.3.</span> <span class="nav-text">排序优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="nav-number">1.5.4.</span> <span class="nav-text">分页查询优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#join%E5%85%B3%E8%81%94%E4%BC%98%E5%8C%96"><span class="nav-number">1.5.5.</span> <span class="nav-text">join关联优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#in%E5%92%8Cexsits%E4%BC%98%E5%8C%96-%EF%BC%9A%E5%B0%8F%E8%A1%A8%E9%A9%B1%E5%8A%A8%E5%A4%A7%E8%A1%A8"><span class="nav-number">1.5.6.</span> <span class="nav-text">in和exsits优化 ：小表驱动大表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#count%EF%BC%88-%EF%BC%89%E4%BC%98%E5%8C%96"><span class="nav-number">1.5.7.</span> <span class="nav-text">count（*）优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81"><span class="nav-number">1.5.8.</span> <span class="nav-text">锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%A6%82%E4%BD%95%E5%9B%9E%E7%AD%94mysql%E7%9B%B8%E5%85%B3%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-number">1.5.9.</span> <span class="nav-text">面试过程中如何回答mysql相关的优化？</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ren zheng xiao"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Ren zheng xiao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">38</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.imder.top/2022/02/28/mysql%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ren zheng xiao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="随记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          mysql优化
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 14:59:29" itemprop="dateCreated datePublished" datetime="2022-02-28T14:59:29+00:00">2022-02-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2024-03-28 16:43:20" itemprop="dateModified" datetime="2024-03-28T16:43:20+00:00">2024-03-28</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Mysql/" itemprop="url" rel="index"><span itemprop="name">Mysql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="mysql优化"><a href="#mysql优化" class="headerlink" title="mysql优化"></a>mysql优化</h1><h2 id="聚集索引和非聚集索引"><a href="#聚集索引和非聚集索引" class="headerlink" title="聚集索引和非聚集索引"></a>聚集索引和非聚集索引</h2><ul>
<li>聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个 </li>
<li>聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续</li>
<li>聚集索引:物理存储按照索引排序；聚集索引是一种索引组织形式，索引的键值逻辑顺序决定了表数据行的物理存储顺序。<br>非聚集索引:物理存储不按照索引排序；非聚集索引则就是普通索引，仅仅只是对数据列创建相应的索引，不影响整个表的物理存储顺序。</li>
<li>聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。</li>
</ul>
<h2 id="mysql的myisam和innodb区别"><a href="#mysql的myisam和innodb区别" class="headerlink" title="mysql的myisam和innodb区别"></a>mysql的myisam和innodb区别</h2><ul>
<li>索引结构<br>  InnoDB的数据文件本身就是主索引文件<br>  MyISAM的主索引和数据是分开的<br>  InnoDB的辅助索引data域存储相应记录主键的值而不是地址<br>  MyISAM的辅助索引和主索引没有多大区别<br>  InnoDB是聚簇索引，数据挂在主键索引之下</li>
<li>锁<br>  myisam 只支持表锁<br>  innodb 支持行锁</li>
<li>事务<br>  myisam 没有事务和mvcc<br>  innodb 支持事务和mvcc</li>
<li>主键<br>  MyISAM允许没有任何索引和主键的表存在，索引都是保存行的地址<br>  InnoDB如果没有设定主键或非空唯一索引，就会自动生成一个6字节的主键，数据是主索引的一部分，附加索引保存的是主索引的值</li>
<li>外键<br>  MyISAM不支持，InnoDB支持</li>
</ul>
<h2 id="b-tree和b-tree"><a href="#b-tree和b-tree" class="headerlink" title="b-tree和b+tree"></a>b-tree和b+tree</h2><p>一棵m阶的B-Tree有如下特性：<br>    1. 每个节点最多有m个孩子。<br>    2. 除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。<br>    3. 若根节点不是叶子节点，则至少有2个孩子<br>    4. 所有叶子节点都在同一层，且不包含其它关键字信息<br>    5. 每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn）<br>    6. 关键字的个数n满足：ceil(m/2)-1 &lt;= n &lt;= m-1<br>    7. ki(i=1,…n)为关键字，且关键字升序排序。<br>    8. Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)</p>
<p><img src="/2022/02/28/mysql%E4%BC%98%E5%8C%96/img.png" alt="img.png"><br>每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。</p>
<p>模拟查找关键字29的过程：<br>    1. 根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】<br>    2. 比较关键字29在区间（17,35），找到磁盘块1的指针P2。<br>    3. 根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】<br>    4. 比较关键字29在区间（26,30），找到磁盘块3的指针P2。<br>    5. 根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】<br>    6. 在磁盘块8中的关键字列表中找到关键字29。</p>
<p>B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。<br>B+Tree相对于B-Tree有几点不同：<br>    1. 非叶子节点只存储键值信息。<br>    2. 所有叶子节点之间都有一个链指针。<br>    3. 数据记录都存放在叶子节点中。“”<br><img src="/2022/02/28/mysql%E4%BC%98%E5%8C%96/img_1.png" alt="img_1.png"><br>推算：<br>    InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为〖10〗^3）。<br>    也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * （16KB/每条数据的大小+键值=100B）= 1600万 条记录。<br>    实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2-4层。<br>    mysql的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。</p>
<h2 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h2><h3 id="explain两个变种"><a href="#explain两个变种" class="headerlink" title="explain两个变种"></a>explain两个变种</h3><ul>
<li>explain extended:会在 explain 的基础上额外提供一些查询优化的信息，紧随其后通过 show warnings 命令可以得到优化后的查询语句，从而看出优化器优化了什么。<ul>
<li>例如：explain extended select * from film where id = 1;</li>
<li>sshow warnings;</li>
</ul>
</li>
<li>explain partitions:相比 explain 多了个 partitions 字段，如果查询是基于分区表的 话，会显示查询将访问的分区。</li>
</ul>
<h3 id="explain中的列"><a href="#explain中的列" class="headerlink" title="explain中的列"></a>explain中的列</h3><ul>
<li>id列<ul>
<li>select语句的编号，越大越先执行</li>
<li>相同编号，从上往下执行</li>
</ul>
</li>
<li>select_type列<ul>
<li>simple 简单查询</li>
<li>primary 复杂查询最外层的查询</li>
<li>subquery 子查询但是不包括from后的子查询</li>
<li>derived from 后的子查询</li>
<li>union union后的select</li>
</ul>
</li>
<li>table列 查询的表<ul>
<li>当from子句中有子查询时，table列是 <derivenN> 格式，表示当前查询依赖 id=N 的查 询，于是先执行 id=N 的查询</li>
<li>当有 union 时，UNION RESULT 的 table 列的值为&lt;union1,2&gt;，1和2表示参与 union 的 select 行id</li>
</ul>
</li>
<li>type列：查询类型<ul>
<li>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL 一般来说，得保证查询达到range级别，最好达到ref</li>
<li>const, system:mysql能对查询的某部分进行优化并将其转化成一个常量</li>
<li>eq_ref:primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。</li>
<li>ref: 简单 select 查询，name是普通索引(非唯一索引)；关联表查询，使用联合索引连接</li>
<li>range：范围扫描通常出现在 in(), between ,&gt; ,&lt;, &gt;= 等操作中。使用一个索引来检索给定范围的行。</li>
<li>index:扫描全表索引</li>
<li>ALL:全表扫描，</li>
</ul>
</li>
<li>possible_keys列<br>  可能使用哪些索引来查找</li>
<li>key列<br>  mysql实际采用哪个索引来优化对该表的访问</li>
<li>key_len列<ul>
<li>mysql在索引里使用的字节数，算出具体使用了索引中的哪些列。</li>
<li>key_len计算规则如下: 字符串:char(n):n字节长度;varchar(n):2字节存储字符串长度，如果是utf-8，则长度 3n +2。数值类型:tinyint:1字节;smallint:2字节;int:4字节 ;bigint:8字节。时间类型:date:3字节;timestamp:4字节;datetime:8字节</li>
<li>如果字段允许为 NULL，需要1字节记录是否为 NULL</li>
<li>索引最大长度是768字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引。</li>
</ul>
</li>
<li>ref列 key列记录的索引中，表查找值所用到的列或常量，常见的有:const(常量)，字段名</li>
<li>rows列 mysql估计要读取并检测的行数，注意不是结果集里的行数。</li>
<li>Extra列:额外信息<ul>
<li>1)Using index:查询的列被索引覆盖，并且where筛选条件是索引的是前导列</li>
<li>2)Using where:查询的列未被索引覆盖，where筛选条件非索引的前导列</li>
<li>3)Using index condition:查询的列不全在索引中，where条件中是一个前导列的范围；查询列不完全被索引覆盖，查询条件完全可以使用到索引</li>
<li>4)Using temporary:mysql需要创建一张临时表来处理查询</li>
<li>5)Using filesort:将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序</li>
<li>6)Select tables optimized away:使用某些聚合函数(比如 max、min)来访问存在索引的某个字段</li>
<li><ol start="7">
<li>Using where Using index 查询的列被索引覆盖，并且where筛选条件是索引列之一但是不是索引的不是前导列</li>
</ol>
</li>
<li><ol start="8">
<li>NULL 查询的列未被索引覆盖，并且where筛选条件是索引的前导列，需要回表</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h2><h3 id="索引实践"><a href="#索引实践" class="headerlink" title="索引实践"></a>索引实践</h3><ul>
<li><p>查询条件全值匹配</p>
</li>
<li><p>最左前缀法则，联合索引，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。</p>
</li>
<li><p>不在索引列上做任何操作(计算、函数、(自动or手动)类型转换)，会导致索引失效而转向全表扫描</p>
</li>
<li><p>存储引擎不能使用联合索引（A，B）中（A）范围条件右边的列（B）</p>
</li>
<li><p>尽量使用覆盖索引(只访问索引的查询(索引列包含查询列))，减少select *语句</p>
</li>
<li><p>mysql在使用不等于(!=或者&lt;&gt;)的时候无法使用索引会导致全表扫描</p>
</li>
<li><p>is null,is not null 也无法使用索引</p>
</li>
<li><p>like以通配符开头(‘%abc…’)mysql索引失效会变成全表扫描操作</p>
<ul>
<li>解决like’%字符串%’索引不被使用的方法? <ul>
<li>a)使用覆盖索引，查询字段必须是建立覆盖索引字段</li>
<li>b)如果不能使用覆盖索引则可能需要借助搜索引擎</li>
</ul>
</li>
</ul>
</li>
<li><p>字符串不加单引号索引失效</p>
</li>
<li><p>少用or或in，用它查询时，mysql不一定使用索引，mysql内部优化器会根据检索比例、 表大小等多个因素整体评估是否使用索引，详见范围查询优化</p>
</li>
<li><p>范围查询优化，可能是由于单次数据量查询过大导致优化器最终选择不走索引 优化方法:可以讲大的范围拆分成多个小</p>
<h3 id="为什么推荐建表时字段为not-null"><a href="#为什么推荐建表时字段为not-null" class="headerlink" title="为什么推荐建表时字段为not null?"></a>为什么推荐建表时字段为not null?</h3></li>
<li><p>通常情况下最好指定列为NOT NULL，除非真的需要存储NULL值。</p>
<ul>
<li>如果查询中包含可为NULL的列，对MySql来说更难优化，因为可为NULL的列使得索引、索引统计和值比较都更复杂。</li>
<li>可为NULL的列会使用更多的存储空间，在MySql里也需要特殊处理。当可为NULL的列被索引时，每个索引记录需要一个额外的字节，在MyISAM里甚至还可能导致固定大小的索引（例如只有一个整数列的索引）变成可变大小的索引。</li>
<li>通常把可为NULL的列改为NOT NULL带来的性能提升比较小，所以（调优时）没有必要首先在现有schema中查找并修改掉这种情况，除非确定这会导致问题。</li>
<li>如果计划在列上建索引，就应该尽量避免设计成可为NULL的列。</li>
</ul>
</li>
<li><p>mysql的默认值</p>
</li>
</ul>
<p>对于MySql而言，如果不主动设置为NOT NULL的话，那么插入数据的时候默认值就是NULL。NULL和NOT NULL使用的空值代表的含义是不一样，NULL可以认为这一列的值是未知的，空值则可以认为我们知道这个值，只不过他是空的而已。举个例子，一张表中的某一条name字段是NULL，我们可以认为不知道名字是什么，反之如果是空字符串则可以认为我们知道没有名字，他就是一个空值。而对于大多数程序的情况而言，没有什么特殊需要非要字段要NULL的吧，NULL值反而会对程序造成比如空指针的问题。</p>
<p>默认值为NULL带来的问题</p>
<ul>
<li><p>聚合函数不准确<br>  对于NULL值的列，使用聚合函数的时候会忽略NULL值。例如：有一张表，name字段默认是NULL，此时对name进行count得出的结果是1，这个是错误的。count(*)是对表中的行数进行统计，count(name)则是对表中非NULL的列进行统计。</p>
</li>
<li><p>=失效<br>  对于NULL值的列，是不能使用=表达式进行判断的，下面对name的查询是不成立的，必须使用is NULL。</p>
</li>
<li><p>与其他值运算<br>  NULL和其他任何值进行运算都是NULL，包括表达式的值也是NULL。user表第二条记录age是NULL，所以+1之后还是NULL，name是NULL，进行concat运算之后结果还是NULL。</p>
</li>
<li><p>distinct、group by、order by<br>  对于distinct和group by来说，所有的NULL值都会被视为相等，对于order by来说升序NULL会排在最前。</p>
</li>
<li><p>索引问题</p>
<ul>
<li>官方文档：使用is NULL和范围查询都是可以和正常一样使用索引的，只不过在某些场景下，由于mysql的执行策略导致索引失效。</li>
<li>sql执行过程中，到优化器阶段，会选择使用什么索引比较合理，sql具体执行方案在这里确定下来，索引列存在NULL就会导致优化器在做索引选择的时候更复杂，更加难以优化。</li>
</ul>
</li>
</ul>
<h3 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h3><ul>
<li>MySQL支持两种方式的排序filesort和index，Using index是指MySQL扫描索引本身完成排序。index效率高，filesort效率低。<ul>
<li>order by满足两种情况会使用Using index。<ul>
<li>order by语句使用索引最左前列。</li>
<li>使用where子句与order by子句条件列组合满足索引最左前列。 </li>
</ul>
</li>
<li>尽量在索引列上完成排序，遵循索引建立(索引创建的顺序)时的最左前缀法则。</li>
<li>如果order by的条件不在索引列上，就会产生Using filesort。</li>
<li>能用覆盖索引尽量用覆盖索引</li>
<li>group by与order by很类似，其实质是先排序后分组，遵照索引创建顺序的最左前缀法则。对于group by的优化如果不需要排序的可以加上order by null禁止排序。注意，where高于having，能写在where中 的限定条件就不要去having限定了。</li>
</ul>
</li>
</ul>
<ul>
<li><p>Using filesort文件排序原理详解 filesort文件排序方式</p>
<ul>
<li><p>单路排序:是一次性取出满足条件行的所有字段，然后在sort buffer中进行排序;用trace工具可 以看到sort_mode信息里显示&lt; sort_key, additional_fields &gt;或者&lt; sort_key, packed_additional_fields &gt;</p>
</li>
<li><p>双路排序(回表排序模式):是首先根据相应的条件取出相应的排序字段和可以直接定位行数据的行 ID，然后在 sort buffer 中进行排序，排序完后需要再次取回其它需要的字段;用trace工具 可以看到sort_mode信息里显示&lt; sort_key, rowid &gt;</p>
</li>
<li><p>MySQL 通过比较系统变量 max_length_for_sort_data(默认1024字节) 的大小和需要查询的字段总大小来 判断使用哪种排序模式。如果 max_length_for_sort_data 比查询字段的总长度大，那么使用 单路排序模式; 如果 max_length_for_sort_data 比查询字段的总长度小，那么使用 双路排序模式。</p>
</li>
</ul>
</li>
</ul>
<p>例如：select * from a_table where b = ‘111’ order by c; 注：字段b建立索引，字段c无索引</p>
<ul>
<li>单路排序:<ol>
<li>索引b找到第一个满足 b = ‘111’ 条件的主键id </li>
<li>根据主键 id 取出整行，取出所有字段的值，存入 sort_buffer 中 </li>
<li>从索引b找到下一个满足 b = ‘111’ 条件的主键 id </li>
<li>重复步骤 2、3 直到不满足  b = ‘111’ </li>
<li>对 sort_buffer 中的数据按照字段 c 进行排序</li>
<li>返回结果给客户端</li>
</ol>
</li>
<li>双路排序: set max_length_for_sort_data = 10; ‐‐设置表所有字段长度总和肯定大于10字节<ol>
<li>从索引 b 找到第一个满足 b = ‘111’ 的主键id</li>
<li>根据主键 id 取出整行，把排序字段 c 和主键 id 这两个字段放到 sort buffer 中 </li>
<li>从索引 b 取下一个满足 b = ‘111’ 记录的主键 id</li>
<li>重复 3、4 直到不满足 b = ‘111’</li>
<li>对 sort_buffer 中的字段 c 和主键 id 按照字段 c 进行排序</li>
<li>遍历排序好的 id 和字段 c，按照 id 的值回到原表中取出 所有字段的值返回给客户端</li>
</ol>
</li>
</ul>
<p>如果全部使用sort_buffer内存排序一般情况下效率会高于磁盘文件排序，但不能因为这个就随便增 大sort_buffer(默认1M)，mysql很多参数设置都是做过优化的，不要轻易调整。</p>
<h3 id="分页查询优化"><a href="#分页查询优化" class="headerlink" title="分页查询优化"></a>分页查询优化</h3><p>例如：select * from employees limit 10000,10<br>从表 employees 中取出从 10001 行开始的 10 行记录。看似只查询了 10 条记录，实际这条 SQL 是先读取 10010 条记录，然后抛弃前 10000 条记录，然后读到后面 10 条想要的数据。因此要查询一张大表比较靠后的数据，执行效率 是非常低的。</p>
<ul>
<li>按照主键排序并limit：条件：主键自增且连续，结果是按照主键排序的<br>  select * from employees where id &gt; 90000 limit 5; 没单独加 order by，表示通过主键排序</li>
<li>根据非主键字段排序的分页查询:连接子查询，子查询使用覆盖索引<br>  select * from employees ORDER BY name limit 90000,5; name字段有索引，但是查询计划显示没有走索引，使用索引比全表扫描成本高<br>  优化方案：select * from employees e inner join (select id from employees order by name limit 90000,5) eq on eq.id = e.id</li>
</ul>
<h3 id="join关联优化"><a href="#join关联优化" class="headerlink" title="join关联优化"></a>join关联优化</h3><ul>
<li>mysql的表关联常见有两种算法<ul>
<li>Nested-Loop Join 算法</li>
<li>Block Nested-Loop Join 算法</li>
</ul>
</li>
<li>嵌套循环连接 Nested-Loop Join(NLJ)算法 ：优化器一般会优先选择小表做驱动表，执行计划 Extra 中未出现 Using join buff<ul>
<li>循环地从第一张表(称为驱动表)中读取行，在这行数据中取到关联字段，根据关联字段在另一张表(被驱动表)里取出满足条件的行，然后取出两张表的结果合集。</li>
<li>select*from t1 inner join t2 on t1.a= t2.a; 这里假设t2小表（100条） t1大表 （10000）</li>
<li>上面sql的大致流程如下:<ol>
<li>从表 t2 中读取一行数据;</li>
<li>从第 1 步的数据中，取出关联字段 a，到表 t1 中查找;</li>
<li>取出表 t1 中满足条件的行，跟 t2 中获取到的结果合并，作为结果返回给客户端; </li>
<li>重复上面 3 步。</li>
</ol>
</li>
<li>整个过程会读取 t2 表的所有数据(扫描100行)，然后遍历这每行数据中字段 a 的值，根据 t2 表中 a 的值索引扫描 t1 表 中的对应行(扫描100次 t1 表的索引，1次扫描可以认为最终只扫描 t1 表一行完整数据，也就是总共 t1 表也扫描了100 行)。因此整个过程扫描了 200 行。</li>
<li>如果被驱动表的关联字段没索引，使用NLJ算法性能会比较低(下面有详细解释)，mysql会选择Block Nested-Loop Join 算法。</li>
</ul>
</li>
<li>基于块的嵌套循环连接 Block Nested-Loop Join(BNL)算法：被驱动表连接字段无索引<ul>
<li>把驱动表的数据读入到 join_buffer 中，然后扫描被驱动表，把被驱动表每一行取出来跟 join_buffer 中的数据做对比。 </li>
<li>select*from t1 inner join t2 on t1.b= t2.b; 这里假设t2小表（100条） t1大表 （10000）<ol>
<li>把 t2 的所有数据放入到 join_buffer 中</li>
<li>把表 t1 中每一行取出来，跟 join_buffer 中的数据做对比 3. 返回满足 join 条件的数据</li>
</ol>
</li>
<li>整个过程对表 t1 和 t2 都做了一次全表扫描，因此扫描的总行数为10000(表 t1 的数据总量) + 100(表 t2 的数据总量) = 10100。并且 join_buffer 里的数据是无序的，因此对表 t1 中的每一行，都要做 100 次判断，所以内存中的判断次数是 100 * 10000= 100 万次。</li>
</ul>
</li>
</ul>
<p>被驱动表的关联字段没索引为什么要选择使用 BNL 算法而不使用 Nested-Loop Join 呢?<br>如果上面第二条sql使用 Nested-Loop Join，那么扫描行数为 100 * 10000 = 100万次，这个是磁盘扫描。<br>很显然，用BNL磁盘扫描次数少很多，相比于磁盘扫描，BNL的内存计算会快得多。</p>
<h3 id="in和exsits优化-：小表驱动大表"><a href="#in和exsits优化-：小表驱动大表" class="headerlink" title="in和exsits优化 ：小表驱动大表"></a>in和exsits优化 ：小表驱动大表</h3><ul>
<li>A表与B表的ID字段应建立索引</li>
<li>in:当B表的数据集小于A表的数据集时，in优于exists<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from A where id in(select id from B)</span><br><span class="line">等价于 </span><br><span class="line">for  bid in select * from B</span><br><span class="line">    select * from A where id = bid  //先扫描索引，然后在根据索引查数据</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>exists:当A表的数据集小于B表的数据集时，exists优于in<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from A where exists(select 1 from B where B.id=A.id)</span><br><span class="line"> 等价于</span><br><span class="line"> for(select * from A)&#123;</span><br><span class="line"> select * from B where B.id = A.id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="count（-）优化"><a href="#count（-）优化" class="headerlink" title="count（*）优化"></a>count（*）优化</h3>id为主键，name普通索引<br>EXPLAIN select count(1) from employees;<br>EXPLAIN select count(id) from employees;<br>EXPLAIN select count(name) from employees;<br>EXPLAIN select count(*) from employees;<br>四个sql的执行计划一样，说明这四个sql执行效率应该差不多，区别在于根据某个字段count不会统计字段为null值的数据行<br>为什么mysql最终选择辅助索引而不是主键聚集索引?因为二级索引相对主键索引存储数据更少，检索性能应该更高</li>
</ul>
<p>常见优化方法<br>1、查询mysql自己维护的总行数 对于myisam存储引擎的表做不带where条件的count查询性能是很高的，因为myisam存储引擎的表的总行数会被 mysql存储在磁盘上，查询不需要计算<br>对于innodb存储引擎的表mysql不会存储表的总记录行数，查询count需要实时计算<br>2、show table status 如果只需要知道表总行数的估计值可以用如下sql查询，性能很高<br>3、将总数维护到Redis里 插入或删除表数据行的时候同时维护redis里的表总行数key的计数值(用incr或decr命令)，但是这种方式可能不准，很难 保证表操作和redis操作的事务一致性<br>4、增加计数表 插入或删除表数据行的时候同时维护计数表，让他们在同一个事务里操作</p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ul>
<li>锁分类<ul>
<li>性能上分为乐观锁和悲观锁</li>
<li>对数据库的操作上分为读锁(共享锁：多个读不影响)和写锁(排他锁：阻断其他读写锁)，都属于悲观锁</li>
<li>从数据的操作粒度上分表锁和行锁</li>
</ul>
</li>
<li>表锁<ul>
<li>每次操作锁住整张表。开销小，加锁快;不会出现死锁;锁定粒度大，发生锁冲突的概率最高，并发度最低</li>
<li>手动增加表锁 lock table 表名称 read(write),表名称2 read(write);</li>
<li>查看表上加过的锁show open tables;</li>
<li>删除表锁 unlock tables;</li>
<li>MyISAM在执行查询语句(SELECT)前,会自动给涉及的所有表加读锁,在执行增删改操作前,会自动给涉及的表加写锁。</li>
<li>读锁会阻塞写，不会阻塞读。写锁则会把读和写都阻塞</li>
</ul>
</li>
</ul>
<ul>
<li><p>行锁 </p>
<ul>
<li>每次操作锁住一行数据。开销大，加锁慢;会出现死锁;锁定粒度最小，发生锁，冲突的概率最低，并发度最高。</li>
</ul>
</li>
<li><p>InnoDB与MYISAM的最大不同有两点:<br>  支持事务(TRANSACTION) 支持行级锁</p>
</li>
</ul>
<h3 id="面试过程中如何回答mysql相关的优化？"><a href="#面试过程中如何回答mysql相关的优化？" class="headerlink" title="面试过程中如何回答mysql相关的优化？"></a>面试过程中如何回答mysql相关的优化？</h3><ul>
<li><p>从建表语句</p>
<ul>
<li>主键尽量使用整形自增<ul>
<li>占用空间小</li>
<li>主键自增，新增的数据永远在后面</li>
<li>排序效率高</li>
<li>范围查找</li>
</ul>
</li>
<li>表字段使用not null,null值很难查询且占用额外空间</li>
<li>单表字段不要太多</li>
<li>建立查询字段索引</li>
</ul>
</li>
<li><p>从一条查询语句</p>
<ul>
<li>不用select*</li>
<li>尽可能使用覆盖索引，避免回表</li>
<li>join 字段建立索引</li>
<li> 大表 in 小表  ，小表 exist 大表</li>
<li>查询条件不用函数</li>
<li>避免使用不等于</li>
<li>对于连续数值，使用BETWEEN不用IN</li>
<li>避免like ‘%xxx’</li>
<li>不做列运算</li>
<li>limit 查询用连接子查询优化，子查询使用覆盖索引</li>
</ul>
</li>
<li><p>拆分大的delete或insert语句</p>
</li>
<li><p>可通过开启慢查询日志来找出较慢的SQL</p>
</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.jpg" alt="Ren zheng xiao 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpg" alt="Ren zheng xiao 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/Mysql/" rel="tag"># Mysql</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/02/22/%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB%E5%88%92%E5%88%86/" rel="prev" title="逻辑关系划分">
                  <i class="fa fa-chevron-left"></i> 逻辑关系划分
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/02/28/%E5%AD%A6MQ%E6%89%80%E5%BE%97/" rel="next" title="学MQ所得">
                  学MQ所得 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">苏ICP备14022081号-4 </a>
  </div>

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ren zheng xiao</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
