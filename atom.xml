<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随记</title>
  
  <subtitle>记一记,所学,温故而知新</subtitle>
  <link href="https://blog.imder.top/atom.xml" rel="self"/>
  
  <link href="https://blog.imder.top/"/>
  <updated>2024-03-28T16:43:20.075Z</updated>
  <id>https://blog.imder.top/</id>
  
  <author>
    <name>Ren zheng xiao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>zookeeper</title>
    <link href="https://blog.imder.top/2022/04/22/zookeeper/"/>
    <id>https://blog.imder.top/2022/04/22/zookeeper/</id>
    <published>2022-04-22T12:43:00.000Z</published>
    <updated>2024-03-28T16:43:20.075Z</updated>
    
    <content type="html"><![CDATA[<h1 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h1><h1 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h1><p>服务器节点状态 ： LOOKING 竞选状态,FOLLOWING 随从状态,LEADING 领导状态,OBSERVING 观察状态，不参与投票<br>服务器ID ：sid<br>事务ID ：zxid</p><p>规则：交换投票信息，对方事务id比自己大的，下一次投票投给对方节点，如果事务id相同，服务器id比自己大的，下一次投票给对方节点，多个取最大，投票给最大；当选票大于总节点一半时，选票多的机器变为leader,其余变成follow</p><p>假设5台机器<br>1.服务器1启动，投票给自己，（zxid=0,sid=1）,只有一票<br>2.服务器2启动，投票给自己，（zxid=0,sid=2）,并和服务器1交换信息，服务器1更改选票投给服务器2 ，服务器2只有两票<br>3.服务器3启动，投票给自己，（zxid=0,sid=3）,并和服务器1、2交换信息，服务器1、2更改选票投给服务器3 ，服务器3只有三票 》2.5 ，成为leader ，服务器1，2成功follow<br>4. 服务器4启动，投票给自己 ，（zxid=0,sid=4）, 并和服务器1，2，3交换选票，但是此时服务器1，2，3已经不是looking状态，服务器3 3票，服务器 4 1票，服务器4成为follow<br>5. 服务器5启动，投票给自己 ，（zxid=0,sid=3）, 并和服务器1，2，3，4交换选票，但是此时服务器1，2，3，4已经不是looking状态，服务器3 4票，服务器5 1票，服务器5成为follow</p><p>leader挂了选举新leader？<br>服务器投票给自己，服务器1 （zxid=99,sid=1）服务器2 （zxid=102,sid=2）服务器4 （zxid=99,sid=4）服务器5 （zxid=99,sid=5），并交换选票信息，接下来改投票给服务器2，服务器2成为leader</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;zookeeper&quot;&gt;&lt;a href=&quot;#zookeeper&quot; class=&quot;headerlink&quot; title=&quot;zookeeper&quot;&gt;&lt;/a&gt;zookeeper&lt;/h1&gt;&lt;h1 id=&quot;选举&quot;&gt;&lt;a href=&quot;#选举&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="zookeeper" scheme="https://blog.imder.top/categories/zookeeper/"/>
    
    
    <category term="zookeeper" scheme="https://blog.imder.top/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>多线程</title>
    <link href="https://blog.imder.top/2022/04/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://blog.imder.top/2022/04/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2022-04-22T11:43:00.000Z</published>
    <updated>2024-03-28T16:43:20.075Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h1 id="线程数量与cpu的关系"><a href="#线程数量与cpu的关系" class="headerlink" title="线程数量与cpu的关系"></a>线程数量与cpu的关系</h1><p>如果是CPU密集型应用，则线程池大小设置为N+1<br>如果是IO密集型应用，则线程池大小设置为2N+1（因为io读数据或者缓存的时候，线程等待，此时如果多开线程，能有效提高cpu利用率）</p><p>最佳线程数目 = （（线程等待时间（非CPU运行时间，比如IO）+线程CPU时间）/线程CPU时间 ）* CPU数目<br>线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。<br>最佳线程数目 = （线程等待时间与线程CPU时间之比 + 1）* CPU数目</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多线程&quot;&gt;&lt;a href=&quot;#多线程&quot; class=&quot;headerlink&quot; title=&quot;多线程&quot;&gt;&lt;/a&gt;多线程&lt;/h1&gt;&lt;h1 id=&quot;线程数量与cpu的关系&quot;&gt;&lt;a href=&quot;#线程数量与cpu的关系&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="多线程" scheme="https://blog.imder.top/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="多线程" scheme="https://blog.imder.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>springboot-tomcat启动</title>
    <link href="https://blog.imder.top/2022/04/12/springboot-tomcat%E5%90%AF%E5%8A%A8/"/>
    <id>https://blog.imder.top/2022/04/12/springboot-tomcat%E5%90%AF%E5%8A%A8/</id>
    <published>2022-04-12T14:59:29.000Z</published>
    <updated>2024-03-28T16:43:20.067Z</updated>
    
    <content type="html"><![CDATA[<embed src="./tomcat启动.pdf" width="100%" height="1000" type="application/pdf">]]></content>
    
    
      
      
    <summary type="html">&lt;embed src=&quot;./tomcat启动.pdf&quot; width=&quot;100%&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot;&gt;

</summary>
      
    
    
    
    <category term="springboot" scheme="https://blog.imder.top/categories/springboot/"/>
    
    
    <category term="tomcat" scheme="https://blog.imder.top/tags/tomcat/"/>
    
    <category term="springboot" scheme="https://blog.imder.top/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>消金内部服务调用框架sif</title>
    <link href="https://blog.imder.top/2022/04/12/%E6%B6%88%E9%87%91%E5%86%85%E9%83%A8%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E6%A1%86%E6%9E%B6sif/"/>
    <id>https://blog.imder.top/2022/04/12/%E6%B6%88%E9%87%91%E5%86%85%E9%83%A8%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E6%A1%86%E6%9E%B6sif/</id>
    <published>2022-04-12T14:59:29.000Z</published>
    <updated>2024-03-28T16:43:20.083Z</updated>
    
    <content type="html"><![CDATA[<h1 id="服务端流程"><a href="#服务端流程" class="headerlink" title="服务端流程"></a>服务端流程</h1><embed src="./Sif2.0.pdf" width="100%" height="1000" type="application/pdf"><h1 id="客户端流程"><a href="#客户端流程" class="headerlink" title="客户端流程"></a>客户端流程</h1> <embed src="./sif2.0client.pdf" width="100%" height="1000" type="application/pdf">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;服务端流程&quot;&gt;&lt;a href=&quot;#服务端流程&quot; class=&quot;headerlink&quot; title=&quot;服务端流程&quot;&gt;&lt;/a&gt;服务端流程&lt;/h1&gt;&lt;embed src=&quot;./Sif2.0.pdf&quot; width=&quot;100%&quot; height=&quot;1000&quot; type=&quot;ap</summary>
      
    
    
    
    <category term="微服务" scheme="https://blog.imder.top/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="微服务" scheme="https://blog.imder.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="远程服务调用" scheme="https://blog.imder.top/tags/%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Spring</title>
    <link href="https://blog.imder.top/2022/03/31/spring/"/>
    <id>https://blog.imder.top/2022/03/31/spring/</id>
    <published>2022-03-31T14:59:29.000Z</published>
    <updated>2024-03-28T16:43:20.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="注册组件方法"><a href="#注册组件方法" class="headerlink" title="注册组件方法"></a>注册组件方法</h2><ul><li>1.包扫描+组件标注注解（@Controller/@Service/@Repository/@Component）[自己写的类]</li><li>2.@Bean[导入的第三方包里面的组件]</li><li>3.@Import[快速给容器中导入一个组件]<pre><code>  1.@Import(要导入到容器中的组件)；容器中就会自动注册这个组件，id默认是全类名  2.ImportSelector接口:返回需要导入的组件的全类名数组；  3.ImportBeanDefinitionRegistrar接口:手动注册bean到容器中</code></pre></li></ul><h2 id="spring-扩展点"><a href="#spring-扩展点" class="headerlink" title="spring 扩展点"></a>spring 扩展点</h2><h3 id="spring启动流程图"><a href="#spring启动流程图" class="headerlink" title="spring启动流程图"></a>spring启动流程图</h3><p><img src="/2022/03/31/spring/b.jpeg" alt="b"></p><h3 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h3><p>允许对Bean的定义进行修改，向ConfigurableListableBeanFactory里注册spring 的组件，比如添加 BeanPostProcessor、ApplicationListener、类型转换器等等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanFactoryPostProcessor &#123;</span><br><span class="line">    void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>应用<ul><li>单元测试懒加载<ul><li>有时候整个项目工程中bean的数量有上百个，而大部分单测依赖都是整个工程的xml，导致单测执行时需要很长时间（大部分时间耗费在xml中数百个单例非懒加载的bean的实例化及初始化过程）</li><li>解决方法：利用Spring提供的扩展点将xml中的bean设置为懒加载模式，省去了Bean的实例化与初始化时间</li></ul></li><li>BeanFactoryPostProcessor 来处理占位符 ${…}，关键的实现类是 PropertySourcesPlaceholderConfigurer，遍历所有的 BeanDefinition，如果 PropertyValue 存在这样的占位符，则会进行解析替换。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class LazyBeanFactoryProcessor implements BeanFactoryPostProcessor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">        DefaultListableBeanFactory fac = (DefaultListableBeanFactory) beanFactory;</span><br><span class="line">        Map&lt;String, AbstractBeanDefinition&gt; map = (Map&lt;String, AbstractBeanDefinition&gt;) ReflectionTestUtils.getField(fac, &quot;beanDefinitionMap&quot;);</span><br><span class="line">        for (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            //设置为懒加载</span><br><span class="line">            entry.getValue().setLazyInit(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PropertySourcesPlaceholderConfigurer extends PlaceholderConfigurerSupport implements EnvironmentAware &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">        // 省略对 PropertySources 的处理逻辑......</span><br><span class="line">        processProperties(beanFactory, new PropertySourcesPropertyResolver(this.propertySources));</span><br><span class="line">        this.appliedPropertySources = this.propertySources;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void processProperties(ConfigurableListableBeanFactory beanFactoryToProcess,</span><br><span class="line">            final ConfigurablePropertyResolver propertyResolver) throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">        propertyResolver.setPlaceholderPrefix(this.placeholderPrefix);</span><br><span class="line">        propertyResolver.setPlaceholderSuffix(this.placeholderSuffix);</span><br><span class="line">        propertyResolver.setValueSeparator(this.valueSeparator);</span><br><span class="line">        StringValueResolver valueResolver = new StringValueResolver() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public String resolveStringValue(String strVal) &#123;</span><br><span class="line">                String resolved = (ignoreUnresolvablePlaceholders ?</span><br><span class="line">                        propertyResolver.resolvePlaceholders(strVal) :</span><br><span class="line">                        propertyResolver.resolveRequiredPlaceholders(strVal));</span><br><span class="line">                if (trimValues) &#123;</span><br><span class="line">                    resolved = resolved.trim();</span><br><span class="line">                &#125;</span><br><span class="line">                return (resolved.equals(nullValue) ? null : resolved);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        // 调用父类 PlaceholderConfigurerSupport 进行 properties 处理</span><br><span class="line">        // 遍历每一个 BeanDefinition，并将其交给 BeanDefinitionVisitor 修改内部的属性</span><br><span class="line">        doProcessProperties(beanFactoryToProcess, valueResolver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="BeanDefinitionRegistryPostProcessor"><a href="#BeanDefinitionRegistryPostProcessor" class="headerlink" title="BeanDefinitionRegistryPostProcessor"></a>BeanDefinitionRegistryPostProcessor</h3><p>BeanDefinitionRegistryPostProcessor 是 BeanFactoryPostProcessor 的子类，可以通过编码的方式，改变、新增类的定义，甚至删除某些 bean 的定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor &#123;</span><br><span class="line">    void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 spring 初始化容器之后，解析Class 为一个BeanDefinition 之前的时候去执行， spring 中有一个开天辟地的类 ConfigurationClassPostProcessor 就是实现了该接口， ConfigurationClassPostProcessor 通过重写 这个方法</p><p>第一步：去扫描加了 @Configuration 注解的这些类，判断是否是AnnotatedBeanDefinition类型的，将这些类去打上 Lite/Full 的属性，以便后续使用 。<br>第二步：去实现扫描basePackage下的加了 @Service @Controller @Component 的这些类 将这些类变成为一个BeanDefinition 注册到 Spring 的BeanDefinitionMap中去 。<br>第三步： 去解析 @import，实现 ImportSelector接口的，实现 ImportBeanDefinitionRegistrar 接口的 这些类的方法，将对应的bean 解析为BeanDefinition，注册到BeanDefinitionMap 中<br>注意： 在新的Mybatis-spring 的框架中，也使用了到了这个接口 MapperScannerConfigurer 这个扫描配置类 也实现了这个接口！ 重写了postProcessBeanDefinitionRegistry() 用于创建扫描器对象，去扫描mybatis 里的那些接口转化为BeanDefinition到容器中去<br>作用： 有了参数 registry 的对象，就能手动向spring容器添加 自定义的BeanDefinition registry 提供了添加的 API，但是一般我们不调用 因为在spring里的执行顺序太早了</p><p>应用：</p><ul><li>spring 集成 mybatis，使用 spring 提供的扫描功能，为我们的Dao接口生成实现类而不需要编写具体的实现类，简化了大量的冗余代码          <ul><li>mybatis-spring 框架就是利用 BeanDefinitionRegistryPostProcessor通过编码的方式往spring容器中添加 bean。</li><li>MapperScannerConfigurer 重写了 postProcessBeanDefinitionRegistry方法，扫描Dao接口的BeanDefinition，并将BeanDefinition注册到 spring容器中。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class MapperScannerConfigurer implements BeanDefinitionRegistryPostProcessor, </span><br><span class="line">    InitializingBean, ApplicationContextAware, BeanNameAware &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">        if (this.processPropertyPlaceHolders) &#123;</span><br><span class="line">            processPropertyPlaceHolders();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // ClassPathMapperScanner 持有 BeanDefinitionRegistry 引用，可以添加 BeanDefinition</span><br><span class="line">        ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);</span><br><span class="line"></span><br><span class="line">        // 省略部分代码……，设置 ClassPathMapperScanner 各种属性</span><br><span class="line"></span><br><span class="line">        // 扫描并注册 Dao 接口的 BeanDefinition，当然是通过动态代理实现</span><br><span class="line">        scanner.scan(StringUtils.tokenizeToStringArray(this.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="InstantiationAwareBeanPostProcessor接口"><a href="#InstantiationAwareBeanPostProcessor接口" class="headerlink" title="InstantiationAwareBeanPostProcessor接口"></a>InstantiationAwareBeanPostProcessor接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface InstantiationAwareBeanPostProcessor extends BeanPostProcessor &#123;</span><br><span class="line">    Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) throws BeansException;</span><br><span class="line">    boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException;</span><br><span class="line">    PropertyValues postProcessPropertyValues(</span><br><span class="line">            PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>BeanPostProcessor的子接口，用于在实例化之后，但在设置显式属性或自动装配之前，设置实例化之前的回调函数。通常用于抑制特定目标bean的默认实例化，例如，创建具有特殊TargetSources（池化目标，延迟初始化目标等）的代理，或者实现其他注入策略，例如字段注入。注意：这个接口是一个专用接口，主要用于框架内的内部使用。 建议尽可能实现简单的BeanPostProcessor接口，或者从InstantiationAwareBeanPostProcessorAdapter派生，以便屏蔽此接口的扩展。</li><li>postProcessBeforeInstantiation方法，在目标bean实例化之前创建bean，如果在这里创建了bean，则不会走默认的实例化过程，通常用来创建代理。注意工厂方法生成的bean不会走这个方法。</li><li>postProcessAfterInstantiation方法，在目标bean实例化后，但是没有进行属性填充前执行的方法。</li><li>postProcessPropertyValues方法，在将给定属性值设置到到给定的bean后，对其进行后处理。 允许检查所有的依赖关系是否被满足，例如基于bean属性设置器上的“Required”注解。还允许替换要应用的属性值，通常通过创建基于原始PropertyValues的新MutablePropertyValues实例，添加或删除特定值。</li></ul><p>接口应用</p><ul><li>spring不建议用户直接实现，如果必须在这些扩展点应用自己的回调函数，spring建议继承InstantiationAwareBeanPostProcessorAdapter，重写相应的方法即可。</li><li>org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator，基于beanName创建代理，就是应用了这个接口，在生成bean前生成代理bean，从而替代默认的实例化。</li></ul><h3 id="SmartInstantiationAwareBeanPostProcessor"><a href="#SmartInstantiationAwareBeanPostProcessor" class="headerlink" title="SmartInstantiationAwareBeanPostProcessor"></a>SmartInstantiationAwareBeanPostProcessor</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface SmartInstantiationAwareBeanPostProcessor extends InstantiationAwareBeanPostProcessor &#123;</span><br><span class="line"> </span><br><span class="line">// 预测Bean的类型，返回第一个预测成功的Class类型，如果不能预测返回null</span><br><span class="line">    Class&lt;?&gt; predictBeanType(Class&lt;?&gt; beanClass, String beanName) throws BeansException;</span><br><span class="line">// 选择合适的构造器，比如目标对象有多个构造器，在这里可以进行一些定制化，选择合适的构造器</span><br><span class="line">// beanClass参数表示目标实例的类型，beanName是目标实例在Spring容器中的name</span><br><span class="line">// 返回值是个构造器数组，如果返回null，会执行下一个PostProcessor的determineCandidateConstructors方法；否则选取该PostProcessor选择的构造器</span><br><span class="line">    Constructor&lt;?&gt;[] determineCandidateConstructors(Class&lt;?&gt; beanClass, String beanName) throws BeansException;</span><br><span class="line">// 获得提前暴露的bean引用。主要用于解决循环引用的问题</span><br><span class="line">// 只有单例对象才会调用此方法</span><br><span class="line">    Object getEarlyBeanReference(Object bean, String beanName) throws BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getEarlyBeanReference调用时机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) &#123;</span><br><span class="line">        Object exposedObject = bean;</span><br><span class="line">        if (bean != null &amp;&amp; !mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">            for (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">                if (bp instanceof SmartInstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                    SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                    exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">                    if (exposedObject == null) &#123;</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return exposedObject;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>determineCandidateConstructors调用时机</p><p>检测Bean的构造器，可以检测出多个候选构造器，再有相应的策略决定使用哪一个，如AutowiredAnnotationBeanPostProcessor实现将自动扫描通过@Autowired/@Value注解的构造器从而可以完成构造器注入</p><h3 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h3><p>BeanPostProcessor允许对bean的实例进行个些自定义的个性，比如检查标记接口、使用代理包装bean实例。spring可以自动检测容器中定义的 BeanPostProcessor，后续创建的bean便会被该BeanPostProcessor处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanPostProcessor &#123;</span><br><span class="line"></span><br><span class="line">    // 初始化之后被调用，已完成注入，但是尚未执行 InitializingBean#afterPropertiesSet() 方法，或者自定义的 init 方法</span><br><span class="line">    Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;</span><br><span class="line"></span><br><span class="line">    // 初始化之后被调用</span><br><span class="line">    Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用：</p><ul><li>注解注入、AOP <ul><li>AnnotationAwareAspectJAutoProxyCreator 在bean的实例化、或者初始化之后创建代理，从而实现 aop 功能。</li><li>spring 根据 BeanDefinition 对bean进行实例化之后，会遍历容器内部注册的 InstantiationAwareBeanPostProcessor(BeanPostProcessor的子类)进行属性填充。</li><li>AutowiredAnnotationBeanPostProcessor，它会处理 @Autowired、@Value 注解，从而完成注入的功能</li><li>CommonAnnotationBeanPostProcessor 也是如此，只是处理不同的注解而已</li><li>注解注入的检查机制RequiredAnnotationBeanPostProcessor，执行的优先级较低(通过 Ordered 控制)</li><li>ApplicationContextAwareProcessor</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class AspectJAutoProxyBeanDefinitionParser implements BeanDefinitionParser &#123;</span><br><span class="line"> @Override</span><br><span class="line"> public BeanDefinition parse(Element element, ParserContext parserContext) &#123;</span><br><span class="line">    //注册特殊的bean</span><br><span class="line">  AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);</span><br><span class="line">  extendBeanDefinition(element, parserContext);</span><br><span class="line">  return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AnnotationAwareAspectJAutoProxyCreator extends AspectJAwareAdvisorAutoProxyCreator &#123;</span><br><span class="line">  public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">        if (bean != null) &#123;</span><br><span class="line">          Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">          if (!this.earlyProxyReferences.containsKey(cacheKey)) &#123;</span><br><span class="line">            //如果该类需要被代理，返回动态代理对象；反之，返回原对象</span><br><span class="line">            return wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return bean;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class ApplicationContextAwareProcessor implements BeanPostProcessor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object postProcessBeforeInitialization(final Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">        // 省略 AccessControlContext 处理的代码</span><br><span class="line">        invokeAwareInterfaces(bean);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void invokeAwareInterfaces(Object bean) &#123;</span><br><span class="line">        if (bean instanceof Aware) &#123;</span><br><span class="line">            if (bean instanceof ApplicationEventPublisherAware) &#123;</span><br><span class="line">                ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);</span><br><span class="line">            &#125;</span><br><span class="line">            // 省略部分代码……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">以@Resource为例，看看这个特殊的bean做了什么</span><br><span class="line"></span><br><span class="line">public class CommonAnnotationBeanPostProcessor extends InitDestroyAnnotationBeanPostProcessor</span><br><span class="line">  implements InstantiationAwareBeanPostProcessor, BeanFactoryAware, Serializable &#123;</span><br><span class="line">     </span><br><span class="line">      public PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, </span><br><span class="line">      Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">          InjectionMetadata metadata = findResourceMetadata(beanName, bean.getClass());</span><br><span class="line">          try &#123;</span><br><span class="line">            //属性注入</span><br><span class="line">            metadata.inject(bean, beanName, pvs);</span><br><span class="line">          &#125;</span><br><span class="line">          catch (Throwable ex) &#123;</span><br><span class="line">            throw new BeanCreationException(beanName, &quot;Injection of resource dependencies failed&quot;, ex);</span><br><span class="line">          &#125;</span><br><span class="line">          return pvs;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="invokeAware"><a href="#invokeAware" class="headerlink" title="invokeAware"></a>invokeAware</h3><p>实现BeanFactoryAware接口的类，会由容器执行setBeanFactory方法将当前的容器BeanFactory注入到类中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">class BeanFactoryHolder implements BeanFactoryAware&#123;</span><br><span class="line">   </span><br><span class="line">    private static BeanFactory beanFactory;</span><br><span class="line">    </span><br><span class="line">    public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">        this.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="afterPropertySet-和init-method"><a href="#afterPropertySet-和init-method" class="headerlink" title="afterPropertySet()和init-method"></a>afterPropertySet()和init-method</h3><p>目前很多Java中间件都是基本Spring Framework搭建的，而这些中间件经常把入口放到afterPropertySet或者自定义的init中</p><h3 id="destroy-和destroy-method"><a href="#destroy-和destroy-method" class="headerlink" title="destroy()和destroy-method"></a>destroy()和destroy-method</h3><p>bean生命周期的最后一个扩展点，该方法用于执行一些bean销毁前的准备工作，比如将当前bean持有的一些资源释放掉</p><h3 id="ApplicationListener"><a href="#ApplicationListener" class="headerlink" title="ApplicationListener"></a>ApplicationListener</h3><p>用于接收spring的事件通知，比如常用的ContextRefreshedEvent事件，spring 在成功完成refresh动作之后便会发出该事件，代表spring容器已经完成初始化了，可以做一些额外的处理了，比如开启 spring 定时任务、拉取 MQ 消息，等等。<br>spring 处理 @Scheduled 注解的部分实现，在收到 Refresh 事件之后对 ScheduledTaskRegistrar 进行额外的设置，并开启定时任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ScheduledAnnotationBeanPostProcessor</span><br><span class="line">        implements MergedBeanDefinitionPostProcessor, DestructionAwareBeanPostProcessor,</span><br><span class="line">        Ordered, EmbeddedValueResolverAware, BeanNameAware, BeanFactoryAware, ApplicationContextAware,</span><br><span class="line">        SmartInitializingSingleton, ApplicationListener&lt;ContextRefreshedEvent&gt;, DisposableBean &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onApplicationEvent(ContextRefreshedEvent event) &#123;</span><br><span class="line">        if (event.getApplicationContext() == this.applicationContext) &#123;</span><br><span class="line">            finishRegistration();   // 对 ScheduledTaskRegistrar 进行额外的设置，并开启定时任务</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 其它代码......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FactoryBean-扩展点"><a href="#FactoryBean-扩展点" class="headerlink" title="FactoryBean 扩展点"></a>FactoryBean 扩展点</h3><p>FactoryBean主要用来定制化Bean的创建逻辑。</p><p>FactoryBean 接口提供了三个方法：</p><ul><li>Object getObject()：返回这个 FactoryBean 所创建的对象。</li><li>boolean isSingleton()：返回 FactoryBean 所创建的对象是否为单例，默认返回 true。</li><li>Class getObjectType()：返回这个 FactoryBean 所创建的对象的类型，如果我们能确认返回对象的类型的话，我们应该正常对这个方法做出实现，而不是返回 null。</li></ul><p>假设定义了一个FactoryBean，名为MyFactoryBean，当我们调用 getBean(“MyFactoryBean”)方法时返回的并不是这个FactoryBean，而是这个FactoryBean所创建的 Bean，如果我们想获取到这个FactoryBean 需要在名字前面拼接”&amp;”，例如这种形式：getBean(“&amp;MyFactoryBean”)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">public static boolean isFactoryDereference(@Nullable String name) &#123;</span><br><span class="line">    return name != null &amp;&amp; name.startsWith(&quot;&amp;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected Object getObjectForBeanInstance(Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) &#123;</span><br><span class="line">    //判断beanName是不是&amp;开头</span><br><span class="line">    if (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">        if (beanInstance instanceof NullBean) &#123;</span><br><span class="line">            return beanInstance;</span><br><span class="line">        &#125; else if (!(beanInstance instanceof FactoryBean)) &#123;</span><br><span class="line">            throw new BeanIsNotAFactoryException(beanName, beanInstance.getClass());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (mbd != null) &#123;</span><br><span class="line">                mbd.isFactoryBean = true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return beanInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;//判断beanInstance 不是factory bean的子类直接返回 </span><br><span class="line">    else if (!(beanInstance instanceof FactoryBean)) &#123;</span><br><span class="line">        return beanInstance;</span><br><span class="line">    &#125; </span><br><span class="line">    // beanname非&amp;开头，且factory bean的子类</span><br><span class="line">    else &#123;</span><br><span class="line">        Object object = null;</span><br><span class="line">        if (mbd != null) &#123;</span><br><span class="line">            mbd.isFactoryBean = true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //从缓存里取对象</span><br><span class="line">            object = this.getCachedObjectForFactoryBean(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        //缓存没有取到</span><br><span class="line">        if (object == null) &#123;</span><br><span class="line">            FactoryBean&lt;?&gt; factory = (FactoryBean)beanInstance;</span><br><span class="line">            if (mbd == null &amp;&amp; this.containsBeanDefinition(beanName)) &#123;</span><br><span class="line">                mbd = this.getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            boolean synthetic = mbd != null &amp;&amp; mbd.isSynthetic();</span><br><span class="line">            //调用factorybean getobject方法</span><br><span class="line">            object = this.getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">protected Object getObjectFromFactoryBean(FactoryBean&lt;?&gt; factory, String beanName, boolean shouldPostProcess) &#123;</span><br><span class="line">        if (factory.isSingleton() &amp;&amp; this.containsSingleton(beanName)) &#123;</span><br><span class="line">            synchronized(this.getSingletonMutex()) &#123;</span><br><span class="line">                Object object = this.factoryBeanObjectCache.get(beanName);</span><br><span class="line">                if (object == null) &#123;</span><br><span class="line">                    //调用factorybean getobject方法</span><br><span class="line">                    object = this.doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">                    Object alreadyThere = this.factoryBeanObjectCache.get(beanName);</span><br><span class="line">                </span><br><span class="line">                if (alreadyThere != null) &#123;</span><br><span class="line">                        object = alreadyThere;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        if (shouldPostProcess) &#123;</span><br><span class="line">                            if (this.isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">                                return object;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            this.beforeSingletonCreation(beanName);</span><br><span class="line"></span><br><span class="line">                            try &#123;</span><br><span class="line">                                object = this.postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">                            &#125; catch (Throwable var14) &#123;</span><br><span class="line">                                throw new BeanCreationException(beanName, &quot;Post-processing of FactoryBean&#x27;s singleton object failed&quot;, var14);</span><br><span class="line">                            &#125; finally &#123;</span><br><span class="line">                                this.afterSingletonCreation(beanName);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        //判断是否单例，存缓存里</span><br><span class="line">                        if (this.containsSingleton(beanName)) &#123;</span><br><span class="line">                            this.factoryBeanObjectCache.put(beanName, object);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="扩展点之间的调用顺序"><a href="#扩展点之间的调用顺序" class="headerlink" title="扩展点之间的调用顺序"></a>扩展点之间的调用顺序</h3><p><img src="/2022/03/31/spring/a.png" alt="a"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring&quot;&gt;&lt;a href=&quot;#Spring&quot; class=&quot;headerlink&quot; title=&quot;Spring&quot;&gt;&lt;/a&gt;Spring&lt;/h1&gt;&lt;h2 id=&quot;注册组件方法&quot;&gt;&lt;a href=&quot;#注册组件方法&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="Spring" scheme="https://blog.imder.top/categories/Spring/"/>
    
    
    <category term="JAVA" scheme="https://blog.imder.top/tags/JAVA/"/>
    
    <category term="Spring" scheme="https://blog.imder.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>redis</title>
    <link href="https://blog.imder.top/2022/03/31/redis/"/>
    <id>https://blog.imder.top/2022/03/31/redis/</id>
    <published>2022-03-31T09:10:00.000Z</published>
    <updated>2024-03-28T16:43:20.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><h2 id="aof重写"><a href="#aof重写" class="headerlink" title="aof重写"></a>aof重写</h2><h3 id="aof重写原因"><a href="#aof重写原因" class="headerlink" title="aof重写原因"></a>aof重写原因</h3><ul><li>AOF 持久化是通过保存被执行的写命令来记录数据库状态的，所以AOF文件的大小随着时间的流逝一定会越来越大；影响包括但不限于：对于Redis服务器，计算机的存储压力；AOF还原出数据库状态的时间增加；</li><li>为了解决AOF文件体积膨胀的问题，Redis提供了AOF重写功能：Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个文件所保存的数据库状态是相同的，但是新的AOF文件不会包含任何浪费空间的冗余命令，通常体积会较旧AOF文件小很多。</li></ul><h3 id="AOF重写功能的实现原理"><a href="#AOF重写功能的实现原理" class="headerlink" title="AOF重写功能的实现原理"></a>AOF重写功能的实现原理</h3><p>AOF重写功能的实现原理：从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录该键值对的多个命令;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">def AOF_REWRITE(tmp_tile_name):</span><br><span class="line"></span><br><span class="line">  f = create(tmp_tile_name)</span><br><span class="line"></span><br><span class="line">  # 遍历所有数据库</span><br><span class="line">  for db in redisServer.db:</span><br><span class="line"></span><br><span class="line">    # 如果数据库为空，那么跳过这个数据库</span><br><span class="line">    if db.is_empty(): continue</span><br><span class="line"></span><br><span class="line">    # 写入 SELECT 命令，用于切换数据库</span><br><span class="line">    f.write_command(&quot;SELECT &quot; + db.number)</span><br><span class="line"></span><br><span class="line">    # 遍历所有键</span><br><span class="line">    for key in db:</span><br><span class="line"></span><br><span class="line">      # 如果键带有过期时间，并且已经过期，那么跳过这个键</span><br><span class="line">      if key.have_expire_time() and key.is_expired(): continue</span><br><span class="line"></span><br><span class="line">      if key.type == String:</span><br><span class="line"></span><br><span class="line">        # 用 SET key value 命令来保存字符串键</span><br><span class="line"></span><br><span class="line">        value = get_value_from_string(key)</span><br><span class="line"></span><br><span class="line">        f.write_command(&quot;SET &quot; + key + value)</span><br><span class="line"></span><br><span class="line">      elif key.type == List:</span><br><span class="line"></span><br><span class="line">        # 用 RPUSH key item1 item2 ... itemN 命令来保存列表键</span><br><span class="line"></span><br><span class="line">        item1, item2, ..., itemN = get_item_from_list(key)</span><br><span class="line"></span><br><span class="line">        f.write_command(&quot;RPUSH &quot; + key + item1 + item2 + ... + itemN)</span><br><span class="line"></span><br><span class="line">      elif key.type == Set:</span><br><span class="line"></span><br><span class="line">        # 用 SADD key member1 member2 ... memberN 命令来保存集合键</span><br><span class="line"></span><br><span class="line">        member1, member2, ..., memberN = get_member_from_set(key)</span><br><span class="line"></span><br><span class="line">        f.write_command(&quot;SADD &quot; + key + member1 + member2 + ... + memberN)</span><br><span class="line"></span><br><span class="line">      elif key.type == Hash:</span><br><span class="line"></span><br><span class="line">        # 用 HMSET key field1 value1 field2 value2 ... fieldN valueN 命令来保存哈希键</span><br><span class="line"></span><br><span class="line">        field1, value1, field2, value2, ..., fieldN, valueN =\</span><br><span class="line">        get_field_and_value_from_hash(key)</span><br><span class="line"></span><br><span class="line">        f.write_command(&quot;HMSET &quot; + key + field1 + value1 + field2 + value2 +\</span><br><span class="line">                        ... + fieldN + valueN)</span><br><span class="line"></span><br><span class="line">      elif key.type == SortedSet:</span><br><span class="line"></span><br><span class="line">        # 用 ZADD key score1 member1 score2 member2 ... scoreN memberN</span><br><span class="line">        # 命令来保存有序集键</span><br><span class="line"></span><br><span class="line">        score1, member1, score2, member2, ..., scoreN, memberN = \</span><br><span class="line">        get_score_and_member_from_sorted_set(key)</span><br><span class="line"></span><br><span class="line">        f.write_command(&quot;ZADD &quot; + key + score1 + member1 + score2 + member2 +\</span><br><span class="line">                        ... + scoreN + memberN)</span><br><span class="line"></span><br><span class="line">      else:</span><br><span class="line"></span><br><span class="line">        raise_type_error()</span><br><span class="line"></span><br><span class="line">      # 如果键带有过期时间，那么用 EXPIREAT key time 命令来保存键的过期时间</span><br><span class="line">      if key.have_expire_time():</span><br><span class="line">        f.write_command(&quot;EXPIREAT &quot; + key + key.expire_time_in_unix_timestamp())</span><br><span class="line"></span><br><span class="line">    # 关闭文件</span><br><span class="line">    f.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="aof子线程重写"><a href="#aof子线程重写" class="headerlink" title="aof子线程重写"></a>aof子线程重写</h3><ul><li><p>aof子线程重写原因</p><ul><li>aof_rewrite函数创建新文件并进行大量写入操作，调用这个函数的线程将被长时间的阻塞</li><li>Redis服务器使用单线程来处理命令请求，如果直接是服务器进程调用AOF_REWRITE函数的话，重写AOF期间，服务器将无法处理客户端发送来的命令请求</li><li>Redis不希望AOF重写会造成服务器无法处理请求，所以Redis决定将AOF重写程序放到子进程（后台）里执行。</li></ul></li><li><p>使用子进程进行AOF重写的问题</p><ul><li>子进程在进行AOF重写期间，服务器进程还要继续处理命令请求，而新的命令可能对现有的数据进行修改，这会让当前数据库的数据和重写后的AOF文件中的数据不一致。</li></ul></li><li><p>解决数据不一致问题</p><ul><li>Redis增加了一个AOF重写缓存，这个缓存在fork出子进程之后开始启用</li><li>Redis服务器主进程在执行完写命令之后，会同时将这个写命令追加到AOF缓冲区和AOF重写缓冲区</li><li>当子进程完成对AOF文件重写之后，会向父进程发送一个完成信号，父进程接到该完成信号之后，会调用一个信号处理函数<ul><li>将AOF重写缓存中的内容全部写入到新的AOF文件中；这个时候新的AOF文件所保存的数据库状态和服务器当前的数据库状态一致；</li><li>新的AOF文件进行改名，原子的覆盖原有的AOF文件；完成新旧两个AOF文件的替换。</li></ul></li></ul></li></ul><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h3><ul><li>从服务器连接主服务器，发送SYNC命令； </li><li>主服务器接收到SYNC命名后，开始执行BGSAVE命令子线程生成RDB文件并使用缓冲区记录此后执行的所有写命令； </li><li>主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令； </li><li>从服务器收到快照文件后丢弃所有旧数据，载入收到的快照； </li><li>主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令； </li><li>从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令； </li></ul><h3 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h3><ul><li>Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。 </li><li>增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令</li></ul><h3 id="Redis主从同步策略"><a href="#Redis主从同步策略" class="headerlink" title="Redis主从同步策略"></a>Redis主从同步策略</h3><p>主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</p><h3 id="主从同步存在的问题"><a href="#主从同步存在的问题" class="headerlink" title="主从同步存在的问题"></a>主从同步存在的问题</h3><ul><li>数据不一致，网络传输延迟，读数据读取从库</li><li>读取过期时间的key,从库读取,3.2之前的不检查过期, 会返回数据, 3.2之后虽然不删除过期数据, 但是返回空值</li></ul><h2 id="主从切换"><a href="#主从切换" class="headerlink" title="主从切换"></a>主从切换</h2><h3 id="切换方式"><a href="#切换方式" class="headerlink" title="切换方式"></a>切换方式</h3><ul><li>手动切换<ul><li>手动将从节点设置成主节点。命令：redis-cli -h &lt;从节点ip&gt; -p &lt;从节点端口号&gt; slaveof no one</li></ul></li><li>哨兵模式<ul><li>Sentinel实例可以自动的将主节点下的其中一个从节点升级为新的主节点</li><li>Sentinel实例会不断检测主从节点是否正常运</li><li>当某个节点出现异常宕机时，Sentinel实例会向管理员或者其他应用发送提醒</li><li>当主节点宕机时，Sentinel实例会将该主节点下的其中一个从节点升级为新的主节点，并且原先其他从节点重新发起socket请求成为新的主节点的从节点</li><li>向客户端返回新主节点的地址，就可以正常上使用新的主节点来处理请求</li></ul></li></ul><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>只开启一个Sentinel实例进行监视，容易出现问题，一般情况下会开启多个Sentinel实例进行监控，一般情况下至少需要3个Sentinel实例。<br>主节点宕机状态<br>    - 只有一个哨兵认为这个主节点宕机了，则成为主观宕机。<br>    - 如果达到一定数量的节点认为该主节点宕机，则成为客观宕机。</p><p>为什么至少需要3个Sentinel实例？</p><ul><li>当指定时间内一定哨兵数量（哨兵数量 / 2 + 1）都认为主节点宕机则称为客观宕机，如果数量为2，出现一个哨兵宕机的情况，在需要主从切换的时候因为无法达到认为主节点宕机的哨兵数量为2，所以在主节点出现宕机时无法进行主从切换。所以说部署哨兵至少需要3个Sentinel实例来保证健壮性。</li></ul><h3 id="哨兵模式引发数据丢失问题"><a href="#哨兵模式引发数据丢失问题" class="headerlink" title="哨兵模式引发数据丢失问题"></a>哨兵模式引发数据丢失问题</h3><p>哨兵模式 + Redis主从复制这种部署结构，无法保证数据不会出现丢失。<br>哨兵模式下数据丢失主要有两种情况：<br>因为主从复制是异步操作，可能主从复制还没成功，主节点宕机了。这时候还没成功复制的数据就会丢失了。<br>如果主节点无法与其他从节点连接，但是实际上还在运行。这时候哨兵会将一个从节点切换成新的主节点，但是在这个过程中实际上主节点还在运行，所以继续向这个主节点写入的数据会被丢失。</p><h3 id="解决数据丢失方案"><a href="#解决数据丢失方案" class="headerlink" title="解决数据丢失方案"></a>解决数据丢失方案</h3><p>使用命令：<br>min-slaves-to-write 1<br>min-slaves-max-lag 10<br>使用这组命令可以设置至少有一个从节点数据复制延迟不能超过10S，也就是说如果一个直接点下所有从节点数据复制延迟都超过10S，则停止主节点继续接收处理新的请求。这样可以保证数据丢失最多只会丢失10S内的数据。</p><h2 id="redis-持久化方案"><a href="#redis-持久化方案" class="headerlink" title="redis 持久化方案"></a>redis 持久化方案</h2><p>数据库的恢复<br>服务器启动时，如果没有开启AOF持久化功能，则会自动载入RDB文件，期间会阻塞主进程。如果开启了AOF持久化功能，服务器则会优先使用AOF文件来还原数据库状态，因为AOF文件的更新频率通常比RDB文件的更新频率高，保存的数据更完整。</p><h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><ul><li>RDB持久化即通过创建快照（压缩的二进制文件）的方式进行持久化，保存某个时间点的全量数据。RDB持久化是Redis默认的持久化方式。</li><li>触发方式<ul><li>手动触发<ul><li>save， 在命令行执行save命令，将以同步的方式创建rdb文件保存快照，会阻塞服务器的主进程，生产环境中不要用    </li><li>bgsave, 在命令行执行bgsave命令，将通过fork一个子进程以异步的方式创建rdb文件保存快照，除了fork时有阻塞，子进程在创建rdb文件时，主进程可继续处理请求</li></ul></li><li>自动触发<ul><li>在redis.conf中配置 save m n 定时触发，如 save 900 1表示在900s内至少存在一次更新就触发</li><li>主从复制时，如果从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从节点</li><li>执行debug reload命令重新加载Redis时</li><li>执行shutdown且没有开启AOF持久化</li><li>redis.conf中RDB持久化配置<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 只要满足下列条件之一，则会执行bgsave命令</span><br><span class="line">save 900 1 # 在900s内存在至少一次写操作</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"># 禁用RBD持久化，可在最后加 save &quot;&quot;</span><br><span class="line"></span><br><span class="line"># 当备份进程出错时主进程是否停止写入操作</span><br><span class="line">stop-writes-on-bgsave-error yes  </span><br><span class="line"># 是否压缩rdb文件 推荐no 相对于硬盘成本cpu资源更贵</span><br><span class="line">rdbcompression no</span><br></pre></td></tr></table></figure><h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3>AOF（Append-Only-File）持久化即记录所有变更数据库状态的指令，以append的形式追加保存到AOF文件中。在服务器下次启动时，通过载入和执行AOF文件中保存的命令，来还原服务器关闭前的数据库状态。</li></ul></li></ul></li></ul><p>redis.conf中AOF持久化配置如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 默认关闭AOF，若要开启将no改为yes</span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"># append文件的名字</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"># 每隔一秒将缓存区内容写入文件 默认开启的写入方式</span><br><span class="line">appendfsync everysec </span><br><span class="line"></span><br><span class="line"># 当AOF文件大小的增长率大于该配置项时自动开启重写（这里指超过原大小的100%）。</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"></span><br><span class="line"># 当AOF文件大小大于该配置项时自动开启重写</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>AOF持久化的实现包括3个步骤:</p><p>命令追加：将命令追加到AOF缓冲区<br>文件写入：缓冲区内容写到AOF文件<br>文件保存：AOF文件保存到磁盘<br>其中后两步的频率通过appendf sync来配置，appendfsync的选项包括</p><p>always， 每执行一个命令就保存一次，安全性最高，最多只丢失一个命令的数据，但是性能也最低（频繁的磁盘IO）<br>everysec，每一秒保存一次，推荐使用，在安全性与性能之间折中，最多丢失一秒的数据<br>no， 依赖操作系统来执行（一般大概30s一次的样子），安全性最低，性能最高，丢失操作系统最后一次对AOF文件触发SAVE操作之后的数据</p><h3 id="RDB-vs-AOF"><a href="#RDB-vs-AOF" class="headerlink" title="RDB vs AOF"></a>RDB vs AOF</h3><p>RDB与AOF两种方式各有优缺点。</p><p>RDB的优点：与AOF相比，RDB文件相对较小，恢复数据比较快（原因见数据恢复部分）<br>RDB的缺点：服务器宕机，RBD方式会丢失掉上一次RDB持久化后的数据；使用bgsave fork子进程时会耗费内存。</p><p>AOF的优点： AOF只是追加文件，对服务器性能影响较小，速度比RDB快，消耗内存也少，同时可读性高。<br>AOF的缺点：生成的文件相对较大，即使通过AOF重写，仍然会比较大；恢复数据的速度比RDB慢。</p><h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><p><img src="/2022/03/31/redis/qidong.png" alt="qidong.png"></p><h3 id="RDB、AOF混合持久化"><a href="#RDB、AOF混合持久化" class="headerlink" title="RDB、AOF混合持久化"></a>RDB、AOF混合持久化</h3><p>Redis从4.0版开始支持RDB与AOF的混合持久化方案。首先由RDB定期完成内存快照的备份，然后再由AOF完成两次RDB之间的数据备份，由这两部分共同构成持久化文件。该方案的优点是充分利用了RDB加载快、备份文件小及AOF尽可能不丢数据的特性。缺点是兼容性差，一旦开启了混合持久化，在4.0之前的版本都不识别该持久化文件，同时由于前部分是RDB格式，阅读性较低。</p><ul><li>开启混合持久化 aof-use-rdb-preamble yes</li><li>数据恢复加载过程就是先按照RDB进行加载，然后把AOF命令追加写入。</li></ul><h3 id="持久化方案的建议"><a href="#持久化方案的建议" class="headerlink" title="持久化方案的建议"></a>持久化方案的建议</h3><p>Redis只用来做缓存服务器，比如数据库查询数据后缓存，可以不用考虑持久化，因为缓存服务失效还能再从数据库获取恢复。<br>提供很高的数据保障性，建议你同时使用两种持久化方式。如果可以接受灾难带来的几分钟的数据丢失，那么可以仅使用RDB。<br>通常的设计思路是利用主从复制机制来弥补持久化时性能上的影响。即Master上RDB、AOF都不做，保证Master的读写性能，而Slave上则同时开启RDB和AOF（或4.0以上版本的混合持久化方式）来进行持久化，保证数据的安全性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;redis&quot;&gt;&lt;a href=&quot;#redis&quot; class=&quot;headerlink&quot; title=&quot;redis&quot;&gt;&lt;/a&gt;redis&lt;/h1&gt;&lt;h2 id=&quot;aof重写&quot;&gt;&lt;a href=&quot;#aof重写&quot; class=&quot;headerlink&quot; title=&quot;aof</summary>
      
    
    
    
    <category term="redis" scheme="https://blog.imder.top/categories/redis/"/>
    
    
    <category term="redis" scheme="https://blog.imder.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>jm调优</title>
    <link href="https://blog.imder.top/2022/03/08/%08JM%E8%B0%83%E4%BC%98/"/>
    <id>https://blog.imder.top/2022/03/08/%08JM%E8%B0%83%E4%BC%98/</id>
    <published>2022-03-08T09:00:00.000Z</published>
    <updated>2024-03-28T16:43:20.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jm调优"><a href="#jm调优" class="headerlink" title="jm调优"></a>jm调优</h1><h2 id="遇到了什么问题需要调优？"><a href="#遇到了什么问题需要调优？" class="headerlink" title="遇到了什么问题需要调优？"></a>遇到了什么问题需要调优？</h2><p>生产环境新上线了一个系统，莫名其妙奔溃，错误日志报异常OOM</p><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 -&gt; 使用 -&gt; 卸载</p><h3 id="什么情况下会去加载一个类呢"><a href="#什么情况下会去加载一个类呢" class="headerlink" title="什么情况下会去加载一个类呢?"></a>什么情况下会去加载一个类呢?</h3><p>何时将“.class”字节码文件中加载这个类到JVM内存里来，代码中用到这个类的时候。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>来校验加载进来的“.class”文件中的内容，是否符合指定的jvm规范。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>类的类变量(static修饰的变量)分配内存空间，来一个默认的初始值，并非执行赋值</p><h3 id="解析阶段"><a href="#解析阶段" class="headerlink" title="解析阶段"></a>解析阶段</h3><p>符号引用替换为直接引用</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>执行类变量的赋值语句，执行静态代码块</p><h2 id="类加载器和双亲委派机制"><a href="#类加载器和双亲委派机制" class="headerlink" title="类加载器和双亲委派机制"></a>类加载器和双亲委派机制</h2><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul><li>启动类加载器<br>Bootstrap ClassLoader，负责加载Java安装目录下的“lib”目录中的核心类库</li><li>扩展类加载器<br>Extension ClassLoader，负责加载Java安装目录“lib\ext”目录里面有一些类</li><li>应用程序类加载器<br>Application ClassLoader，负责去加载“ClassPath”环境变量所指定的路径中的类 理解为去加载自己写好的Java代码</li><li>自定义类加载器 除了上面那几种之外，还可以自定义类加载器，去根据自己的需求加载自己的类。<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3></li><li>JVM的类加载器是有亲子层级结构的，启动类加载器是最上层的，扩展类加载器在第二层，第三层是应用程序类加载器，最后一层是自定义类加载器。</li><li>双亲委派模型:先找父亲去加载，不行的话再由自己来加载。</li></ul><h2 id="内存划分"><a href="#内存划分" class="headerlink" title="内存划分"></a>内存划分</h2><h3 id="方法区（1-8之前）-元空间"><a href="#方法区（1-8之前）-元空间" class="headerlink" title="方法区（1.8之前） 元空间"></a>方法区（1.8之前） 元空间</h3><p>将“.class”文件里加载进来的类</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>写好的Java代码会被翻译成字节码，对应各种字节码指令，JVM加载类信息到内存之后，会使用自己的字节码执行引擎执行字节码指令，执行时，JVM里就需要一个特殊的内存区域，那就是“程序计数器”，这个程序计数器就是用来记录当前执行的字节码指令的位置的</p><h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><ul><li>JVM必须有一块区域是来保存每个方法内的局部变量等数据的，这个区域就是Java虚拟机栈 </li><li>每个线程都有自己的Java虚拟机栈</li><li>如果线程执行了一个方法，就会对这个方法调用创建对应的一个栈帧，栈帧里就有这个方法的局部变量表 、操作数栈、动态链接、方法出口</li></ul><h3 id="Java堆内存"><a href="#Java堆内存" class="headerlink" title="Java堆内存"></a>Java堆内存</h3><p>存放代码中创建的各种对象的</p><h2 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h2><h3 id="jvm参数"><a href="#jvm参数" class="headerlink" title="jvm参数"></a>jvm参数</h3><ul><li>-Xms:Java堆内存的大小 、-Xmx:Java堆内存的最大大小 </li><li>-Xms和-Xmx，分别用于设置Java堆内存的刚开始的大小，以及允许扩张到的最大大小。</li><li>-Xmn:Java堆内存中的新生代大小，扣除新生代剩下的就是老年代的内存大小,默认不设置新生代大小时，大概老年代占2/3，新生代占1/3，eden和2个survivor 8:1:1  jvm参数”- XX:SurvivorRatio=8”</li><li>-XX:PermSize:永久代大小、-XX:MaxPermSize:永久代最大大小</li><li>jdk1.8 用这两个-XX:MetaspaceSize和-XX:MaxMetaspaceSize替换永久代大小</li><li>-Xss:每个线程的栈内存大小</li></ul><h3 id="如何合理设置永久代大小"><a href="#如何合理设置永久代大小" class="headerlink" title="如何合理设置永久代大小?"></a>如何合理设置永久代大小?</h3><p>一般你设置个几百MB，大体上都是够用的 因为里面主要就是存放一些类的信息</p><h3 id="如何合理设置栈内存大小"><a href="#如何合理设置栈内存大小" class="headerlink" title="如何合理设置栈内存大小"></a>如何合理设置栈内存大小</h3><p>一般默认就是比如512KB到1MB</p><h3 id="如何确定对象是垃圾？可达性分析算法GCRoot根由那些对象组成？"><a href="#如何确定对象是垃圾？可达性分析算法GCRoot根由那些对象组成？" class="headerlink" title="如何确定对象是垃圾？可达性分析算法GCRoot根由那些对象组成？"></a>如何确定对象是垃圾？可达性分析算法GCRoot根由那些对象组成？</h3><p>对象无引用时会被确定为垃圾对象，方法的局部变量、类的静态变量都被看为GCRoot根</p><h3 id="垃圾对象一定会被回收吗？"><a href="#垃圾对象一定会被回收吗？" class="headerlink" title="垃圾对象一定会被回收吗？"></a>垃圾对象一定会被回收吗？</h3><p>不一定，如果对象重写了Object类中的finialize()方法，并且在该方法建立起与静态变量的引用关系就可以不被回收</p><h3 id="强引用、软引用、弱引用、虚引用"><a href="#强引用、软引用、弱引用、虚引用" class="headerlink" title="强引用、软引用、弱引用、虚引用"></a>强引用、软引用、弱引用、虚引用</h3><p>强引用：绝对不能回收的对象<br>软引用：有的对象可有可无，如果内存实在不够了，可以回收他。<br>弱引用：与没引用是类似的，如果发生垃圾回收，就会把这个对象回收掉<br>虚引用：暂时忽略，很少用。</p><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>复制算法：内存区域划分为两块，对象就就会分配在其中一块内存空间，垃圾回收时，存活对象复制到另一块内存空间，同时原分配对象空间清除所有对象<br>缺点：内存使用率太低 优点：不会产生内存碎片，不浪费内存空间</p><p>复制算法做出如下优化：</p><ul><li>把新生代内存区域划分为三块:1个Eden区，2个Survivor区，其中Eden区占80%内存空间，每一块Survivor区各占10%内存空间</li><li>刚开始对象都是分配在Eden区内的，如果Eden区快满了，此时就会触发垃圾回收，把Eden区中的存活对象都一次性转移到一块空着的Survivor区，接着Eden区就会被清空</li><li>然后再次分配新对象到Eden区里，此时，Eden区和一块Survivor区里是有对象的，其中Survivor区里放的是上一次Minor GC后存活的对象。如果下次再次Eden区满，那么再次触发Minor GC，Eden区和放着上一次Minor GC后存活对象的Survivor区内的存活对象，转移到另外一块Survivor区去。然后清空eden区和上一次的survivor区</li></ul><h3 id="对象何时从新生代转到老年代？"><a href="#对象何时从新生代转到老年代？" class="headerlink" title="对象何时从新生代转到老年代？"></a>对象何时从新生代转到老年代？</h3><ul><li>15次minor gc对象还存活。JVM参数“-XX:MaxTenuringThreshold”来设置，默认是15岁</li><li>动态对象年龄判断：假如说当前放对象的Survivor区域的一些对象大小和（按照年龄排正序）大于了这块Survivor区域的内存大小的50%，那么此时大于等于这批对象年龄的对象，就可以直接进入老年代。年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会把年龄n以上的对象都放入老年代。</li><li>大对象直接进入老年代。JVM参数，“-XX:PretenureSizeThreshold”，单位字节数，比如“1048576”字节，就是1MB。</li><li>Minor GC后的对象太多无法放入Survivor区怎么办? 这个时候就必须得把这些对象直接转移到老年代去</li><li>老年代空间分配担保机制<ul><li>在执行任何一次Minor GC之前，JVM会先检查一下老年代可用的可用内存空间，是否大于新生代所有对象的总大小。避免Minor GC后老年代空间放不下存活对象</li><li>如果老年代的内存大小是大于新生代所有对象的，此时就可以对新生代发起一次Minor GC了</li><li>如果老年代的内存大小是小于新生代所有对象的，JVM“-XX:- HandlePromotionFailure”的参数是否设置,<ul><li>未设置 发生一次Full GC（对老年代进行垃圾回收，同时一般会对新生代进行垃圾回收）</li><li>设置表示开启老年代空间担保，接着判断老年代的内存大小，是否大于之前每一次Minor GC后进入老年代的对象的平均大小，如果大于，则Minor GC,如果小于，FullGC（年轻代+老年代+永久代）</li></ul></li><li>如果要是Full GC过后，老年代还是没有足够的空间存放Minor GC过后的剩余存活对象，就会导致所谓的 “OOM”内存溢出</li></ul></li></ul><h3 id="老年代采用的什么垃圾回收算法？"><a href="#老年代采用的什么垃圾回收算法？" class="headerlink" title="老年代采用的什么垃圾回收算法？"></a>老年代采用的什么垃圾回收算法？</h3><ul><li>标记整理算法：首先标记出来老年代当前存活的对象，接着会让这些存活对象在内存里进行移动，把存活对象尽量都挪动到一边去</li><li>老年代的垃圾回收算法的速度至少比新生代的垃圾回收算法的速度慢10倍。</li><li>如果系统频繁出现老年代的Full GC垃圾回收，会导致系统性能被严重影响，出现频繁卡顿的情况。<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3></li><li>Serial和Serial Old垃圾回收器:分别用来回收新生代和老年代的垃圾对象，工作原理就是单线程运行，STW，一般几乎不用。</li><li>ParNew和CMS垃圾回收器:ParNew现在一般用在新生代的，CMS是用在老年代的，都是多线程并发的机制，性能更好，一般是生产系统的标配组合。</li><li>G1垃圾回收器:统一收集新生代和老年代，采用了更加优秀的算法和设计机制</li></ul><h3 id="stw"><a href="#stw" class="headerlink" title="stw"></a>stw</h3><p>直接停止Java系统的所有工作线程，让代码不再运行，让垃圾回收线程可以专心致志的进行垃圾回收的工作<br>    - 假设我们的Minor GC要运行100ms，那么可能就会导致系统直接停顿100ms不能处理任何请求<br>    - Full GC是最慢的，有的时候弄不好一次回收要进行几秒钟，甚至几十秒，有的极端场景几分钟都是有可能的。一旦频繁的Full GC，系统每一段时间就卡死个30秒吗?<br>    - 无论是新生代GC还是老年代GC，都尽量不要让频率过高，避免持续时间过长</p><h3 id="ParNew垃圾收集器"><a href="#ParNew垃圾收集器" class="headerlink" title="ParNew垃圾收集器"></a>ParNew垃圾收集器</h3><p>暂停系统程序的工作线程，禁止程序继续运行创建新的对象，用多个垃圾回收线程去进行垃圾回收，用复制算法回收<br>使用ParNew垃圾回收器 JVM参数 -XX:+UseParNewGC<br>ParNew垃圾回收器默认情况下的线程数量 垃圾回收线程的数量就是跟CPU的核数是一样。 JVM参数设置 - XX:ParallelGCThreads=n</p><h3 id="服务器模式与客户端模式"><a href="#服务器模式与客户端模式" class="headerlink" title="服务器模式与客户端模式"></a>服务器模式与客户端模式</h3><ul><li>启动系统的时候是可以区分服务器模式和客户端模式的，启动系统的时候加入“-server”就是服务器模式，如果加入“-cilent”就是客户端模式。</li><li>系统部署在比如4核8G的Linux服务器上那么就应该用服务器模式，如果你的系统是运行在比如Windows上的客户端程序，那么就应该是客户端模式。</li><li>服务器模式通常ParNew来进行垃圾回收，客户端模式使用采用Serial垃圾回收器，单CPU单线程垃圾回收</li></ul><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>CMS垃圾回收器采取的是垃圾回收线程和系统工作线程尽量同时执行的模式来处理的，使用标记-清理的算法<br>初始标记 ：stw 很快，仅仅标记出GC Root根<br>并发标记 ：对老年代所有对象进行GC Roots追踪，其实是最耗时的<br>重新标记 ：stw 很快,对在第二阶段中被系统程序运行变动过的少数对象进行标记<br>并发清理 ：很耗时</p><p>缺点：<br>    - 会消耗CPU资源，在并发标记时，老年代存活对象多，追踪大量对象，耗时较高，并发清理，把垃圾对象从随机的内存位置清理掉，也比较耗时，CMS的垃圾回收线程是比较耗费CPU资源的。CMS默认启动的垃圾回收线程的数量是(CPU核数 + 3)/ 4。<br>    - 会产生浮动垃圾，并发清理同时随着系统运行让一些对象进入老年代，这种垃圾需要等到下一次GC才能回收掉</p><p>-XX:CMSInitiatingOccupancyFaction 用来设置老年代占用多少时触发CMS垃圾回收，JDK 1.6里面默认的值是 92%。<br>-XX:+UseCMSCompactAtFullCollection 默认开启 Full GC之后再次进行stw，碎片整理<br>-XX:CMSFullGCsBeforeCompaction 执行多少次Full GC之后执行一次内存碎片整理，默认是0，每次Full GC之后都会进行内存整理。</p><h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><ul><li>评估Eden区进行Minor Gc 之后存活的对象大小，Suvivor区空间够不够，建议的是调整新生代和老年代的大小，让短期存活的对象在新生代就被垃圾回收</li><li>结合系统的运行模型，@Service、@Controller之类的注解那种需要长期存活的核心业务逻辑组件，降低“-XX:MaxTenuringThreshold”参数的值，避免对长期存活的对象在新生代Survivor区来回复制</li><li>大对象直接进入老年代，-XX:PretenureSizeThreshold=1M，避免对象在新生代Survivor区来回复制<br>一般启动参数：</li><li>Xms3072M -Xmx3072M -Xmn2048M -Xss1M -XX:PermSize=256M -XX:MaxPermSize=256M - XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=1M -XX:+UseParNewGC - XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFaction=92 -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=0</li></ul><h3 id="Concurrent-Mode-Failure"><a href="#Concurrent-Mode-Failure" class="headerlink" title="Concurrent Mode Failure"></a>Concurrent Mode Failure</h3><p>CMS在垃圾回收的时候，尤其是并发清理期间，系统程序是可以并发运行的，假设此时老年代空闲空间仅剩100MB，此时系统程序还在不停的创建对象，万一这个时候系统运行触发了某个条件，比如说有200MB对象要进入老年代，这个时候就会触发“Concurrent Mode Failure”问题，因为此时老年代没有足够内存来放这200MB对象，此时就会导致立马进入Stop the World，然后切换CMS为Serial Old收集器来单线程收集垃圾 </p><h3 id="G1-垃圾收集器（针对大内存机器通常建议采用G1垃圾回收器）"><a href="#G1-垃圾收集器（针对大内存机器通常建议采用G1垃圾回收器）" class="headerlink" title="G1 垃圾收集器（针对大内存机器通常建议采用G1垃圾回收器）"></a>G1 垃圾收集器（针对大内存机器通常建议采用G1垃圾回收器）</h3><ul><li>G1垃圾回收器把Java堆内存拆分为多个大小相等的Region，G1会有新生代和老年代的概念，但是只是逻辑上的概念</li><li>G1垃圾回收器可以设置一个垃圾回收的预期停顿时间</li><li>G1通过把内存拆分为大量小Region，以及追踪每个Region中可以回收的对象大小和预估时间，在垃圾回收的时候，尽量把垃圾回收对系统造成的影响控制在指定的时间范围内，同时在有限的时间内尽量回收尽可能多的垃圾对象</li><li>使用“-XX:+UseG1GC”来指定使用G1垃圾回收器，会自动用堆大小除以2048得到每个region的大小，可以使用-XX:G1HeapRegionSize指定region的大小<br>G1中新生代（Eden、Survivor）、老年代的逻辑概念，-XX:G1NewSizePercent来设置新生代初始占比的，随着对象的不停创建，属于新生代的Region会不断增加，Eden和Survivor对应的Region也会不断增加。一旦新生代达到了设定的占据堆内存的最大大小60%，会触发新生代的GC，G1就会用复制算法来进行垃圾回收，进入一个“Stop the World”状态，然后把Eden对应的Region中的存活对象放入S1对应的Region中，接着回收掉Eden对应的Region中的垃圾对象   </li><li>G1是可以设定目标GC停顿时间的，G1执行GC的时候最多可以让系统停顿多长时间，可以通过“-XX:MaxGCPauseMills”参数来设定，默认值是200ms。</li><li>年轻代何时进入老年代？跟之前几乎是一样的<ul><li>对象在新生代gc多次仍然存活 -XX:MaxTenuringThreshold</li><li>年龄为1岁，2岁，3岁，n岁的对象的大小总和超过了Survivor的50%，n+1岁进入老年代</li><li>在G1中，大对象的判定规则：一个大对象超过了一个Region大小的50%，会被放入大对象专门的Region</li></ul></li><li>G1有“-XX:InitiatingHeapOccupancyPercent”，默认值是45%：老年代占据了堆内存的45%的Region的时候，尝试触发一个新生代+老年代一起回收的混合回收阶段。</li><li>G1垃圾收集几个阶段（混合回收可以执行多次）<ul><li>初始标记 stw 标记一下GC Roots直接能引用的对象 很快</li><li>并发标记，允许系统程序的运行，同时进行GC Roots追踪，从GC Roots开始追踪所有的存活，同时记录并发标记系统运行导致哪些对象的改变</li><li>最终标记阶段，stw 对并发标记阶段记录的对象进行标记，最终标记一下有哪些存活对象，有哪些是垃圾对象</li><li>混合回收，从新生代和老年代里都回收一些Region，先停止工作，执行一次混合回收回收掉一些Region，接着恢复系统运行，然后再次停止系统运行，再执行一次混合回收回收掉一些Region。-XX:G1MixedGCCountTarget  混合回收的过程中，最后一个阶段执行几次混合 回收，默认值是8次</li></ul></li></ul><h3 id="G1调优"><a href="#G1调优" class="headerlink" title="G1调优"></a>G1调优</h3><ul><li>-Xms4096M -Xmx4096M -Xss1M -XX:PermSize=256M -XX:MaxPermSize=256M -XX:+UseG1GC</li><li>-XX:G1NewSizePercent参数是用来设置新生代初始占比的，不用设置，维持默认值为5%即可</li><li>-XX:G1MaxNewSizePercent参数是用来设置新生代最大占比的，也不用设置，维持默认值为60%即可</li><li>-XX:MaxGCPauseMills 默认值是200毫秒 垃圾回收时最大停顿时间 </li><li>G1里是很动态灵活的，根据你设定的gc停顿时间给你的新生代不停分配更多Region，到一定程度，就会触发新生代gc，保证新生代gc的时候导致的系统停顿时间在预设范围内。</li><li>新生代的GC优化：合理设置“-XX:MaxGCPauseMills”参数，设置小了，Gc频繁，设置大了，GC停顿时间长</li><li>mixed gc优化：默认老年代占据了堆内存的45%的Region的时候，发生Gc,如果-XX:MaxGCPauseMills设置过大，就会导致新生代GC后更多的对象进入老年代，加速mixed gc 发生</li></ul><h3 id="日处理上亿数据案例"><a href="#日处理上亿数据案例" class="headerlink" title="日处理上亿数据案例"></a>日处理上亿数据案例</h3><ul><li>分布式系统，4核心8G，JVM给了4G，新生代和老年代各1.5G（1.2G Eden区Survivor区150M）,每台机器每分钟计算100条数据，每秒取10000条数据，需要10秒计算完成<ul><li>预估每条数据20个字段，每个字段4B，大约1条数据100B,10000条数据1M，系统运行产生其他对象*10，10M</li><li>每次运行产生10M，一分钟产生1G，大概1分钟就要产生一次年轻代垃圾</li><li>每次年轻代垃圾回收，会有大概17～20次还在计算中，这些数据都是存活的对象，占用空间170M～200M </li><li>每次年轻代垃圾回收，Survivor区无法放入存活的对象，放老年代，在7～9次年轻代垃圾回收后，老年代就满了，触发Fullgc 耗时</li><li>将年轻代分配2G eden1.6G surviro 200m</li></ul></li></ul><h3 id="BI系统案例"><a href="#BI系统案例" class="headerlink" title="BI系统案例"></a>BI系统案例</h3><ul><li>10台机器来部署BI系统，4核8G的配置，堆内存中的新生代分配的内存都在1.5G左右，Eden区大概也就1G左右的空间，几万商家作为你的系统用户，很可能同一时间打开那个实时报表的商家就有几千个，然后每个商家打开实时报表之后，前端页面都会每隔几秒钟发送请求到后台来加载最新数据BI系统部署的每台机器每秒的请求会达到几百个，假设5000个商家同时在线，每秒刷新一次，每秒5000个请求，每台机器分摊500个请求<ul><li>预算每个请求大概需要加载出来10kb的数据进行计算，每秒需要加载出来5MB的数据到内存中进行计算</li><li>200s 就会触发年轻代GC，存活的对象估计几十m</li><li>估计50次年轻代gc 会发生老年代Gc</li></ul></li><li>每秒十万并发，那么就要部署上百台机器来，扩大机器内存，使用G1收集器，采用10台机器</li></ul><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="打印gc日志"><a href="#打印gc日志" class="headerlink" title="打印gc日志"></a>打印gc日志</h3><ul><li>-XX:+PrintGCDetils:打印详细的gc日志 </li><li>-XX:+PrintGCTimeStamps:这个参数可以打印出来每次GC发生的时间 </li><li>-Xloggc:gc.log:这个参数可以设置将gc日志写入一个磁盘文件</li></ul><h3 id="Jvm-命令"><a href="#Jvm-命令" class="headerlink" title="Jvm 命令"></a>Jvm 命令</h3><ul><li>jps 查看jvm进程ID</li><li>jstat -gc jvm进程ID 查看jvm进程内存使用情况<ul><li>S0C:From Survivor区的大小</li><li>S1C:To Survivor区的大小</li><li>S0U:From Survivor区当前使用的内存大小 </li><li>S1U:To Survivor区当前使用的内存大小 </li><li>EC:Eden区的大小</li><li>EU:Eden区当前使用的内存大小</li><li>OC:老年代的大小</li><li>OU:老年代当前使用的内存大小 </li><li>MC:方法区(永久代、元数据区)的大小 </li><li>MU:方法区(永久代、元数据区)的当前使用的内存大小 </li><li>YGC:Young GC次数 </li><li>YGCT:Young GC的耗时 </li><li>FGC:Full GC次数</li><li>FGCT:Full GC的耗时</li><li>GCT:所有GC的总耗时</li></ul></li><li>jstat -gc jvm进程ID 1000 10  1秒输出一次 输出10次 用于观察环境上内存变化</li><li>jmap -heap jvm进程ID 查看堆内存信息</li><li>jmap -histo:live jvm进程ID 查看内存对象信息</li><li>jmap -dump:live,file=/filename.hprof jvm进程ID  dump出内存信息</li><li>jhat -port 7000 filename.hprof 将dump文件加载出来以网页方式呈现</li></ul><h2 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h2><h3 id="调优方案"><a href="#调优方案" class="headerlink" title="调优方案"></a>调优方案</h3><p>尽量让每次Young GC后的存活对象小于Survivor区域的50%，都留存在年轻代里。<br>尽量别让对象进入老年代。<br>尽量减少Full GC的频率，避免频繁Full GC对JVM性能的影响。</p><h3 id="社交app，QPS-十万"><a href="#社交app，QPS-十万" class="headerlink" title="社交app，QPS 十万"></a>社交app，QPS 十万</h3><ul><li>老年代频繁Gc 压缩碎片，避免每次GC间隔越来越短 -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=5<h3 id="垂直电商app-每小时总会有卡顿"><a href="#垂直电商app-每小时总会有卡顿" class="headerlink" title="垂直电商app 每小时总会有卡顿"></a>垂直电商app 每小时总会有卡顿</h3></li><li>垂直电商APP的各个系统通过jstat分析JVM GC之后发现，基本上高峰期的时候，Full GC每小时都会发生好几次</li><li>通用JVM参数 -Xms4096M -Xmx4096M -Xmn3072M -Xss1M -XX:PermSize=256M -XX:MaxPermSize=256M -XX:+UseParNewGC - XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFaction=92 -XX:+UseCMSCompactAtFullCollection - XX:CMSFullGCsBeforeCompaction=0</li><li>优化fullgc的效率<ul><li>-XX:+CMSParallelInitialMarkEnabled CMS垃圾回收器的“初始标记”阶段开启多线程并发执行</li><li>-XX:+CMSScavengeBeforeRemark 会在CMS的重新标记阶段之前，尽量执行一次Young GC。</li></ul></li></ul><h3 id="频繁的fullgc-观察后发现元空间的满了"><a href="#频繁的fullgc-观察后发现元空间的满了" class="headerlink" title="频繁的fullgc 观察后发现元空间的满了"></a>频繁的fullgc 观察后发现元空间的满了</h3><ul><li>代码里写了大量反射代码，JVM会动态的去生成一些类放入Metaspace区域里的，JVM自己创建的奇怪的类Class对象是SoftReference</li><li>软引用，只有内存不够才会回收，怎么判断要不要回收？clock - timestamp &lt;= freespace * SoftRefLRUPolicyMSPerMB，clock - timestamp代表了一个软引用对象他有多久没被访问过了，freespace代表JVM中的空闲内存空间，SoftRefLRUPolicyMSPerMB代表每一MB空闲内存空间可以允许SoftReference对象存活多久</li><li>SoftRefLRUPolicyMSPerMB 设置为0 导致</li><li>在有大量反射代码的场景下 -XX:SoftRefLRUPolicyMSPerMB=0 可以设置个1000，2000，3000，或者5000毫秒 默认1000</li></ul><h3 id="线上fullgc频繁"><a href="#线上fullgc频繁" class="headerlink" title="线上fullgc频繁"></a>线上fullgc频繁</h3><ul><li>机器配置:2核4G，JVM堆内存大小:2G，系统运行时间:6天，系统运行6天内发生的Full GC次数和耗时:250次，70多秒，系统运行6天内发生的Young GC次数和耗时:2.6万次，1400秒，每天会发生4000多次Young GC，每分钟会发生3次，每次Young GC在50毫秒左右</li><li>未优化前 -Xms1536M -Xmx1536M -Xmn512M -Xss256K -XX:SurvivorRatio=5 -XX:+UseParNewGC -XX:+UseConcMarkSweepGC - XX:CMSInitiatingOccupancyFraction=68 -XX:+CMSParallelRemarkEnabled -XX:+UseCMSInitiatingOccupancyOnly - XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC</li><li>通过jstat的观察，每次Young GC过后升入老年代里的对象很少 ， 每次Young GC过后大概就存活几十MB而已，那么Survivor区域因为就70MB，所以经常会触发动态年龄判断规则，导致偶尔一次Young GC过后有几十MB对象进入老年代</li><li>大对象 jstat工具观察系统，发现老年代里突然进入了几百MB的大对象,就是特殊场景全表查了数据库，量比较大</li><li>优化方案<ul><li>去除查大数据量的bug</li><li>年轻代变大，避免触发动态年龄判断，部分垃圾对象进入老年代</li><li>-Xms1536M -Xmx1536M -Xmn1024M -Xss256K -XX:SurvivorRatio=5 -XX:PermSize=256M -XX:MaxPermSize=256M - XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=92 - XX:+CMSParallelRemarkEnabled -XX:+UseCMSInitiatingOccupancyOnly -XX:+PrintGCDetails -XX:+PrintGCTimeStamps - XX:+PrintHeapAtGC<h3 id="线上fullgc每秒一次"><a href="#线上fullgc每秒一次" class="headerlink" title="线上fullgc每秒一次"></a>线上fullgc每秒一次</h3></li></ul></li><li>排查是不是代码里使用System.gc()会指挥JVM去尝试执行一次Full GC</li><li>推荐使用参数禁用-XX:+DisableExplicitGC 不允许通过代码触发GC</li></ul><h3 id="mat-内存泄漏分析利器"><a href="#mat-内存泄漏分析利器" class="headerlink" title="mat 内存泄漏分析利器"></a>mat 内存泄漏分析利器</h3><ul><li>频繁Full GC的原因：<ul><li> 内存分配不合理，导致对象频繁进入老年代，进而引发频繁的Full GC; </li><li>存在内存泄漏等问题，就是内存里驻留了大量的对象塞满了老年代，导致稍微有一些对象进入老年代就会引发Full GC; </li><li>永久代里的类太多，触发了Full GC</li></ul></li><li>大促系统 突然卡顿严重<ul><li>线程太多 负载重</li><li>JVM fullgc</li></ul></li><li>jstat 分析得出fullgc频繁 jstat -gc pid 1000 1000</li><li>jmap -dump:live,file=/data.hprof  pid dump文件导入visualvm可视化图形界面分析</li><li>mat工具分析<ul><li><a href="https://www.eclipse.org/mat/downloads.php">https://www.eclipse.org/mat/downloads.php</a></li><li>MAT上有一个工具栏，Leak Suspects，内存泄漏的分析</li></ul></li></ul><h3 id="处理数据量巨大的系统前端页面卡顿"><a href="#处理数据量巨大的系统前端页面卡顿" class="headerlink" title="处理数据量巨大的系统前端页面卡顿"></a>处理数据量巨大的系统前端页面卡顿</h3><ul><li>jstat -gc pid 1000 1000 发现fullgc 耗时10s</li><li>堆分配了20G的内存，其中10G给了年轻代，10G给了老年代</li><li>Eden区大概1分钟左右就会塞满，young gc 每次都会有几个g进入老年代</li><li>系统运行的时候在产生大量的对象，而且处理的极其的慢</li></ul><h3 id="调优到底该怎么做"><a href="#调优到底该怎么做" class="headerlink" title="调优到底该怎么做"></a>调优到底该怎么做</h3><ul><li>原则:尽可能让每次Young GC后存活对象远远小于Survivor区域，避免对象频繁进入老年代触发Full GC。</li><li>新上线系统进行压测，模拟生产环境压力，用jstat观察jvm内存变化</li><li>频繁gc表现：<ul><li>机器cpu负载过高</li><li>fullgc报警</li><li>无法处理请求或者响应慢</li></ul></li><li>频繁gc的原因<ul><li>一次性加载过多数据进入内存，很多大对象，导致大对象进入老年代  打内存快照 mat分析</li><li>系统高并发导致频繁young gc，每次young gc 存活的对象太多，内存分配不合理，survivor区太小，导致对象进入老年代，频繁触发fullgc jstat观察，然后调大survivor区，调大年轻代</li><li>永久代因为加载类过多触发fullgc  打内存快照 mat分析</li><li>调用System.gc()  代码优化</li><li>内存泄漏，无法被回收   代码优化</li></ul></li></ul><h3 id="应该如何在面试中回答JVM生产优化问题"><a href="#应该如何在面试中回答JVM生产优化问题" class="headerlink" title="应该如何在面试中回答JVM生产优化问题?"></a>应该如何在面试中回答JVM生产优化问题?</h3><ul><li><p>归纳总结出来一套通用的方法付论</p><ul><li><p>堆内存大小设置 </p><ul><li>-Xms3G -Xmx3G  最大最小堆设置相同，避免内存伸缩时造成gc导致卡顿</li><li>-Xmn2G 设置新生代的大小 -XX:SurvivorRatio=8设置eden与survivor区比例</li></ul></li><li><p>元空间</p><ul><li>-XX:MetaspaceSize=512m</li><li>-XX:MaxMetaspaceSize=512m</li></ul></li><li><p>gc日志</p><ul><li> -XX:+PrintGCDetails -XX:+PrintGCTimeStamps  -Xloggc:/gc.log</li></ul></li><li><p>栈大小</p><ul><li>-Xss1M</li></ul></li><li><p>垃圾收集器设置</p><ul><li>-XX:+UseParNewGC</li><li>-XX:+UseConcMarkSweepGC</li><li>-XX:+UseG1GC</li></ul></li><li><p>垃圾收集器相关参数设置</p><ul><li>-XX:CMSInitiatingOccupancyFaction=92 cms老年代内存大小发生fullgc,可以设置稍微小，降低发生fullgc的时间</li><li>-XX:+UseCMSCompactAtFullCollection - XX:CMSFullGCsBeforeCompaction=0 压缩碎片，每次都压缩吗</li><li>-XX:+CMSParallelInitialMarkEnabled CMS垃圾回收器的“初始标记”阶段开启多线程并发执行</li><li>-XX:+CMSScavengeBeforeRemark 会在CMS的重新标记阶段之前，尽量执行一次Young GC</li><li>-XX:+UseCMSInitiatingOccupancyOnly 只使用指定的值，避免伸缩</li></ul></li><li><p>oom的参数设置</p><ul><li>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/local/app/oom</li></ul></li><li><p>预防System.gc()</p><ul><li>-XX:+DisableExplicitGC 不容许代码控制gc</li></ul></li></ul></li><li><p>负责的系统，假设数据量和访问量暴增10倍，或者100倍，此时会不会出现频繁Full GC的 问题?如果会的话，那么一旦发生了，如何定位、分析和解决?</p><ul><li>负责的系统主要的业务借款，用户量大概有2000万，日活500万，集中在下午4～6点会进行借款</li><li>目前生产机器4核8G配置给jvm4G</li><li>借款的接口并发 每秒进入借款页面5000，借款相关接口并发10000 </li><li>核心接口 产生新对象平均20 字段数平均20个  4<em>20B</em>20=2k 扩大10倍～20倍 20k</li><li>部署8台机器 接口并发1000接口/s 一秒产生20m对象  平均80s就会young gc一次 </li></ul></li><li><p>说自己的系统可能在哪些情况下发生频繁Full GC，在压测的时候就发现了这 些问题，然后你是如何进行JVM性能优化的!</p></li></ul><h3 id="oom"><a href="#oom" class="headerlink" title="oom"></a>oom</h3><ul><li>元空间<ul><li>-XX:MetaspaceSize=512m -XX:MaxMetaspaceSize=512m</li><li>元空间gc的条件：类的类加载器先要被回收，类的所有对象实例都要被回收</li><li>在上线系统的时候对Metaspace区域直接用默认的参数,默认的太小</li><li>用cglib之类的技术动态生成一些类，一旦代码中没有控制好，导致生成的类过多，导致元空间满，从而引发oom</li></ul></li><li>栈内存<ul><li>递归调用</li></ul></li><li>堆内存<ul><li>高并发场景，导致ygc后很多请求还没处理完毕，存活对象太多，可能就在Survivor区域放不下了，只能进入到老年代，老年代很快就会放满。又有一批对象生成后younggc后仍有大量存活对象，需要放到老年代，此时老年代满了，就要触发fullgc,fullgc之后仍然放不下对象就会oom</li></ul></li></ul><h3 id="大型计算系统oom了"><a href="#大型计算系统oom了" class="headerlink" title="大型计算系统oom了"></a>大型计算系统oom了</h3><ul><li>从数据存储系统读出并计算，计算完成推送Kafka</li><li>发送Kafka失败就要重试</li><li>假设Kafka宕机，系统计算结果越来越多，最终oom</li><li>解决方案，当Kafka宕机时，写本地存储</li></ul><h3 id="oom监控方案"><a href="#oom监控方案" class="headerlink" title="oom监控方案"></a>oom监控方案</h3><ul><li>主动监控：监控系统，监控cpu,内存，监控fullgc次数</li><li>被动监控：<ul><li>系统宕机，通知</li><li>每天观察系统日志<h3 id="系统宕机时dump"><a href="#系统宕机时dump" class="headerlink" title="系统宕机时dump"></a>系统宕机时dump</h3></li></ul></li><li>XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/local/app/oom</li></ul><h3 id="netty-nio-堆外内存溢出"><a href="#netty-nio-堆外内存溢出" class="headerlink" title="netty nio 堆外内存溢出"></a>netty nio 堆外内存溢出</h3><p>当堆外内存都被大量的DirectByteBuffer对象关联使用了，再要使用更多的堆外内存，那么就会报内存溢出了<br>系统承载的是超高并发，复杂压力很高，瞬时大量请求过来，创建了过多的DirectByteBuffer占用了大量的堆外内存，此时再继续想要使用堆外内存，就会内存溢出</p><h3 id="rpc-oom"><a href="#rpc-oom" class="headerlink" title="rpc oom"></a>rpc oom</h3><p>rpc传输需要将对象序列化成字节，比如服务A的Request类有15个字段，序列化成字节流给你发送过来了，服务B的Request类只有10个字段，有的字段名字还不一 样，那么反序列化的时候就会失败，代码中写的逻辑是，一旦反序列化失败了，此时就会开辟一个byte[]数组，默认大小是4GB，然后把对方的字节流原封不动的放进 去。<br>垃圾处理逻辑，序列化失败应该返回错误的响应码</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;jm调优&quot;&gt;&lt;a href=&quot;#jm调优&quot; class=&quot;headerlink&quot; title=&quot;jm调优&quot;&gt;&lt;/a&gt;jm调优&lt;/h1&gt;&lt;h2 id=&quot;遇到了什么问题需要调优？&quot;&gt;&lt;a href=&quot;#遇到了什么问题需要调优？&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="JAVA虚拟机" scheme="https://blog.imder.top/categories/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="JAVA虚拟机" scheme="https://blog.imder.top/tags/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>学MQ所得</title>
    <link href="https://blog.imder.top/2022/02/28/%E5%AD%A6MQ%E6%89%80%E5%BE%97/"/>
    <id>https://blog.imder.top/2022/02/28/%E5%AD%A6MQ%E6%89%80%E5%BE%97/</id>
    <published>2022-02-28T22:22:22.000Z</published>
    <updated>2024-03-28T16:43:20.075Z</updated>
    
    <content type="html"><![CDATA[<h3 id="梳理出来自己负责的系统的核心业务流程，核心功能模块，跟其他系统是如何交互的，数据是如何存储，当前已经使用了哪些中间件技术。"><a href="#梳理出来自己负责的系统的核心业务流程，核心功能模块，跟其他系统是如何交互的，数据是如何存储，当前已经使用了哪些中间件技术。" class="headerlink" title="梳理出来自己负责的系统的核心业务流程，核心功能模块，跟其他系统是如何交互的，数据是如何存储，当前已经使用了哪些中间件技术。"></a>梳理出来自己负责的系统的核心业务流程，核心功能模块，跟其他系统是如何交互的，数据是如何存储，当前已经使用了哪些中间件技术。</h3><h3 id="系统与系统之间的耦合性体现"><a href="#系统与系统之间的耦合性体现" class="headerlink" title="系统与系统之间的耦合性体现"></a>系统与系统之间的耦合性体现</h3><p>来思考一个问题，假设促销系统现在有一个接口，专门是让你调用了以后派发优惠券的，现在这个接口接收的参数有 5个，你要是调用这个接口，就必须给他传递5个参数过去，这个是没的说的。<br>现在问题来了，负责促销系统的工程师某一天突然有一个新的想法，他希望改一改这个接口，在接口调用的时候需要传递7个参数！<br>一旦他的这个新接口上线了，你还是给他传5个参数，那么他那里就会报错，这个派发优惠券的行为就会失败！<br>那在这样的一个情况下应该怎么办？<br>    很简单，你作为订单系统的负责人，必须要配合促销系统去修改代码，既然他要7个参数，那么你就必须得在代码里调用他的接口的时候传递7个参数。<br>并且你还得配合他的新接口去进行测试以及部署上线，你必须得围绕着他转，配合他。<br>在这种情况下，就说明你的订单系统跟促销系统是强耦合的</p><h3 id="订单系统存在的问题"><a href="#订单系统存在的问题" class="headerlink" title="订单系统存在的问题"></a>订单系统存在的问题</h3><p><img src="/2022/02/28/%E5%AD%A6MQ%E6%89%80%E5%BE%97/aimg.png" alt="img.png"></p><h3 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h3><p>异步化提升性能，降低系统耦合，流量削峰</p><ul><li>解耦异步<br>  引入MQ之前,a系统调用b系统<br>  <img src="/2022/02/28/%E5%AD%A6MQ%E6%89%80%E5%BE%97/aimg_2.png" alt="img_2.png"><br>  引入MQ之后<br>  <img src="/2022/02/28/%E5%AD%A6MQ%E6%89%80%E5%BE%97/aimg_3.png" alt="img_3.png"></li><li>削峰<br>  MQ这个技术抗高并发的能力远远高于数据库，同样的机器配置下，如果数据库可以抗每秒6000请求，MQ至少可以抗每秒几万请求。<br>  <img src="/2022/02/28/%E5%AD%A6MQ%E6%89%80%E5%BE%97/aimg_1.png" alt="img_1.png"><br>  MQ进行流量削峰的效果，系统A发送过来的每秒1万请求是一个流量洪峰，然后MQ直接给扛下来了，都存储自己本地磁盘，这个过程就是流量削峰的过程，瞬间把一个洪峰给削下来了，让系统B后续慢慢获取消息来处理。</li></ul><h3 id="kafka-rabbitmq-rocketmq"><a href="#kafka-rabbitmq-rocketmq" class="headerlink" title="kafka rabbitmq rocketmq"></a>kafka rabbitmq rocketmq</h3><ul><li><p>kafka优点<br>  Kafka的吞吐量几乎是行业里最优秀的，在常规的机器配置下，一台机器 可以达到每秒十几万的QPS<br>  Kafka性能也很高，发送消息给Kafka都是毫秒级的性能。<br>  可用性也很高，Kafka是可以支持集群部署的，其中部分机器宕机是可以继续运行的。</p></li><li><p>kafka缺点<br>  丢数据方面的问题，Kafka收到消息之后会写入一个磁盘缓冲区里，并没有直接落地到物理磁盘上去，要是机器本身故障，可能会导致磁盘缓冲区里的数据丢失。<br>  功能非常的单一，主要是支持发送消息给他，然后从里面消费消息</p></li><li><p>kafka使用场景<br>  Kafka用在用户行为日志的采集和传输上，比如大数据团队要收集APP上用户的一些行为日志，这种日志就是用Kafka来收集和传输的。<br>  因为那种日志适当丢失数据是没有关系的，而且一般量特别大，要求吞吐量要高，一般就是收发消息，不需要太多的高级功能，所以<br>Kafka是非常适合这种场景的。</p></li><li><p>RabbitMQ优点<br>  保证数据不丢失<br>  保证高可用性，集群部署的时候部分机器宕机可以继续运行<br>  支持部分高级功 能，比如说死信队列，消息重试之类的</p></li><li><p>RabbitMQ缺点<br>  RabbitMQ的吞吐量是比较低的，一般就是每秒几万的级别<br>  集群扩展的时候（也就是加机器部署），还比较麻烦。<br>  开发语言是erlang，国内很少有精通erlang语言的工程师，没办法去阅读他的源代码</p></li><li><p>RocketMQ 优点<br>  RocketMQ是阿里开源的消息中间件，几乎同时解决了Kafka和RabbitMQ的缺陷。<br>  RocketMQ的吞吐量很高，单机可以达到10万QPS以上<br>  保证高可用性，性能很高，而且支持通过配置保证数据绝对不丢失，部署大规模的集群<br>  支持各种高级的功能，比如说延迟消息、事务消息、消息回溯、死信队列、消息积压<br>  RocketMQ是基于Java开发的，符合国内大多数公司的技术栈，可以阅读源码或者修改源码。</p></li><li><p>RocketMQ 缺点<br>  RocketMQ的官方文档相对简单，但是Kafka和RabbitMQ的官方文档就非常的全面和详细，这可能是RocketMQ目前唯一的缺点。</p></li><li><p>活跃的社区和广泛的运用<br>  基本上Kafka、RabbitMQ和RocketMQ的社区都还算活跃，更新频率都还可以，而且基本运用都非常的广泛。<br>  目前Kafka几乎是国内大数据领域日志采集传输的标准,RabbitMQ在各种中小公司里运用极为广泛,RocketMQ也是开始在一些大公司和其他公司里快速推行中。</p></li></ul><h3 id="RocketMQ-相关问题"><a href="#RocketMQ-相关问题" class="headerlink" title="RocketMQ 相关问题"></a>RocketMQ 相关问题</h3><ul><li>RocketMQ是如何集群化部署来承载高并发访问的？<br>  假设RocketMQ部署在一台机器上，即使这台机器配置很高，一般来说一台机器也就是支撑10万+的并发访问。 RocketMQ是可以集群化部署的，可以部署在多台机器上，假设每台机器都能抗10万并发，然后你只要让几十万请求分散到多 台机器上就可以了，让每台机器承受的QPS不超过10万不就行了</li><li>如果RocketMQ中要存储海量消息，如何实现分布式存储架构？<br>  MQ会收到大量的消息，这些消息并不是立马就会被所有的消费方获取过去消费的，所以一般MQ都得把消息在自己本地磁盘存储起来，然后等待消费方获取消息去处理。</li><li>RocketMQ是如何分布式存储海量消息的呢？<br>  每台机器上部署的RocketMQ进程一般称之为Broker，每个Broker都会收到不同的消息，然后就会把这批消息存储在自己本地的磁盘文件里</li><li>高可用保障:万一Broker宕机了怎么办？<br>  Broker主从架构以及多副本策略<br>  <img src="/2022/02/28/%E5%AD%A6MQ%E6%89%80%E5%BE%97/bimg.png" alt="img.png"><br>  Master Broker收到消息后会同步给Slave Broker,这个时候如果任何一个Master Broker出现故障，还有一个Slave Broker上有一份数据副本，可以保证数据不丢失，还能继续对外提供服务，保证了MQ的可靠性和高可用性</li><li>数据路由:怎么知道访问哪个Broker？<br>  有一个NameServer的概念，他也是独立部署在几台机器上的，然后所有的Broker都会把自己注册到NameServer上去，NameServer不就知道集群里有哪些Broker了？</li></ul><h3 id="RocketMQ-NameServer设计原理"><a href="#RocketMQ-NameServer设计原理" class="headerlink" title="RocketMQ NameServer设计原理"></a>RocketMQ NameServer设计原理</h3><ul><li>NameServer到底可以部署几台机器？<br>  NameServer支持部署多台机器的,NameServer可以集群化部署的，<br>  那为什么NameServer要集群化部署？ 最主要的一个原因，就是高可用性。<br>  NameServer是集群里非常关键的一个角色，管理Broker信息，别人都要通过他才知道跟哪个Broker通信。<br>  NameServer多机器部署，集群，高可用，保证任何一台机器宕机,其他机器上的NameServer可以继续对外提供服务 </li><li>Broker在启动的时候是把自己的信息注册到哪个NameServer上去的？<br>  每个Broker启动都得向所有的NameServer进行注册<br>  比如一共有10台Broker机器，2个NameServer机器，然后其中5台Broker会把自己的信息注册到1个NameServer上去，另外5台Broker会把自己的信息注册到另外1个NameServer上去。这样搞有一个最大的问题，如果1台NameServer上有5个Broker的信息，另外1个NameServer上有另外5个Broker的信息，那么此时 任何一个NameServer宕机了，不就导致5个Broker的信息就没了吗</li><li>扮演生产者和消费者的系统们，如何从NameServer那儿获取到集群的Broker信息呢？<br>知道集群里有哪些Broker，根据一定的算法挑选一个Broker去发送消息或者获取消息<br>第一种办法是这样，NameServer那儿会主动发送请求给所有的系统，告诉他们Broker信息。<br>  NameServer无法知道要推送Broker信息给哪些系统<br>第二种办法是这样的，每个系统自己每隔一段时间，定时发送请求到NameServer去拉取最新的集群Broker信息。<br>  RocketMQ中的生产者和消费者就是这样，自己主动去NameServer拉取Broker信息</li><li>如果Broker挂了，NameServer是怎么感知到的？<br>  Broker跟NameServer之间的心跳机制，Broker会每隔30s给所有的NameServer发送心跳，告诉每个NameServer自己目前还活着。<br>  NameServer会每隔10s运行一个任务，去检查一下各个Broker的最近一次心跳时间，如果某个Broker超过120s都没发送心跳了，则认为这个Broker挂掉了</li><li>Broker挂了，系统是怎么感知到的？<br>  可能某个系统就会发送消息到那个已经挂掉的Broker上去，此时是绝对不可能成功发送消息的<br>  可以考虑不发送消息到那台Broker，改成发到其他Broker上去。<br>  你必须要发送消息给那台Broker，Slave机器是一个备份，可以继续使用，可以考虑Slave进行通信<br>  系统又会重新从NameServer拉取最新的路由信息了，此时就会知道有一个Broker已经宕机了。<br><img src="/2022/02/28/%E5%AD%A6MQ%E6%89%80%E5%BE%97/cimg.png" alt="img.png"></li></ul><h3 id="RocketMQ-Broker原理分析"><a href="#RocketMQ-Broker原理分析" class="headerlink" title="RocketMQ Broker原理分析"></a>RocketMQ Broker原理分析</h3><ul><li><p>Master Broker是如何将消息同步给Slave Broker的？<br>  Master Broker主动推送给Slave Broker？还是Slave Broker发送请求到Master Broker去拉取？<br>  RocketMQ的Master-Slave模式采取的是Slave Broker不停的发送请求到Master Broker去拉取消息<br>  RocketMQ自身的Master-Slave模式采取的是Pull模式拉取消息</p></li><li><p>RocketMQ 实现读写分离了吗？<br>  Master Broker主要是接收系统的消息写入，然后会同步给Slave Broker<br>  作为消费者的系统在获取消息的时候，是从Master Broker获取的？还是从Slave Broker获取的？<br>  有可能从Master Broker获取消息，也有可能从Slave Broker获取消息<br>  Master Broker在返回消息给消费者系统的时候，会根据当时Master Broker的负载情况和Slave Broker的同步情况，向消费者系 统建议下一次拉取消息的时候是从Master Broker拉取还是从Slave Broker拉取。<br>  举个例子，Master Broker负载很重, 所以此时Master Broker就会建议你从Slave Broker去拉取消息。<br>  举另外一个例子，本身这个时候Master Broker上都已经写入了100万条数据了，结果Slave Broke同步的特别慢， 才同步了96万条数据，落后了整整4万条消息的同步，这个时候你作为消费者系统可能都获取到96万条数据了，那么下次还是只能从Master Broker去拉取消息。 </p></li><li><p>如果Slave Broke挂掉了有什么影响？<br>  有一点影响，但是影响不太大<br>  消息写入全部是发送到Master Broker的，消息获取也可以走Master Broker，只不过有一些消息获取可能是从Slave Broker 去走的。所以如果Slave Broker挂了，那么此时无论消息写入还是消息拉取，还是可以继续从Master Broke去走，对整体运行不影响。<br>  只不过少了Slave Broker，会导致所有读写压力都集中在Master Broker上。 </p></li><li><p>如果Master Broker挂掉了该怎么办？<br>  对消息的写入和获取都有一定的影响了。但是其实本质上而言，Slave Broker也是跟Master Broker一样有一份数据在的，<br>  只不过Slave Broker上的数据可能有部分没来得及从Master Broker同步。<br>  此时RocketMQ可以实现直接自动将Slave Broker切换为Master Broker吗？不能<br>  Master-Slave模式不是彻底的高可用模式，他没法实现自动把Slave切换为Master</p></li><li><p>基于Dledger实现RocketMQ高可用自动切换<br>RocketMQ 4.5之后，RocketMQ支持了一种基于Raft协议实现的一个机制，叫做Dledger,,Dledger融入RocketMQ之后，可以让一个Master Broker对应多个Slave Broker，也就是说一份数据可以有多份副本，比如一个Master Broker对应两个Slave Broker。<br>此时一旦Master Broker宕机了，就可以在多个副本，也就是多个Slave中，通过Dledger技术和Raft协议算法进行leader选举，直接将一个Slave Broker选举为新的Master Broker，然后这个新的Master Broker就可以对外提供服务了。整个过程也许只要10秒或者几十秒的时间就可以完成，这样的话，就可以实现Master Broker挂掉之后，自动从多个Slave Broker中选举出来一个新的Master Broker，继续对外服务，一切都是自动的。<br><img src="/2022/02/28/%E5%AD%A6MQ%E6%89%80%E5%BE%97/dimg.png" alt="img.png"></p></li></ul><h3 id="高可用部署方案"><a href="#高可用部署方案" class="headerlink" title="高可用部署方案"></a>高可用部署方案</h3><ul><li>NameServer集群化部署，保证高可用，建议3台机器</li><li>基于Dledger的Broker主从架构<ul><li>Dledger技术是要求至少得是一个Master带两个Slave，这样有三个Broke组成一个Group，也就是作为一个分组来运行。一旦 Master宕机，他就可以从剩余的两个Slave中选举出来一个新的Master对外提供服务</li></ul></li><li>Broker是如何跟NameServer进行通信的?<ul><li>Broker会跟每个NameServer都建立一个TCP长连接，然后定时通过TCP长连接发送心跳请求过去，30s心跳一次，120秒检查一次是否一直没有心跳包</li></ul></li><li>使用MQ的系统都要多机器集群部署<ul><li>生产者 消费者</li></ul></li><li>MQ的核心数据模型:Topic到底是什么?<ul><li>Topic不能直译，表达的意思就是一个数据集合的意思，不同类型的数据你得放不同的Topic</li></ul></li><li>Topic作为一个数据集合是怎么在Broker集群里存储的?<ul><li>分布式存储 多个master</li><li>创建Topic的时候指定数据分散存储在多台Broker机器<br><img src="/2022/02/28/%E5%AD%A6MQ%E6%89%80%E5%BE%97/fimg.png" alt="img.png"></li></ul></li><li>生产者系统是如何将消息发送给Broker的?<ul><li>在发送消息之前，得先有一个Topic，然后在发送消息的时候你得指定你要发送到哪个Topic里面去。</li><li>生产者跟nameserver建立长连接，拉取路由信息找到要投递消息的Topic分布在哪几台Broker上，根据负载均衡算法，从里面选择一台Broke机器出来</li><li>选择一台Broker，跟这个Broker建立一个TCP长连接，通过长连接向Broker发送消息</li></ul></li><li>消费者是如何从Broker上拉取消息的?<ul><li>消费者跟nameserver建立长连接，拉取路由信息,接着找到自己要获取消息的 Topic在哪几台Broker上，就可以跟Broker建立长连接，从里面拉取消息</li></ul></li></ul><h3 id="rocket-mq可视化界面管理工具"><a href="#rocket-mq可视化界面管理工具" class="headerlink" title="rocket mq可视化界面管理工具"></a>rocket mq可视化界面管理工具</h3><ul><li>git clone <a href="https://github.com/apache/rocketmq-externals.git">https://github.com/apache/rocketmq-externals.git</a> </li><li>进入rocketmq-console的目录<br>  cd rocketmq-externals/rocketmq-console </li><li>执行以下命令对rocketmq-cosole进行打包，把他做成一个jar包:<br>  mvn package -DskipTests</li><li>进入target目录下，可以看到一个jar包，接着执行下面的命令启动工作台:<br>  java -jar rocketmq-console-ng-1.0.1.jar –server.port=8080 –rocketmq.config.namesrvAddr=127.0.0.1:9876</li></ul><h3 id="中间件系统，对os内核参数调整"><a href="#中间件系统，对os内核参数调整" class="headerlink" title="中间件系统，对os内核参数调整"></a>中间件系统，对os内核参数调整</h3><p>vm.overcommit_memory 有三个值可以选择，0、1、2</p><ul><li>0，在中间件系统申请内存的时候，os内核会检查可用内存是否足够，如果足够的话就分配内存给你，如果感觉剩余内存不是太够了，干脆就拒绝你的申请，导致你申请内存失败，进而导致中间件系统异常出错。</li><li>1，把所有可用的物理内存都允许分配给你，只要有内存就给你来用，可以避免申请内存失败的问题。<br>因此一般需要将这个参数的值调整为1<br>比如我们曾经线上环境部署的Redis就因为这个参数是0，导致在save数据快照到磁盘文件的时候，需要申请大内存的时候被拒绝了，进而导致了异常报错。<br>用如下命令修改:echo ‘vm.overcommit_memory=1’ &gt;&gt; /etc/sysctl.conf。</li></ul><p>vm.max_map_count 默认值是65536</p><ul><li>会影响中间件系统可以开启的线程的数量</li><li>默认值有时候是不够的，比如我们大数据团队的生产环境部署的Kafka集群曾经有一次就报出过这个异常，说无法开启足够多的线程，直接导致Kafka宕机了。<br>建议可以把这个参数调大10倍，比如655360这样的值，保证中间件可以开启足够多的线程。<br>用如下命令修改:echo ‘vm.max_map_count=655360’ &gt;&gt; /etc/sysctl.conf。</li></ul><p>vm.swappiness<br>用来控制进程的swap行为，os会把一部分磁盘空间作为swap区域，有的进程现在可能不是太活跃，就会被操作系统把进程调整为睡眠状态，把进程中的数据放入磁盘上的swap区域，然后让这个进程把原来占用的内存空间腾出来，交给其他活跃运行的进程来使用。</p><ul><li>如果这个参数的值设置为0，意思就是尽量别把任何一个进程放到磁盘swap区域去，尽量大家都用物理内存。</li><li>如果这个参数的值是100，那么意思就是尽量把一些进程给放到磁盘swap区域去，内存腾出来给活跃的进程使用。 </li><li>默认这个参数的值是60，有点偏高了，可能会导致我们的中间件运行不活跃的时候被迫腾出内存空间然后放磁盘swap区域去。</li><li>生产环境建议把这个参数调整小一些，比如设置为10，尽量用物理内存，别放磁盘swap区域去。<br>用如下命令修改:echo ‘vm.swappiness=10’ &gt;&gt; /etc/sysctl.conf。</li></ul><p>ulimit<br>用来控制linux上的最大文件链接数的，默认值可能是1024，一般肯定是不够的，因为你在大量频繁的读写磁盘文件的时候，或者是进行网络通信的时候，都会跟这个参数有关系</p><ul><li>对于一个中间件系统而言肯定是不能使用默认值的，如果你采用默认值，很可能在线上会出现如下错误:error: too many open files。<br>因此通常建议用如下命令修改这个值:echo ‘ulimit -n 1000000’ &gt;&gt; /etc/profile。</li></ul><h3 id="中间件系统，对jvm参数调整"><a href="#中间件系统，对jvm参数调整" class="headerlink" title="中间件系统，对jvm参数调整"></a>中间件系统，对jvm参数调整</h3><ul><li>-server:服务器模式启动</li><li>-Xms8g -Xmx8g -Xmn4g:默认的堆大小是8g内存，新生代是4g内存</li><li>-XX:+UseG1GC -XX:G1HeapRegionSize=16m:用了G1垃圾回收器来做分代回收，对新生代和老年代都是用G1来回收，G1的region大小设置为了16m，这个因-为机器内存比较多，所以region大小可以调大一些给到16m，不然用2m的region，会导致致region数量过多的</li><li>-XX:G1ReservePercent=25:G1管理的老年代里预留25%的空闲内存，保证新生代对象晋升到老年代的时候有足够空间，避免老年代内存都满了，新生代有对象要进入老年代没有充足内存了，默认值是10%，偏少，调大</li><li>-XX:InitiatingHeapOccupancyPercent=30:当堆内存的使用率达到30%之后就会自动启动G1的并发垃圾回收，开始尝试回收一些垃圾对象<br>默认值是45%，调低，提高了GC的频率，避免了垃圾对象过多，一次垃圾回收耗时过长的问题</li><li>-XX:SoftRefLRUPolicyMSPerMB=0:建议这个参数不要设置为0，避免频繁回收一些软引用的Class对象，调整为比如1000</li><li>-verbose:gc -Xloggc:/dev/shm/mq_gc_%p.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps - XX:+PrintGCApplicationStoppedTime -XX:+PrintAdaptiveSizePolicy -XX:+UseGCLogFileRotation - XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=30m:控制GC日志打印输出的，gc日志文件的地址，打印哪些详细信息，每个gc日志文件的大小是30m，最多保留5个gc日志文件。</li><li>-XX:-OmitStackTraceInFastThrow:有时候JVM会抛弃一些异常堆栈信息，这个参数设置之后，禁用这个特性，要把完整的异常堆栈信息打印出来</li><li>-XX:+AlwaysPreTouch:刚开始指定JVM用多少内存，不会真正分配给他，会在实际需要使用的时候再分配给他，使用这个参数之后，就是强制让JVM启动的时候直接分配我们指定的内存，不要等到使用内存的时候再分配</li><li>-XX:MaxDirectMemorySize=15g:RocketMQ里大量用了NIO中的direct buffer，限定了direct buffer最多申请多少， 如果你机器内存比较大，可以适当调大这个值</li><li>-XX:-UseLargePages -XX:-UseBiasedLocking:这两个参数的意思是禁用大内存页和偏向锁<br>RocketMQ默认的JVM参数是采用了G1垃圾回收器，默认堆内存大小是8G 可以根据机器内存来调整，增大一些也是没有问题的，然后就是一些G1的垃圾回收的行为参数做了调整，<h3 id="对RocketMQ核心参数进行调整"><a href="#对RocketMQ核心参数进行调整" class="headerlink" title="对RocketMQ核心参数进行调整"></a>对RocketMQ核心参数进行调整</h3>sendMessageThreadPoolNums=16 RocketMQ内部用来发送消息的线程池的线程数量，默认是16</li><li>根据你的机器的CPU核数进行适当增加，比如机器CPU是24核的，可以增加这个线程数量到24或者30</li></ul><h3 id="压测"><a href="#压测" class="headerlink" title="压测"></a>压测</h3><p>在RocketMQ的TPS和机器的资源使用率和负载之间取得一个平衡。<br>例如：两个Producer不停的往RocketMQ集群发送消息，每个Producer所在机器启动了80个线程，相当于每台机器有80个线程并发的往RocketMQ集群写入消息。RocketMQ集群是1主2从组成的一个dledger模式的高可用集群，只有一个Master Broker会接收消息的写入，有2个Cosumer不停的从RocketMQ集群消费数据。<br>每条数据的大小是500个字节。</p><ul><li>cpu负载情况 top</li><li>内存使用率 free </li><li>JVM GC频率 gc日志 </li><li>磁盘IO负载 top</li><li>网卡流量 服务器使用的是千兆网卡，千兆网卡的理论上限是每秒传输128M数据，但是一般实际最大值是每秒传输100M数据<br>  sar -n DEV 1 2<br>  RocketMQ处理到每秒7万消息的时候，每条消息500字节左右的大小的情况下，每秒网卡传输数据量已经达到100M了，就是已经达到了网卡的一个极限值</li></ul><h3 id="订单系统改造"><a href="#订单系统改造" class="headerlink" title="订单系统改造"></a>订单系统改造</h3><p><img src="/2022/02/28/%E5%AD%A6MQ%E6%89%80%E5%BE%97/gimg.png" alt="img.png"></p><h3 id="发消息的几种方式（生产者）"><a href="#发消息的几种方式（生产者）" class="headerlink" title="发消息的几种方式（生产者）"></a>发消息的几种方式（生产者）</h3><ul><li><p>同步发送消息到MQ<br>  通过代码发送消息到MQ去，SendResult sendResult = producer.send(msg)，然后等待mq返回一个结果继续往下执行</p></li><li><p>异步发送消息到MQ<br>  消息发送出去，不会等待MQ返回结果，当MQ返回结果给你的时候，Producer会回调你的SendCallback里的函数，发送成功回调onSuccess函数，发送失败了回调onExceptino函数。</p></li><li><p>发送单向消息到RocketMQ<br>  发送一个消息给MQ，不会等待mq返回结果，不会关注MQ有没有返回结果，不管发送的消息是成功还是失败</p><h3 id="收消息的几种方式（消费者）"><a href="#收消息的几种方式（消费者）" class="headerlink" title="收消息的几种方式（消费者）"></a>收消息的几种方式（消费者）</h3></li><li><p>push模式<br>  Broker会主动把消息发送给消费者，消费者是被动的接收Broker推送给过来的消息，然后进行处理</p></li><li><p>pull模式<br>  消费者主动发送请求到Broker去拉取消息并处理</p></li></ul><h3 id="对其他团队要获取你们核心数据的问题，应该如何解决"><a href="#对其他团队要获取你们核心数据的问题，应该如何解决" class="headerlink" title="对其他团队要获取你们核心数据的问题，应该如何解决?"></a>对其他团队要获取你们核心数据的问题，应该如何解决?</h3><ul><li>定时同步 统计数据按天，周可以定时同步</li><li>实时同步<ul><li>发mq，其他团队消费，容许延迟</li><li>调接口 告知 </li></ul></li><li>其他团队拉数据<ul><li>提供接口给他们</li></ul></li></ul><h3 id="秒杀场景下？"><a href="#秒杀场景下？" class="headerlink" title="秒杀场景下？"></a>秒杀场景下？</h3><p>高并发读,抢购商品界面 </p><ul><li>cdn + nginx + redis  提前将商品数据放入redis, 使用nginx + lua 本地缓存和redis缓存加载商品页面<br>高并发写 </li><li>独立于订单系统，新建秒杀订单系统，避免秒杀时影响普通订单的下订单</li><li>客户端页面需要新增答题功能，防止作弊</li><li>nginx + lua 判断库存为0拦截下单接口，避免更多的请求直接打到下单接口</li><li>调用下单接口，商品库存存redis,扣减库存</li><li>下单接口 采用将数据写入mq，从而避免瞬间高并发数据库，使数据库宕机,订单系统拉取mq数据进行下单</li></ul><h3 id="Topic、MessageQueue和Broker之间的关系是什么"><a href="#Topic、MessageQueue和Broker之间的关系是什么" class="headerlink" title="Topic、MessageQueue和Broker之间的关系是什么?"></a>Topic、MessageQueue和Broker之间的关系是什么?</h3><ul><li>在创建Topic的时候需要指定一个很关键的参数，就是MessageQueue,指定你的这个Topic对应了多少个队列，也就是多少个MessageQueue</li><li>每个MessageQueue中会平均分配Topic的数据,每个Broker机器上都存储一些MessageQueue，MessageQueue是RocketMQ中非常关键的一个数据分片机制，通过这个方法，就可以实现Topic数据的分布式存储!</li><li>生产者会跟NameServer进行通信获取Topic的路由数据，生产者从NameServer中就知道一个Topic有几个MessageQueue，哪些MessageQueue在哪台Broker机器上，基于写入MessageQueue的策略，从而使消息分散在多个broker上</li><li>Master Broker挂了，此时正在等待的其他Slave Broker自动热切换为Master Broker，那么这个时候对这一组Broker就没有Master Broker可以写入了<br>按照之前的策略来均匀把数据写入各个Broker上的MessageQueue，那么会导致你在一段时间内，每次访问到这个挂掉的 Master Broker都会访问失败，在Producer中开启一个开关，sendLatencyFaultEnable 一个自动容错机制，某次访问一个Broker发现网络延迟有500ms，无法访问，自动回避访问这个Broker一段时间</li></ul><h3 id="broker如何存数据？"><a href="#broker如何存数据？" class="headerlink" title="broker如何存数据？"></a>broker如何存数据？</h3><ul><li>commitlog 顺序写文件<br>  当生产者的消息发送到一个Broker上的时候，broker接收到了一条消息，将这个消息直接写入磁盘上的一个日志文件，叫做CommitLog，直接顺序写入这个文件，CommitLog是很多磁盘文件，每个文件限定最多1GB，Broker收到消息之后就直接追加写入这个文件的末尾，如果一个CommitLog写满了1GB，就会创建一个新的CommitLog文件。</li><li>MessageQueue在数据存储中是体现在哪里呢?<ul><li>在Broker中，对Topic下的每个MessageQueue都会有一系列的ConsumeQueue文件。</li><li>在Broker的磁盘上，这种格式的一系列文件: $HOME/store/consumequeue/{topic}/{queueId}/{fileName}<br>  {topic}指代的就是某个Topic，{queueId}指代的就是某个MessageQueue，有很多的ConsumeQueue文件，ConsumeQueue文件里存储的是一条消息对应在CommitLog文件中的offset偏移量，还包含了消息的长度，以及tag hashcode，一条数据是20个字节<br><img src="/2022/02/28/%E5%AD%A6MQ%E6%89%80%E5%BE%97/abc.png" alt="img.png"></li></ul></li><li>如何让消息写入CommitLog文件近乎内存写性能的?<ul><li>Broker是基于OS操作系统的PageCache和顺序写两个机制</li><li>数据写入CommitLog文件的时候，不是直接写入底层的物理磁盘文件，先写入OS的PageCache内存缓存中，然后由OS的后台线程选一个时间，异步化的将OS PageCache内存缓冲中的数据刷入底层的磁盘文件。</li><li>磁盘文件顺序写+OS PageCache写入+OS异步刷盘的策略，基本上可以让消息写入CommitLog的性能 跟你直接写入内存里是差不多的</li><li>异步刷盘模式，消息写入吞吐量非常高，可能会有数据丢失的风险 （Broker将消息写入OS PageCache中，就直接返回ACK，尚未刷入磁盘，宕机丢数据）</li><li>同步刷盘模式 必须强制把消息刷入底层的物理磁盘文件中，然后才会返回ack给producer</li></ul></li></ul><h3 id="基于Dledger的高可用broker如何运行？"><a href="#基于Dledger的高可用broker如何运行？" class="headerlink" title="基于Dledger的高可用broker如何运行？"></a>基于Dledger的高可用broker如何运行？</h3><ul><li><p>基于DLedger技术管理CommitLog </p><ul><li>用DLedger先替换掉原来Broker 自己管理的CommitLog，由DLedger来管理CommitLog</li><li>Broker基于DLedger管理的CommitLog 去构建出来机器上的各个ConsumeQueue磁盘文件</li></ul></li><li><p>Broker集群启动时，基于DLedger技术和Raft协议完成Leader选举</p><ul><li>每个节点都投票给自己</li><li>选举失败后，每个节点随机休眠，先醒的机器投票给自己并发送投票信息给其他节点，其他节点醒了收到先醒机器的投票，会投票给先醒的节点</li><li>选票 大于等于（机器数/2+1）,选为master节点</li></ul></li><li><p>Leader Broker写入之后，基于DLedger技术和Raft协议同步给Follower Broker </p><ul><li>数据同步会分为两个阶段，一个是uncommitted阶段，一个是commited阶段</li><li>首先Leader Broker上的DLedger收到一条数据之后，会标记为uncommitted状态，通过自己的DLedgerServer组件把这个uncommitted数据发送给Follower Broker的DLedgerServer。Follower Broker的DLedgerServer收到uncommitted消息之后，必须返回一个ack给Leader Broker的DLedgerServer，然后如果Leader Broker收到超过半数的Follower Broker返回ack之后，就会将消息标记为committed状态。Leader Broker上的DLedgerServer就会发送commited消息给Follower Broker机器的DLedgerServer，让他们也把消息标记为 comitted状态。</li></ul></li><li><p>如果Leader Broker崩溃，则基于DLedger和Raft协议重新选举Leader<br>  基于DLedger还是采用Raft协议的算法，去选举出来一个新的Leader Broker继续对外提供服务，而且会对没有完成的数据同步进行一些恢复性的操作，保证数据不会丢失。</p></li></ul><h3 id="消费者是如何获取消息并处理？"><a href="#消费者是如何获取消息并处理？" class="headerlink" title="消费者是如何获取消息并处理？"></a>消费者是如何获取消息并处理？</h3><ul><li><p>消费者组概念<br>  一组消费者的简称，集群模式下，一个消费组获取到一条消息，只会交给组内的一台机器去处理，广播模式下，消费组获取到的一条消息，组内每台机器都可以获取到这条消息</p></li><li><p>重温MessageQueue、CommitLog、ConsumeQueue之间的关系<br>  MessageQueue会分散在多个Broker上，在每个Broker机器上，一 个MessageQueue就对应了一个ConsumeQueue，在物理磁盘上其实是对应了多个ConsumeQueue文件的，</p></li><li><p>MessageQueue与消费者的关系<br>  均匀的将MessageQueue分配给消费组的多台机器来消费</p></li><li><p>Push模式 vs Pull模式</p><ul><li>两个消费模式本质都是消费者机器主动发送请求到Broker机器去拉取一批消息下来。</li><li>Push是Broker会尽可能实时的把新消息交给消费者机器来进行处理，消息时效性会更好。<br>  一般我们使用RocketMQ的时候，消费模式通常都是基于他的Push模式来做的，因为Pull模式的代码写起来更加的复杂和繁琐</li><li>Push当消费者发送请求到Broker去拉取消息，有新的消息可以消费那么就会立马返回一批消息到消费机器去处理，处理完之后会接着立刻发送请求到Broker机器去拉取下一批消息。</li><li>Push模式下有一个请求挂起和长轮询的机制<br>  当消费者的请求发送到Broker，没有新的消息给你处理的时候，就会让请求线程挂起，默认是挂起15秒，后台线程每隔一会儿检查一下是否有的新的消息，在这个挂起过程中，有新的消息到达了会主动唤醒挂起的线程，然后把消息返回给消费者。</li></ul></li><li><p>Broker是如何将消息读取出来返回给消费机器的?<br>  要消费的MessageQueue以及开始消费的位置，去找到对应的ConsumeQueue读取里面对应位置的消息在CommitLog中的物理offset偏移量，然后到CommitLog中根</p></li><li><p>消费者机器如何处理消息、进行ACK以及提交消费进度?<br>  处理完这批消息之后，消费者机器就会提交我们目前的一个消费进度到Broker上去，然后Broker就会存储我们的消费进度</p></li><li><p>如果消费组中出现机器宕机或者扩容加机器，会怎么处理?<br>  如果消费组中出现机器宕机或者扩容加机器的情况，他会怎么处理?这个时候其实会进入一个rabalance的环节，也就是说重新给各个消费机器分配他们要处理的MessageQueue。</p></li></ul><h3 id="消费者根据什么策略从master还是slave拉取消息？"><a href="#消费者根据什么策略从master还是slave拉取消息？" class="headerlink" title="消费者根据什么策略从master还是slave拉取消息？"></a>消费者根据什么策略从master还是slave拉取消息？</h3><ul><li><p>ConsumeQueue文件也是基于os cache的</p><ul><li>os读取一个磁盘文件时，自动把磁盘文件里的数据缓存到os cache中</li><li>ConsumeQueue文件主要是存放消息的offset，文件小，30万条消息的offset就只有5.72MB。实际上ConsumeQueue文件是不占用多少磁盘空间的，整体数据量很小，几乎可以完全被os缓存在内存cache里。</li></ul></li><li><p>根据你读取到的offset去CommitLog里读取消息的完整数据<br>  os cache对于CommitLog而言，主要是提升文件写入性能，当你不停的写入的时候，很多最新写入的数据都会先停留在os cache里，比如这可能有10GB~20GB的数据。os会自动把cache里的比较旧的一些数据刷入磁盘里，腾出来空间给更新写入的数据放在os cache里</p><ul><li>如果你读取的是那种刚刚写入CommitLog的数据，大概率停留在os cache中，可以直接从os cache里读取CommitLog中的数据，这个就是内存读取，性能是很高的。</li><li>读取的是比较早之前写入CommitLog的数据，数据被刷入磁盘，不存在os cache里了，只能从磁盘上的文件里读取，性能是比较差</li></ul></li><li><p>Master Broker什么时候会让你从Slave Broker拉取数据?<br>  对比你当前没有拉取消息的数量和大小，以及最多可以存放在os cache内存里的消息的大小，如果没拉取的消息超过了最大能使用的内存的量，那么说明你后续会频繁从磁盘加载数据，此时就让你从slave broker去加载数据了</p></li></ul><h3 id="基于mmap技术实现磁盘高性能读写"><a href="#基于mmap技术实现磁盘高性能读写" class="headerlink" title="基于mmap技术实现磁盘高性能读写"></a>基于mmap技术实现磁盘高性能读写</h3><ul><li>传统文件读写：<br>  普通的IO操作的一个弊端，必然涉及到两次数据拷贝操作，对磁盘读写性能是有影响的。 <pre><code>  - 从磁盘上把数据读取到内核IO缓冲区里，再从内核IO缓存区里读取到用户进程私有空间，才能拿到这个文件里的数据  - 必须先把数据写入到用户进程私有空间里去，再进入内核IO缓冲区，最后进入磁盘文件里去。</code></pre></li><li>mmap技术<br>  建立用户进程私有空间的虚拟内存和文件物理磁盘地址映射，此时并没有任何的数据拷贝操作，JDK NIO包下的MappedByteBuffer的map()函数 将文件映射到内存。mmap技术在进行文件映射的时候，一般有大小限制，在1.5GB~2GB之间</li><li>mmap + page cache<br>  接下来MappedByteBuffer执行写入操作，写入的时候直接进入PageCache中，过一段时间之后，由os的线程异步刷入磁盘中<br>  判断要读取的数据是否在PageCache里?如果在的话，直接从PageCache里读取。如果不在PageCache，会从磁盘文件里加载数据到PageCache中，PageCache技术在加载数据的时候，会将你加载的数据块的临近的其他数据块一起加载到PageCache中。</li></ul><h3 id="丢数据场景"><a href="#丢数据场景" class="headerlink" title="丢数据场景"></a>丢数据场景</h3><ul><li>生产者往broker发送数据，网络异常没有发送成功</li><li>broker正常接受到数据，写入page cache ，异步刷盘策略，未刷盘机器宕机</li><li>leader故障，slave切换leader过程中，这个过程出现异常</li><li>磁盘坏了</li><li>消费者读取消息策略自动提交offset，数据未处理完宕机</li></ul><h3 id="解决丢数据"><a href="#解决丢数据" class="headerlink" title="解决丢数据"></a>解决丢数据</h3><ul><li>RocketMQ的事务消息机制确定生产者发送的消息到达broker<ul><li>首先要让生产者去发送一条half消息到MQ去，这个half消息本质就是一个业务执行成功的消息，可以理解这个消息的状态是half状态，这时消费者系统是看不见这个half消息的，生产者等待接收half消息写入成功的响应通知</li><li>half消息给MQ失败了，报错了，可能mq挂了，可能网络故障了，这时执行回滚操作</li><li>half消息成功，生产者系统完成自己的任务</li><li>生产者系统做自己的任务时发生异常，需要发rollback给mq,让mq删除half消息</li><li>生产者系统完成自己的任务，需要commit half消息，发一个commit请求给mq</li><li>rocketmq 有一个补偿，扫描自己的half消息，如果一直没有commit或rollback 会回调生产者系统的接口，询问这个消息是commit还是rollback<br><img src="/2022/02/28/%E5%AD%A6MQ%E6%89%80%E5%BE%97/d.png" alt="img.png"></li></ul></li><li>异步刷盘改为同步刷盘<br>  调整broker的配置文件，将其中的flushDiskType配置设置为:SYNC_FLUSH，默认他的值是ASYNC_FLUSH，即默认是异步刷盘的。</li><li>消费端 改为不自动提交offset<br>  RocketMQ的消费者中会注册一个监听器，MessageListenerConcurrently，当你的消费者获取到一批消息之后，回调你的这个监听器函数，让消费者系统处理这一批消息。<br>  默认的Consumer的消费模式，处理完一批消息了，才会返回 ConsumeConcurrentlyStatus.CONSUME_SUCCESS状态标识消息都处理结束，去提交offset到broker去<br>  <img src="/2022/02/28/%E5%AD%A6MQ%E6%89%80%E5%BE%97/f.png" alt="img.png"></li></ul><h3 id="事务机制底层实现原理"><a href="#事务机制底层实现原理" class="headerlink" title="事务机制底层实现原理"></a>事务机制底层实现原理</h3><ul><li>half消息写入到rocketmq内部的“RMQ_SYS_TRANS_HALF_TOPIC”这个Topic对应的一个ConsumeQueue里，此时就会认为half消息写入成功，响应给生产者系统</li><li>定时任务会去扫描RMQ_SYS_TRANS_HALF_TOPIC中的half消息，超过一定时间还是half消息，回调生产者的接口，让系统判断这个half消息是要rollback还是commit</li><li>执行rollback操作，RocketMQ就会在OP_TOPIC里写入一条记录，标记half消息已经是rollback状态</li><li>执行commit操作之后，RocketMQ就会在OP_TOPIC里写入一条记录，标记half消息已经是commit状态，接着需要把放在RMQ_SYS_TRANS_HALF_TOPIC中的half消息给写入到业务topic的ConsumeQueue里去，然后消费者系统可以看见</li><li>一直没有执行commit/rollback，RocketMQ会回调订单系统的接口去判断half消息的状态，最多就是回调15次，如果15次之后没法告知他half消息的状态，自动把消息标记为rollback。</li></ul><h3 id="同步发送-反复重试发送的缺陷"><a href="#同步发送-反复重试发送的缺陷" class="headerlink" title="同步发送+反复重试发送的缺陷"></a>同步发送+反复重试发送的缺陷</h3><ul><li>反复重试耗时，影响接口返回</li><li>反复重试失败，回滚业务代码不方便，本地事务容易会滚，但是操作中间件的不容易会滚</li><li>反复重试失败，未会滚业务代码，导致系统之间数据不一致，未收到消息的系统与发送消息的系统数据不一致</li></ul><h3 id="消息重复消费原因？"><a href="#消息重复消费原因？" class="headerlink" title="消息重复消费原因？"></a>消息重复消费原因？</h3><ul><li>生产者接口由于意外原因被调用多次</li><li>反复重试代码有概率重复发送</li><li>消费者消费未提交offset之前系统重启</li></ul><h3 id="幂等性，保证数据不会重复消费"><a href="#幂等性，保证数据不会重复消费" class="headerlink" title="幂等性，保证数据不会重复消费"></a>幂等性，保证数据不会重复消费</h3><ul><li>生产者保证幂等性<ul><li>利用rocket mq 可查询已发送消息判断</li><li>利用redis 存储已发过的消息，存在缺陷，消息已推送mq，未写入redis，系统重启</li><li>RocketMQ支持你查询某个消息是否存在的，性能也不是太好，会影响接口的性能。基于Redis的消息发送状态的方案，在极端情况下还是没法100%保证幂等性</li></ul></li><li>消费者保证幂等性<ul><li>推荐业务判断法，直接根据你的数据存储中的记录来判断这个消息是否处理过， 如果处理过，那就别再次处理</li></ul></li></ul><h3 id="消息消费过程异常怎么办？"><a href="#消息消费过程异常怎么办？" class="headerlink" title="消息消费过程异常怎么办？"></a>消息消费过程异常怎么办？</h3><ul><li>重试流程？<ul><li>RocketMQ会有一个针对你这个ConsumerGroup的重试队列，如果消费消息返回RECONSUME_LATER状态，就会把这个消息放到这个消费者组的重试队列中，消费组的名称是“VoucherConsumerGroup”，一个消费者组，那么会有一个 “%RETRY%VoucherConsumerGroup”的重试队列</li><li>过一段时间，重试队列中的消息会再次给消费者处理，如果再次失败，又返回了RECONSUME_LATER，那么会再过一段时间让我们来进行处理，默认最多是重试16次!</li><li>重试时间间隔 messageDelayLevel=1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</li></ul></li><li>重试失败了怎么办？<ul><li>重试了16次还一直没处理成功，就不要继续重试这批消息，同时消息会自动进入死信队列。</li><li>死信队列的名字是“%DLQ%VoucherConsumerGroup”</li><li>可以开一个后台线程，订阅“%DLQ%VoucherConsumerGroup”死信队列， 对死信队列中的消息，一直不停的处理</li></ul></li></ul><h3 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h3><p>发送消息时，给消息设置tag或者属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Message msg = new Message(&quot;topic&quot;,&quot;tag&quot;,data.getBytes()); 指定tag</span><br><span class="line">msg.putUserProperty(&quot;props&quot;,10);添加属性</span><br></pre></td></tr></table></figure><p>消费数据的时候根据tag和属性进行过滤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">consumer.subscribe(&quot;topic&quot;,&quot;tag1||tag2&quot;);</span><br><span class="line">或</span><br><span class="line">consumer.subscribe(&quot;topic&quot;,MessageSelector.bySql(&quot;props &gt; 10s&quot;))</span><br></pre></td></tr></table></figure><p> RocketMQ还是支持比较丰富的数据过滤语法的，如下所示:<br>(1)数值比较，比如: &gt;，&gt;=，&lt;，&lt;=，BETWEEN，=;<br>(2)字符比较，比如: =，&lt;&gt;，IN;<br>(3)IS NULL 或者 IS NOT NULL;<br>(4)逻辑符号 AND，OR，NOT;<br>(5)数值，比如:123，3.1415;<br>(6)字符，比如:’abc’，必须用单引号包裹起来;<br>(7)NULL，特殊的常量<br>(8)布尔值，TRUE 或 FALSE</p><h3 id="延迟消息"><a href="#延迟消息" class="headerlink" title="延迟消息"></a>延迟消息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Message msg = new Message(&quot;topic&quot;,&quot;tag&quot;,data.getBytes()); 指定tag</span><br><span class="line">msg.setDelayTimeLevel(3);添加延迟级别</span><br></pre></td></tr></table></figure><p>发送延迟消息的核心，就是设置消息的delayTimeLevel延迟级别<br>RocketMQ默认支持延迟级别:1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h<br>代码中设置延迟级别为3，意思就是延迟10s，发送出去的消息，会过10s被消费者获取到。</p><h3 id="基于消息key来定位消息是否丢失"><a href="#基于消息key来定位消息是否丢失" class="headerlink" title="基于消息key来定位消息是否丢失"></a>基于消息key来定位消息是否丢失</h3><p>可以基于消息key来实现，通过如下方式设置一个消息的key为订单id:message.setKeys(orderId)<br>接着这个消息到broker上，会基于key构建hash索引，这个hash索引就存放在IndexFile索引文件里。<br>通过MQ提供的命令去根据key查询这个消息:mqadmin queryMsgByKey -n 127.0.0.1:9876 - t SCANRECORD -k orderId</p><h3 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h3><p>Broker的配置文件里需要设置aclEnable=true这个配置，开启权限控制<br>Broker部署机器的${ROCKETMQ_HOME}/store/config目录下，可以放一个plain_acl.yml的配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 这个参数就是全局性的白名单</span><br><span class="line"># 这里定义的ip地址，都是可以访问Topic的</span><br><span class="line">globalWhiteRemoteAddresses:</span><br><span class="line">- 13.21.33.*</span><br><span class="line">- 192.168.0.*</span><br><span class="line"># 这个accounts就是说，你在这里可以定义很多账号</span><br><span class="line"># 每个账号都可以在这里配置对哪些Topic具有一些操作权限</span><br><span class="line">accounts:</span><br><span class="line"># 这个accessKey其实就是用户名的意思，比如我们这里叫做“订单技术团队” - accessKey: OrderTeam</span><br><span class="line"># 这个secretKey其实就是这个用户名的密码</span><br><span class="line">secretKey: 123456</span><br><span class="line"># 下面这个是当前这个用户名下哪些机器要加入白名单的</span><br><span class="line">whiteRemoteAddress:</span><br><span class="line"># admin指的是这个账号是不是管理员账号</span><br><span class="line">admin: false</span><br><span class="line"># 这个指的是默认情况下这个账号的Topic权限和ConsumerGroup权限</span><br><span class="line">defaultGroupPerm: SUB</span><br><span class="line"># 这个就是这个账号具体的堆一些账号的权限</span><br><span class="line"># 下面就是说当前这个账号对两个Topic，都具备PUB|SUB权限，就是发布和订阅的权限 # PUB就是发布消息的权限，SUB就是订阅消息的权限</span><br><span class="line"># DENY就是拒绝你这个账号访问这个Topic</span><br><span class="line">topicPerms:</span><br><span class="line">- CreateOrderInformTopic=PUB|SUB - PaySuccessInformTopic=PUB|SUB</span><br><span class="line"># 下面就是对ConsumerGroup的权限，也是同理的 groupPerms:</span><br><span class="line">- groupA=DENY</span><br><span class="line">- groupB=PUB|SUB</span><br><span class="line">- groupC=SUB</span><br><span class="line"># 下面就是另外一个账号了，比如是商品技术团队的账号 - accessKey: ProductTeam</span><br><span class="line">secretKey: 12345678 whiteRemoteAddress: 192.168.1.*</span><br><span class="line"># 如果admin设置为true，就是具备一切权限 admin: true</span><br></pre></td></tr></table></figure><h3 id="消息消费链路"><a href="#消息消费链路" class="headerlink" title="消息消费链路"></a>消息消费链路</h3><ul><li>broker的配置文件里开启traceTopicEnable=true开启消息轨迹追踪。</li><li>当启动这个Broker的时候会自动创建出来一个内部的Topic，RMQ_SYS_TRACE_TOPIC，用来存储所有的消息轨迹追踪的数据的。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQProducer producer = new DefaultMQProducer(&quot;topic&quot;,true); //第二个参数enableMsgTrace= true表示对消息开启轨迹追踪</span><br></pre></td></tr></table></figure><ul><li><p>RocketMQ控制台里，在导航栏里就有一个消息轨迹，在里面可以创建查询任务， 根据messageId、message key或者Topic来查询，Producer、Broker、Consumer上报的一些轨迹数据</p></li><li><p>Broker记录消息的轨迹数据，包括如下:消息存储的Topic、消息存储的位置、消息的key、消息的 tags。</p></li><li><p>Consumer端上报信息， 包括：Consumer的信息、投递消息的时间、这是第几轮投递消息、消息消费是否成功、消费这条消息的耗时</p><h3 id="消息积压了怎么办？"><a href="#消息积压了怎么办？" class="headerlink" title="消息积压了怎么办？"></a>消息积压了怎么办？</h3><p>4台机器20个message queue 消息积压了</p></li><li><p>临时申请16台机器多部署16个消费者系统的实例，然后20个消费者系统同时消费，每个人消费一个MessageQueue的 消息</p></li><li><p>消费者系统底层依赖的数据库必须要能抗住临时增加了5倍的读写压力</p></li></ul><h3 id="mq故障了怎么办？-异常重试、失败存储、恢复发送"><a href="#mq故障了怎么办？-异常重试、失败存储、恢复发送" class="headerlink" title="mq故障了怎么办？ 异常重试、失败存储、恢复发送"></a>mq故障了怎么办？ 异常重试、失败存储、恢复发送</h3><ul><li>针对这种场景，生产者系统中设计高可用的降级方案，发送消息到MQ代码里去try catch捕获异常，有异常进行重试。</li><li>连续重试了超过n次还是失败，说明MQ集群可能彻底崩溃，这时消息写入到本地存储（数据库、本地磁盘文件、NoSQL存储）</li><li>不停的尝试发送消息到MQ去，一旦发现MQ集群恢复，有一个后台线程可以把之前持久化存储的消息都查询出来，依次按照顺序发送到MQ集群里</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;梳理出来自己负责的系统的核心业务流程，核心功能模块，跟其他系统是如何交互的，数据是如何存储，当前已经使用了哪些中间件技术。&quot;&gt;&lt;a href=&quot;#梳理出来自己负责的系统的核心业务流程，核心功能模块，跟其他系统是如何交互的，数据是如何存储，当前已经使用了哪些中间件技</summary>
      
    
    
    
    <category term="消息队列" scheme="https://blog.imder.top/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="消息队列" scheme="https://blog.imder.top/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>mysql优化</title>
    <link href="https://blog.imder.top/2022/02/28/mysql%E4%BC%98%E5%8C%96/"/>
    <id>https://blog.imder.top/2022/02/28/mysql%E4%BC%98%E5%8C%96/</id>
    <published>2022-02-28T14:59:29.000Z</published>
    <updated>2024-03-28T16:43:20.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql优化"><a href="#mysql优化" class="headerlink" title="mysql优化"></a>mysql优化</h1><h2 id="聚集索引和非聚集索引"><a href="#聚集索引和非聚集索引" class="headerlink" title="聚集索引和非聚集索引"></a>聚集索引和非聚集索引</h2><ul><li>聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个 </li><li>聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续</li><li>聚集索引:物理存储按照索引排序；聚集索引是一种索引组织形式，索引的键值逻辑顺序决定了表数据行的物理存储顺序。<br>非聚集索引:物理存储不按照索引排序；非聚集索引则就是普通索引，仅仅只是对数据列创建相应的索引，不影响整个表的物理存储顺序。</li><li>聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。</li></ul><h2 id="mysql的myisam和innodb区别"><a href="#mysql的myisam和innodb区别" class="headerlink" title="mysql的myisam和innodb区别"></a>mysql的myisam和innodb区别</h2><ul><li>索引结构<br>  InnoDB的数据文件本身就是主索引文件<br>  MyISAM的主索引和数据是分开的<br>  InnoDB的辅助索引data域存储相应记录主键的值而不是地址<br>  MyISAM的辅助索引和主索引没有多大区别<br>  InnoDB是聚簇索引，数据挂在主键索引之下</li><li>锁<br>  myisam 只支持表锁<br>  innodb 支持行锁</li><li>事务<br>  myisam 没有事务和mvcc<br>  innodb 支持事务和mvcc</li><li>主键<br>  MyISAM允许没有任何索引和主键的表存在，索引都是保存行的地址<br>  InnoDB如果没有设定主键或非空唯一索引，就会自动生成一个6字节的主键，数据是主索引的一部分，附加索引保存的是主索引的值</li><li>外键<br>  MyISAM不支持，InnoDB支持</li></ul><h2 id="b-tree和b-tree"><a href="#b-tree和b-tree" class="headerlink" title="b-tree和b+tree"></a>b-tree和b+tree</h2><p>一棵m阶的B-Tree有如下特性：<br>    1. 每个节点最多有m个孩子。<br>    2. 除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。<br>    3. 若根节点不是叶子节点，则至少有2个孩子<br>    4. 所有叶子节点都在同一层，且不包含其它关键字信息<br>    5. 每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn）<br>    6. 关键字的个数n满足：ceil(m/2)-1 &lt;= n &lt;= m-1<br>    7. ki(i=1,…n)为关键字，且关键字升序排序。<br>    8. Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)</p><p><img src="/2022/02/28/mysql%E4%BC%98%E5%8C%96/img.png" alt="img.png"><br>每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。</p><p>模拟查找关键字29的过程：<br>    1. 根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】<br>    2. 比较关键字29在区间（17,35），找到磁盘块1的指针P2。<br>    3. 根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】<br>    4. 比较关键字29在区间（26,30），找到磁盘块3的指针P2。<br>    5. 根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】<br>    6. 在磁盘块8中的关键字列表中找到关键字29。</p><p>B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。<br>B+Tree相对于B-Tree有几点不同：<br>    1. 非叶子节点只存储键值信息。<br>    2. 所有叶子节点之间都有一个链指针。<br>    3. 数据记录都存放在叶子节点中。“”<br><img src="/2022/02/28/mysql%E4%BC%98%E5%8C%96/img_1.png" alt="img_1.png"><br>推算：<br>    InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为〖10〗^3）。<br>    也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * （16KB/每条数据的大小+键值=100B）= 1600万 条记录。<br>    实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2-4层。<br>    mysql的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。</p><h2 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h2><h3 id="explain两个变种"><a href="#explain两个变种" class="headerlink" title="explain两个变种"></a>explain两个变种</h3><ul><li>explain extended:会在 explain 的基础上额外提供一些查询优化的信息，紧随其后通过 show warnings 命令可以得到优化后的查询语句，从而看出优化器优化了什么。<ul><li>例如：explain extended select * from film where id = 1;</li><li>sshow warnings;</li></ul></li><li>explain partitions:相比 explain 多了个 partitions 字段，如果查询是基于分区表的 话，会显示查询将访问的分区。</li></ul><h3 id="explain中的列"><a href="#explain中的列" class="headerlink" title="explain中的列"></a>explain中的列</h3><ul><li>id列<ul><li>select语句的编号，越大越先执行</li><li>相同编号，从上往下执行</li></ul></li><li>select_type列<ul><li>simple 简单查询</li><li>primary 复杂查询最外层的查询</li><li>subquery 子查询但是不包括from后的子查询</li><li>derived from 后的子查询</li><li>union union后的select</li></ul></li><li>table列 查询的表<ul><li>当from子句中有子查询时，table列是 <derivenN> 格式，表示当前查询依赖 id=N 的查 询，于是先执行 id=N 的查询</li><li>当有 union 时，UNION RESULT 的 table 列的值为&lt;union1,2&gt;，1和2表示参与 union 的 select 行id</li></ul></li><li>type列：查询类型<ul><li>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL 一般来说，得保证查询达到range级别，最好达到ref</li><li>const, system:mysql能对查询的某部分进行优化并将其转化成一个常量</li><li>eq_ref:primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。</li><li>ref: 简单 select 查询，name是普通索引(非唯一索引)；关联表查询，使用联合索引连接</li><li>range：范围扫描通常出现在 in(), between ,&gt; ,&lt;, &gt;= 等操作中。使用一个索引来检索给定范围的行。</li><li>index:扫描全表索引</li><li>ALL:全表扫描，</li></ul></li><li>possible_keys列<br>  可能使用哪些索引来查找</li><li>key列<br>  mysql实际采用哪个索引来优化对该表的访问</li><li>key_len列<ul><li>mysql在索引里使用的字节数，算出具体使用了索引中的哪些列。</li><li>key_len计算规则如下: 字符串:char(n):n字节长度;varchar(n):2字节存储字符串长度，如果是utf-8，则长度 3n +2。数值类型:tinyint:1字节;smallint:2字节;int:4字节 ;bigint:8字节。时间类型:date:3字节;timestamp:4字节;datetime:8字节</li><li>如果字段允许为 NULL，需要1字节记录是否为 NULL</li><li>索引最大长度是768字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引。</li></ul></li><li>ref列 key列记录的索引中，表查找值所用到的列或常量，常见的有:const(常量)，字段名</li><li>rows列 mysql估计要读取并检测的行数，注意不是结果集里的行数。</li><li>Extra列:额外信息<ul><li>1)Using index:查询的列被索引覆盖，并且where筛选条件是索引的是前导列</li><li>2)Using where:查询的列未被索引覆盖，where筛选条件非索引的前导列</li><li>3)Using index condition:查询的列不全在索引中，where条件中是一个前导列的范围；查询列不完全被索引覆盖，查询条件完全可以使用到索引</li><li>4)Using temporary:mysql需要创建一张临时表来处理查询</li><li>5)Using filesort:将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序</li><li>6)Select tables optimized away:使用某些聚合函数(比如 max、min)来访问存在索引的某个字段</li><li><ol start="7"><li>Using where Using index 查询的列被索引覆盖，并且where筛选条件是索引列之一但是不是索引的不是前导列</li></ol></li><li><ol start="8"><li>NULL 查询的列未被索引覆盖，并且where筛选条件是索引的前导列，需要回表</li></ol></li></ul></li></ul><h2 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h2><h3 id="索引实践"><a href="#索引实践" class="headerlink" title="索引实践"></a>索引实践</h3><ul><li><p>查询条件全值匹配</p></li><li><p>最左前缀法则，联合索引，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。</p></li><li><p>不在索引列上做任何操作(计算、函数、(自动or手动)类型转换)，会导致索引失效而转向全表扫描</p></li><li><p>存储引擎不能使用联合索引（A，B）中（A）范围条件右边的列（B）</p></li><li><p>尽量使用覆盖索引(只访问索引的查询(索引列包含查询列))，减少select *语句</p></li><li><p>mysql在使用不等于(!=或者&lt;&gt;)的时候无法使用索引会导致全表扫描</p></li><li><p>is null,is not null 也无法使用索引</p></li><li><p>like以通配符开头(‘%abc…’)mysql索引失效会变成全表扫描操作</p><ul><li>解决like’%字符串%’索引不被使用的方法? <ul><li>a)使用覆盖索引，查询字段必须是建立覆盖索引字段</li><li>b)如果不能使用覆盖索引则可能需要借助搜索引擎</li></ul></li></ul></li><li><p>字符串不加单引号索引失效</p></li><li><p>少用or或in，用它查询时，mysql不一定使用索引，mysql内部优化器会根据检索比例、 表大小等多个因素整体评估是否使用索引，详见范围查询优化</p></li><li><p>范围查询优化，可能是由于单次数据量查询过大导致优化器最终选择不走索引 优化方法:可以讲大的范围拆分成多个小</p><h3 id="为什么推荐建表时字段为not-null"><a href="#为什么推荐建表时字段为not-null" class="headerlink" title="为什么推荐建表时字段为not null?"></a>为什么推荐建表时字段为not null?</h3></li><li><p>通常情况下最好指定列为NOT NULL，除非真的需要存储NULL值。</p><ul><li>如果查询中包含可为NULL的列，对MySql来说更难优化，因为可为NULL的列使得索引、索引统计和值比较都更复杂。</li><li>可为NULL的列会使用更多的存储空间，在MySql里也需要特殊处理。当可为NULL的列被索引时，每个索引记录需要一个额外的字节，在MyISAM里甚至还可能导致固定大小的索引（例如只有一个整数列的索引）变成可变大小的索引。</li><li>通常把可为NULL的列改为NOT NULL带来的性能提升比较小，所以（调优时）没有必要首先在现有schema中查找并修改掉这种情况，除非确定这会导致问题。</li><li>如果计划在列上建索引，就应该尽量避免设计成可为NULL的列。</li></ul></li><li><p>mysql的默认值</p></li></ul><p>对于MySql而言，如果不主动设置为NOT NULL的话，那么插入数据的时候默认值就是NULL。NULL和NOT NULL使用的空值代表的含义是不一样，NULL可以认为这一列的值是未知的，空值则可以认为我们知道这个值，只不过他是空的而已。举个例子，一张表中的某一条name字段是NULL，我们可以认为不知道名字是什么，反之如果是空字符串则可以认为我们知道没有名字，他就是一个空值。而对于大多数程序的情况而言，没有什么特殊需要非要字段要NULL的吧，NULL值反而会对程序造成比如空指针的问题。</p><p>默认值为NULL带来的问题</p><ul><li><p>聚合函数不准确<br>  对于NULL值的列，使用聚合函数的时候会忽略NULL值。例如：有一张表，name字段默认是NULL，此时对name进行count得出的结果是1，这个是错误的。count(*)是对表中的行数进行统计，count(name)则是对表中非NULL的列进行统计。</p></li><li><p>=失效<br>  对于NULL值的列，是不能使用=表达式进行判断的，下面对name的查询是不成立的，必须使用is NULL。</p></li><li><p>与其他值运算<br>  NULL和其他任何值进行运算都是NULL，包括表达式的值也是NULL。user表第二条记录age是NULL，所以+1之后还是NULL，name是NULL，进行concat运算之后结果还是NULL。</p></li><li><p>distinct、group by、order by<br>  对于distinct和group by来说，所有的NULL值都会被视为相等，对于order by来说升序NULL会排在最前。</p></li><li><p>索引问题</p><ul><li>官方文档：使用is NULL和范围查询都是可以和正常一样使用索引的，只不过在某些场景下，由于mysql的执行策略导致索引失效。</li><li>sql执行过程中，到优化器阶段，会选择使用什么索引比较合理，sql具体执行方案在这里确定下来，索引列存在NULL就会导致优化器在做索引选择的时候更复杂，更加难以优化。</li></ul></li></ul><h3 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h3><ul><li>MySQL支持两种方式的排序filesort和index，Using index是指MySQL扫描索引本身完成排序。index效率高，filesort效率低。<ul><li>order by满足两种情况会使用Using index。<ul><li>order by语句使用索引最左前列。</li><li>使用where子句与order by子句条件列组合满足索引最左前列。 </li></ul></li><li>尽量在索引列上完成排序，遵循索引建立(索引创建的顺序)时的最左前缀法则。</li><li>如果order by的条件不在索引列上，就会产生Using filesort。</li><li>能用覆盖索引尽量用覆盖索引</li><li>group by与order by很类似，其实质是先排序后分组，遵照索引创建顺序的最左前缀法则。对于group by的优化如果不需要排序的可以加上order by null禁止排序。注意，where高于having，能写在where中 的限定条件就不要去having限定了。</li></ul></li></ul><ul><li><p>Using filesort文件排序原理详解 filesort文件排序方式</p><ul><li><p>单路排序:是一次性取出满足条件行的所有字段，然后在sort buffer中进行排序;用trace工具可 以看到sort_mode信息里显示&lt; sort_key, additional_fields &gt;或者&lt; sort_key, packed_additional_fields &gt;</p></li><li><p>双路排序(回表排序模式):是首先根据相应的条件取出相应的排序字段和可以直接定位行数据的行 ID，然后在 sort buffer 中进行排序，排序完后需要再次取回其它需要的字段;用trace工具 可以看到sort_mode信息里显示&lt; sort_key, rowid &gt;</p></li><li><p>MySQL 通过比较系统变量 max_length_for_sort_data(默认1024字节) 的大小和需要查询的字段总大小来 判断使用哪种排序模式。如果 max_length_for_sort_data 比查询字段的总长度大，那么使用 单路排序模式; 如果 max_length_for_sort_data 比查询字段的总长度小，那么使用 双路排序模式。</p></li></ul></li></ul><p>例如：select * from a_table where b = ‘111’ order by c; 注：字段b建立索引，字段c无索引</p><ul><li>单路排序:<ol><li>索引b找到第一个满足 b = ‘111’ 条件的主键id </li><li>根据主键 id 取出整行，取出所有字段的值，存入 sort_buffer 中 </li><li>从索引b找到下一个满足 b = ‘111’ 条件的主键 id </li><li>重复步骤 2、3 直到不满足  b = ‘111’ </li><li>对 sort_buffer 中的数据按照字段 c 进行排序</li><li>返回结果给客户端</li></ol></li><li>双路排序: set max_length_for_sort_data = 10; ‐‐设置表所有字段长度总和肯定大于10字节<ol><li>从索引 b 找到第一个满足 b = ‘111’ 的主键id</li><li>根据主键 id 取出整行，把排序字段 c 和主键 id 这两个字段放到 sort buffer 中 </li><li>从索引 b 取下一个满足 b = ‘111’ 记录的主键 id</li><li>重复 3、4 直到不满足 b = ‘111’</li><li>对 sort_buffer 中的字段 c 和主键 id 按照字段 c 进行排序</li><li>遍历排序好的 id 和字段 c，按照 id 的值回到原表中取出 所有字段的值返回给客户端</li></ol></li></ul><p>如果全部使用sort_buffer内存排序一般情况下效率会高于磁盘文件排序，但不能因为这个就随便增 大sort_buffer(默认1M)，mysql很多参数设置都是做过优化的，不要轻易调整。</p><h3 id="分页查询优化"><a href="#分页查询优化" class="headerlink" title="分页查询优化"></a>分页查询优化</h3><p>例如：select * from employees limit 10000,10<br>从表 employees 中取出从 10001 行开始的 10 行记录。看似只查询了 10 条记录，实际这条 SQL 是先读取 10010 条记录，然后抛弃前 10000 条记录，然后读到后面 10 条想要的数据。因此要查询一张大表比较靠后的数据，执行效率 是非常低的。</p><ul><li>按照主键排序并limit：条件：主键自增且连续，结果是按照主键排序的<br>  select * from employees where id &gt; 90000 limit 5; 没单独加 order by，表示通过主键排序</li><li>根据非主键字段排序的分页查询:连接子查询，子查询使用覆盖索引<br>  select * from employees ORDER BY name limit 90000,5; name字段有索引，但是查询计划显示没有走索引，使用索引比全表扫描成本高<br>  优化方案：select * from employees e inner join (select id from employees order by name limit 90000,5) eq on eq.id = e.id</li></ul><h3 id="join关联优化"><a href="#join关联优化" class="headerlink" title="join关联优化"></a>join关联优化</h3><ul><li>mysql的表关联常见有两种算法<ul><li>Nested-Loop Join 算法</li><li>Block Nested-Loop Join 算法</li></ul></li><li>嵌套循环连接 Nested-Loop Join(NLJ)算法 ：优化器一般会优先选择小表做驱动表，执行计划 Extra 中未出现 Using join buff<ul><li>循环地从第一张表(称为驱动表)中读取行，在这行数据中取到关联字段，根据关联字段在另一张表(被驱动表)里取出满足条件的行，然后取出两张表的结果合集。</li><li>select*from t1 inner join t2 on t1.a= t2.a; 这里假设t2小表（100条） t1大表 （10000）</li><li>上面sql的大致流程如下:<ol><li>从表 t2 中读取一行数据;</li><li>从第 1 步的数据中，取出关联字段 a，到表 t1 中查找;</li><li>取出表 t1 中满足条件的行，跟 t2 中获取到的结果合并，作为结果返回给客户端; </li><li>重复上面 3 步。</li></ol></li><li>整个过程会读取 t2 表的所有数据(扫描100行)，然后遍历这每行数据中字段 a 的值，根据 t2 表中 a 的值索引扫描 t1 表 中的对应行(扫描100次 t1 表的索引，1次扫描可以认为最终只扫描 t1 表一行完整数据，也就是总共 t1 表也扫描了100 行)。因此整个过程扫描了 200 行。</li><li>如果被驱动表的关联字段没索引，使用NLJ算法性能会比较低(下面有详细解释)，mysql会选择Block Nested-Loop Join 算法。</li></ul></li><li>基于块的嵌套循环连接 Block Nested-Loop Join(BNL)算法：被驱动表连接字段无索引<ul><li>把驱动表的数据读入到 join_buffer 中，然后扫描被驱动表，把被驱动表每一行取出来跟 join_buffer 中的数据做对比。 </li><li>select*from t1 inner join t2 on t1.b= t2.b; 这里假设t2小表（100条） t1大表 （10000）<ol><li>把 t2 的所有数据放入到 join_buffer 中</li><li>把表 t1 中每一行取出来，跟 join_buffer 中的数据做对比 3. 返回满足 join 条件的数据</li></ol></li><li>整个过程对表 t1 和 t2 都做了一次全表扫描，因此扫描的总行数为10000(表 t1 的数据总量) + 100(表 t2 的数据总量) = 10100。并且 join_buffer 里的数据是无序的，因此对表 t1 中的每一行，都要做 100 次判断，所以内存中的判断次数是 100 * 10000= 100 万次。</li></ul></li></ul><p>被驱动表的关联字段没索引为什么要选择使用 BNL 算法而不使用 Nested-Loop Join 呢?<br>如果上面第二条sql使用 Nested-Loop Join，那么扫描行数为 100 * 10000 = 100万次，这个是磁盘扫描。<br>很显然，用BNL磁盘扫描次数少很多，相比于磁盘扫描，BNL的内存计算会快得多。</p><h3 id="in和exsits优化-：小表驱动大表"><a href="#in和exsits优化-：小表驱动大表" class="headerlink" title="in和exsits优化 ：小表驱动大表"></a>in和exsits优化 ：小表驱动大表</h3><ul><li>A表与B表的ID字段应建立索引</li><li>in:当B表的数据集小于A表的数据集时，in优于exists<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from A where id in(select id from B)</span><br><span class="line">等价于 </span><br><span class="line">for  bid in select * from B</span><br><span class="line">    select * from A where id = bid  //先扫描索引，然后在根据索引查数据</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>exists:当A表的数据集小于B表的数据集时，exists优于in<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from A where exists(select 1 from B where B.id=A.id)</span><br><span class="line"> 等价于</span><br><span class="line"> for(select * from A)&#123;</span><br><span class="line"> select * from B where B.id = A.id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="count（-）优化"><a href="#count（-）优化" class="headerlink" title="count（*）优化"></a>count（*）优化</h3>id为主键，name普通索引<br>EXPLAIN select count(1) from employees;<br>EXPLAIN select count(id) from employees;<br>EXPLAIN select count(name) from employees;<br>EXPLAIN select count(*) from employees;<br>四个sql的执行计划一样，说明这四个sql执行效率应该差不多，区别在于根据某个字段count不会统计字段为null值的数据行<br>为什么mysql最终选择辅助索引而不是主键聚集索引?因为二级索引相对主键索引存储数据更少，检索性能应该更高</li></ul><p>常见优化方法<br>1、查询mysql自己维护的总行数 对于myisam存储引擎的表做不带where条件的count查询性能是很高的，因为myisam存储引擎的表的总行数会被 mysql存储在磁盘上，查询不需要计算<br>对于innodb存储引擎的表mysql不会存储表的总记录行数，查询count需要实时计算<br>2、show table status 如果只需要知道表总行数的估计值可以用如下sql查询，性能很高<br>3、将总数维护到Redis里 插入或删除表数据行的时候同时维护redis里的表总行数key的计数值(用incr或decr命令)，但是这种方式可能不准，很难 保证表操作和redis操作的事务一致性<br>4、增加计数表 插入或删除表数据行的时候同时维护计数表，让他们在同一个事务里操作</p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ul><li>锁分类<ul><li>性能上分为乐观锁和悲观锁</li><li>对数据库的操作上分为读锁(共享锁：多个读不影响)和写锁(排他锁：阻断其他读写锁)，都属于悲观锁</li><li>从数据的操作粒度上分表锁和行锁</li></ul></li><li>表锁<ul><li>每次操作锁住整张表。开销小，加锁快;不会出现死锁;锁定粒度大，发生锁冲突的概率最高，并发度最低</li><li>手动增加表锁 lock table 表名称 read(write),表名称2 read(write);</li><li>查看表上加过的锁show open tables;</li><li>删除表锁 unlock tables;</li><li>MyISAM在执行查询语句(SELECT)前,会自动给涉及的所有表加读锁,在执行增删改操作前,会自动给涉及的表加写锁。</li><li>读锁会阻塞写，不会阻塞读。写锁则会把读和写都阻塞</li></ul></li></ul><ul><li><p>行锁 </p><ul><li>每次操作锁住一行数据。开销大，加锁慢;会出现死锁;锁定粒度最小，发生锁，冲突的概率最低，并发度最高。</li></ul></li><li><p>InnoDB与MYISAM的最大不同有两点:<br>  支持事务(TRANSACTION) 支持行级锁</p></li></ul><h3 id="面试过程中如何回答mysql相关的优化？"><a href="#面试过程中如何回答mysql相关的优化？" class="headerlink" title="面试过程中如何回答mysql相关的优化？"></a>面试过程中如何回答mysql相关的优化？</h3><ul><li><p>从建表语句</p><ul><li>主键尽量使用整形自增<ul><li>占用空间小</li><li>主键自增，新增的数据永远在后面</li><li>排序效率高</li><li>范围查找</li></ul></li><li>表字段使用not null,null值很难查询且占用额外空间</li><li>单表字段不要太多</li><li>建立查询字段索引</li></ul></li><li><p>从一条查询语句</p><ul><li>不用select*</li><li>尽可能使用覆盖索引，避免回表</li><li>join 字段建立索引</li><li> 大表 in 小表  ，小表 exist 大表</li><li>查询条件不用函数</li><li>避免使用不等于</li><li>对于连续数值，使用BETWEEN不用IN</li><li>避免like ‘%xxx’</li><li>不做列运算</li><li>limit 查询用连接子查询优化，子查询使用覆盖索引</li></ul></li><li><p>拆分大的delete或insert语句</p></li><li><p>可通过开启慢查询日志来找出较慢的SQL</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mysql优化&quot;&gt;&lt;a href=&quot;#mysql优化&quot; class=&quot;headerlink&quot; title=&quot;mysql优化&quot;&gt;&lt;/a&gt;mysql优化&lt;/h1&gt;&lt;h2 id=&quot;聚集索引和非聚集索引&quot;&gt;&lt;a href=&quot;#聚集索引和非聚集索引&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Mysql" scheme="https://blog.imder.top/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://blog.imder.top/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>逻辑关系划分</title>
    <link href="https://blog.imder.top/2022/02/22/%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB%E5%88%92%E5%88%86/"/>
    <id>https://blog.imder.top/2022/02/22/%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB%E5%88%92%E5%88%86/</id>
    <published>2022-02-22T22:22:22.000Z</published>
    <updated>2024-03-28T16:43:20.083Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逻辑关系划分"><a href="#逻辑关系划分" class="headerlink" title="逻辑关系划分"></a>逻辑关系划分</h1><h2 id="带”除非”的句子一共有3种情况"><a href="#带”除非”的句子一共有3种情况" class="headerlink" title="带”除非”的句子一共有3种情况"></a>带”除非”的句子一共有3种情况</h2><ul><li><p>除非和否则一起使用， 除非A，否则B，等同于 非A-&gt;B<br>【范例】除非你去，否则我不去。用逻辑表述为：  你不去-&gt;我不去</p></li><li><p>“除非”单独出现，没有其他逻辑连词，默认省略了“否则”。<br>比如说：（否则）B，除非A，等同于，除非A，否则B<br>【范例】他这次死定了，除非出现奇迹。等于除非出现奇迹，否则他死定了逻辑表述：非死定-&gt;出现奇迹，不出现奇迹-&gt;死定了</p></li><li><p>带有逻辑连词”除非”的句子，还有其他的逻辑连词“若”“如果”“才”<br>类似于“除非。。。才”，“如果…，除非…”，在带有其他逻辑连词的句子里，在这些句子里”除非”就是“必须的意思”除非A，才B，等同于必须A，才B，逻辑表述为 A&lt;-B 如果（若）A，除非B，等同于如果A，必须B，逻辑表述为  A-&gt;B</p></li></ul><p>【第一家】把若A，除非B，理解为除非A,否则不B，就等同于非A-&gt;非B，逆否后还是B-&gt;A。<br>除非天上掉馅饼，否则不嫁给你，非天上掉馅饼==》不嫁给你 【第二家】若A，除非B，理解为如果A，那么B，逻辑表示还是A==》B，所以这三种理解从逻辑的本质来说，最终是相同的。<br>【范例】如果我嫁给你了，除非天上掉馅饼<br>（1）除非替换为必须我嫁给你，必须天上掉馅饼，等同于，天上不掉馅饼==》不嫁给你<br>（2）“如果”，理解为“否则不”除非天上掉馅饼，否则不嫁给你，等同于，非天上掉馅饼=》不嫁给你<br>（3）理解为，如果，那么,如果嫁给你，那么天上掉馅饼，等同于，嫁给你==》掉馅饼，逆否后：不掉馅饼==》不嫁给你这三种理解，最中得出的逻辑本质是完全相同的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;逻辑关系划分&quot;&gt;&lt;a href=&quot;#逻辑关系划分&quot; class=&quot;headerlink&quot; title=&quot;逻辑关系划分&quot;&gt;&lt;/a&gt;逻辑关系划分&lt;/h1&gt;&lt;h2 id=&quot;带”除非”的句子一共有3种情况&quot;&gt;&lt;a href=&quot;#带”除非”的句子一共有3种情况&quot; class</summary>
      
    
    
    
    <category term="逻辑" scheme="https://blog.imder.top/categories/%E9%80%BB%E8%BE%91/"/>
    
    
    <category term="逻辑" scheme="https://blog.imder.top/tags/%E9%80%BB%E8%BE%91/"/>
    
  </entry>
  
  <entry>
    <title>sentinel</title>
    <link href="https://blog.imder.top/2022/02/22/springcloudsentinel/"/>
    <id>https://blog.imder.top/2022/02/22/springcloudsentinel/</id>
    <published>2022-02-22T14:20:47.000Z</published>
    <updated>2024-03-28T16:43:20.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sentinel"><a href="#sentinel" class="headerlink" title="sentinel"></a>sentinel</h1><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><ul><li>在pom文件中dependencyManagement里添加依赖<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2021.1&lt;/version&gt;</span><br><span class="line">    &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">    &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li>在pom文件中dependencies里添加依赖<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="抛出异常的方式定义资源"><a href="#抛出异常的方式定义资源" class="headerlink" title="抛出异常的方式定义资源"></a>抛出异常的方式定义资源</h2></li><li>定义流控规则<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void initRule()&#123;</span><br><span class="line">    FlowRule flowRule = new FlowRule();</span><br><span class="line">    flowRule.setResource(&quot;helloworld&quot;);</span><br><span class="line">    flowRule.setCount(2);</span><br><span class="line">    flowRule.setGrade(RuleConstant.FLOW_GRADE_QPS);</span><br><span class="line">    ArrayList arrayList = new ArrayList();</span><br><span class="line">    arrayList.add(flowRule);</span><br><span class="line">    FlowRuleManager.loadRules(arrayList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>判断是否限流<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> public  static  void helloworld()&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        Entry helloworld = SphU.entry(&quot;helloworld&quot;);</span><br><span class="line">        System.out.println(&quot;通过&quot;);</span><br><span class="line">    &#125;catch (Exception e)&#123;</span><br><span class="line">        System.out.println(&quot;限流&quot;);</span><br><span class="line">    &#125;finally &#123;</span><br><span class="line">        // SphU.entry(xxx) 需要与 entry.exit() 成对出现,否则会导致调用链记录异常</span><br><span class="line">        if (entry != null) &#123;</span><br><span class="line">            entry.exit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="限流实现方式二-注解方式定义资源"><a href="#限流实现方式二-注解方式定义资源" class="headerlink" title="限流实现方式二: 注解方式定义资源"></a>限流实现方式二: 注解方式定义资源</h2></li><li>@SentinelResource(value = “资源名称”,blockHandler =”handleFlowQpsException” ,fallback =”queryOrderInfo2Fallback”)</li><li>blockHandler = “handleFlowQpsException”用来处理Sentinel 限流/熔断等错误；</li><li>fallback = “queryOrderInfo2Fallback”用来处理接口中业务代码所有异常(如业务代码异常、sentinel限流熔断异常等)</li></ul><p>在接口OrderQueryService中，使用注解实现订单查询接口的限流：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@SentinelResource(value = &quot;getOrderInfo&quot;, blockHandler = &quot;handleFlowQpsException&quot;,</span><br><span class="line">        fallback = &quot;queryOrderInfo2Fallback&quot;)</span><br><span class="line">public String queryOrderInfo2(String orderId) &#123;</span><br><span class="line"></span><br><span class="line">    // 模拟接口运行时抛出代码异常</span><br><span class="line">    if (&quot;000&quot;.equals(orderId)) &#123;</span><br><span class="line">        throw new RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;获取订单信息:&quot; + orderId);</span><br><span class="line">    return &quot;return OrderInfo :&quot; + orderId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 订单查询接口抛出限流或降级时的处理逻辑</span><br><span class="line"> *</span><br><span class="line"> * 注意: 方法参数、返回值要与原函数保持一致</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public String handleFlowQpsException(String orderId, BlockException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    return &quot;handleFlowQpsException for queryOrderInfo2: &quot; + orderId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 订单查询接口运行时抛出的异常提供fallback处理</span><br><span class="line"> *</span><br><span class="line"> * 注意: 方法参数、返回值要与原函数保持一致</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public String queryOrderInfo2Fallback(String orderId, Throwable e) &#123;</span><br><span class="line">    return &quot;fallback queryOrderInfo2: &quot; + orderId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="控制台的使用"><a href="#控制台的使用" class="headerlink" title="控制台的使用"></a>控制台的使用</h2><h3 id="启动Sentinel控制台"><a href="#启动Sentinel控制台" class="headerlink" title="启动Sentinel控制台"></a>启动Sentinel控制台</h3><ul><li><p>下载地址：<a href="https://github.com/alibaba/Sentinel/releases">https://github.com/alibaba/Sentinel/releases</a></p></li><li><p>启动命令：java -Dserver.port=8080 \</p></li><li><p>Dcsp.sentinel.dashboard.server=localhost:8080 \</p></li><li><p>jar target/sentinel-dashboard.jar<br> <img src="/2022/02/22/springcloudsentinel/img.png" alt="img.png"></p><h3 id="客户端接入（Spring-Boot项目接入控制台"><a href="#客户端接入（Spring-Boot项目接入控制台" class="headerlink" title="客户端接入（Spring Boot项目接入控制台"></a>客户端接入（Spring Boot项目接入控制台</h3></li><li><p>添加依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sentinel-transport-simple-http&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;sentinel.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>配置 JVM 启动参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dproject.name=sentinel-demo -Dcsp.sentinel.dashboard.server=127.0.0.1:8080 -Dcsp.sentinel.api.port=8719</span><br></pre></td></tr></table></figure><p><img src="/2022/02/22/springcloudsentinel/img_1.png" alt="img_1.png"></p></li><li><p>控制台页面<br><img src="/2022/02/22/springcloudsentinel/img_2.png" alt="img_2.png"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;sentinel&quot;&gt;&lt;a href=&quot;#sentinel&quot; class=&quot;headerlink&quot; title=&quot;sentinel&quot;&gt;&lt;/a&gt;sentinel&lt;/h1&gt;&lt;h2 id=&quot;添加依赖&quot;&gt;&lt;a href=&quot;#添加依赖&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="Springcloud" scheme="https://blog.imder.top/categories/Springcloud/"/>
    
    
    <category term="Springcloud" scheme="https://blog.imder.top/tags/Springcloud/"/>
    
  </entry>
  
  <entry>
    <title>Springcloud-config</title>
    <link href="https://blog.imder.top/2022/02/22/springcloudconfig/"/>
    <id>https://blog.imder.top/2022/02/22/springcloudconfig/</id>
    <published>2022-02-22T11:59:29.000Z</published>
    <updated>2024-03-28T16:43:20.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="config"><a href="#config" class="headerlink" title="config"></a>config</h1><h2 id="Config-server"><a href="#Config-server" class="headerlink" title="Config server"></a>Config server</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="Application-properties配置"><a href="#Application-properties配置" class="headerlink" title="Application.properties配置"></a>Application.properties配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring.cloud.config.server.git.uri=https://gitee.com/rzxbest/springcloud-config.git</span><br><span class="line">spring.cloud.config.server.git.username=********</span><br><span class="line">spring.cloud.config.server.git.password=********</span><br><span class="line">spring.cloud.config.server.git.search-paths=config</span><br><span class="line">spring.cloud.config.server.default-label=master</span><br><span class="line"></span><br><span class="line">eureka.instance.hostname=localhost</span><br><span class="line">eureka.client.registerWithEureka=true</span><br><span class="line">eureka.client.fetchRegistry=true</span><br><span class="line">eureka.client.serviceUrl.defaultZone:http://$&#123;eureka.instance.hostname&#125;:8761/eureka/</span><br></pre></td></tr></table></figure><h2 id="访问配置文件"><a href="#访问配置文件" class="headerlink" title="访问配置文件"></a>访问配置文件</h2><h3 id="访问配置信息的URL与配置文件的映射关系如下所示："><a href="#访问配置信息的URL与配置文件的映射关系如下所示：" class="headerlink" title="访问配置信息的URL与配置文件的映射关系如下所示："></a>访问配置信息的URL与配置文件的映射关系如下所示：</h3><ul><li>/{ application } / {profile} [/{label}]</li><li>/{ application }-{profile}. yml</li><li>/{ label }/{ application }-{profile}.yml</li><li>/{ application }-{profile}.properties</li><li>/{ label }/{ application }-{profile}.properties<br>上面的 url 会映射 {application}-{profile} .properties 对应的配置文件，其中 {label} 对应Git上不同的分支，默认为 master 。我们可以尝试构造不同的 url 来访问不同的配置内容， 例如：<a href="http://localhost:8888/%7BapplicationName%7D/%7Bprofile%7D/%7Blabel%7D">http://localhost:8888/{applicationName}/{profile}/{label}</a> , label分支，不传的话默认master。</li></ul><h2 id="Config-client"><a href="#Config-client" class="headerlink" title="Config client"></a>Config client</h2><h3 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="添加配置-bootstrap-properties"><a href="#添加配置-bootstrap-properties" class="headerlink" title="添加配置 bootstrap.properties"></a>添加配置 bootstrap.properties</h3><p>server.port=8769</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=CLOUD-CONFIG-CLIENT</span><br><span class="line">eureka.instance.hostname=localhost</span><br><span class="line">eureka.client.registerWithEureka=true</span><br><span class="line">eureka.client.fetchRegistry=true</span><br><span class="line">eureka.client.serviceUrl.defaultZone:http://$&#123;eureka.instance.hostname&#125;:8761/eureka/</span><br><span class="line">spring.cloud.config.profile=dev</span><br><span class="line">spring.cloud.config.name=client-app</span><br><span class="line">spring.cloud.config.discovery.serviceId=CLOUD-CONFIG-SERVER</span><br><span class="line">spring.cloud.config.discovery.enabled=true</span><br></pre></td></tr></table></figure><h2 id="配置刷新"><a href="#配置刷新" class="headerlink" title="配置刷新"></a>配置刷新</h2><h3 id="手动调用config-client的refresh接口"><a href="#手动调用config-client的refresh接口" class="headerlink" title="手动调用config-client的refresh接口"></a>手动调用config-client的refresh接口</h3><ul><li><p>添加依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.6.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>添加配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.web.exposure.include=refresh</span><br><span class="line">management.endpoints.web.discovery.enabled=true</span><br></pre></td></tr></table></figure></li><li><p>需用使用配置的类加@RefreshScope<br><img src="/2022/02/22/springcloudconfig/img_3.png" alt="img_3.png"></p></li><li><p>Post请求接口<br><img src="/2022/02/22/springcloudconfig/img_2.png" alt="img_2.png"></p></li></ul><h2 id="自动刷新-利用git-webhook"><a href="#自动刷新-利用git-webhook" class="headerlink" title="自动刷新,利用git webhook"></a>自动刷新,利用git webhook</h2><ul><li>安装rabbitmq</li><li>configserver添加依赖<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.6.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li>configserver添加配置<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.host=localhost</span><br><span class="line">spring.rabbitmq.port=5672</span><br><span class="line">spring.rabbitmq.username=guest</span><br><span class="line">spring.rabbitmq.password=guest</span><br><span class="line"></span><br><span class="line">management.endpoints.web.exposure.include=*</span><br></pre></td></tr></table></figure></li><li>Configclient 添加依赖 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> &lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.6.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li>ConfigClient 添加配置<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.host=localhost</span><br><span class="line">spring.rabbitmq.port=5672</span><br><span class="line">spring.rabbitmq.username=guest</span><br><span class="line">spring.rabbitmq.password=guest</span><br></pre></td></tr></table></figure></li><li>需要刷新的配置类加@RefreshScope</li><li>配置configserver bus-refresh webhook<br><img src="/2022/02/22/springcloudconfig/img.png" alt="img.png"><br><a href="http://localhost:8768/actuator/bus-refresh">http://localhost:8768/actuator/bus-refresh</a><br><img src="/2022/02/22/springcloudconfig/img_1.png" alt="img_1.png"></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;config&quot;&gt;&lt;a href=&quot;#config&quot; class=&quot;headerlink&quot; title=&quot;config&quot;&gt;&lt;/a&gt;config&lt;/h1&gt;&lt;h2 id=&quot;Config-server&quot;&gt;&lt;a href=&quot;#Config-server&quot; class=&quot;he</summary>
      
    
    
    
    <category term="Springcloud" scheme="https://blog.imder.top/categories/Springcloud/"/>
    
    
    <category term="Springcloud" scheme="https://blog.imder.top/tags/Springcloud/"/>
    
  </entry>
  
  <entry>
    <title>Springcloud-gateway</title>
    <link href="https://blog.imder.top/2022/02/22/springgateway/"/>
    <id>https://blog.imder.top/2022/02/22/springgateway/</id>
    <published>2022-02-22T10:59:29.000Z</published>
    <updated>2024-03-28T16:43:20.075Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gateway"><a href="#gateway" class="headerlink" title="gateway"></a>gateway</h1><h2 id="文档地址"><a href="#文档地址" class="headerlink" title="文档地址"></a>文档地址</h2><ul><li><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.1.0.RELEASE/multi/multi_spring-cloud-gateway.html">https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.1.0.RELEASE/multi/multi_spring-cloud-gateway.html</a></li></ul><h2 id="Springcloud通用配置"><a href="#Springcloud通用配置" class="headerlink" title="Springcloud通用配置"></a>Springcloud通用配置</h2><ul><li><p>Eureka server 配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.port=8761</span><br><span class="line">eureka.instance.hostname=localhost</span><br><span class="line">eureka.client.registerWithEureka=false</span><br><span class="line">eureka.client.fetchRegistry=false</span><br><span class="line">eureka.client.serviceUrl.defaultZone:http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span><br></pre></td></tr></table></figure></li><li><p>服务配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server.port=8760</span><br><span class="line">spring.application.name=CLOUD-SERVICE</span><br><span class="line">eureka.instance.hostname=localhost</span><br><span class="line">eureka.client.registerWithEureka=true</span><br><span class="line">eureka.client.fetchRegistry=true</span><br><span class="line">eureka.client.serviceUrl.defaultZone:http://$&#123;eureka.instance.hostname&#125;:8761/eureka/</span><br></pre></td></tr></table></figure></li><li><p>网关配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server.port=8088</span><br><span class="line">spring.application.name=CLOUD-GATEWAY</span><br><span class="line">eureka.instance.hostname=localhost</span><br><span class="line">eureka.client.registerWithEureka=true</span><br><span class="line">eureka.client.fetchRegistry=true</span><br><span class="line">eureka.client.serviceUrl.defaultZone:http://$&#123;eureka.instance.hostname&#125;:8761/eureka/</span><br></pre></td></tr></table></figure></li></ul><h2 id="以服务名为前缀访问服务接口"><a href="#以服务名为前缀访问服务接口" class="headerlink" title="以服务名为前缀访问服务接口"></a>以服务名为前缀访问服务接口</h2><ul><li>在网关配置加入<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cloud.gateway.discovery.locator.enabled=true</span><br></pre></td></tr></table></figure><img src="/2022/02/22/springgateway/img.png" alt="img.png"></li></ul><h2 id="predicates断言路由"><a href="#predicates断言路由" class="headerlink" title="predicates断言路由"></a>predicates断言路由</h2><ul><li>在网关配置中加入以下配置<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.cloud.gateway.routes[0].id= 1</span><br><span class="line">spring.cloud.gateway.routes[0].uri=http://localhost:8760</span><br><span class="line">spring.cloud.gateway.routes[0].predicates[0]=Path=/demo/**</span><br></pre></td></tr></table></figure><img src="/2022/02/22/springgateway/img2.png" alt="img2.png"></li></ul><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><ul><li>加入以下配置<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.cloud.gateway.routes[0].filters[0].name=AddRequestParameter</span><br><span class="line">spring.cloud.gateway.routes[0].filters[0].args[name]=token</span><br><span class="line">spring.cloud.gateway.routes[0].filters[0].args[value]=abcdef</span><br></pre></td></tr></table></figure><img src="/2022/02/22/springgateway/img11.png" alt="img11.png"></li></ul><h2 id="过滤器对结果进行处理"><a href="#过滤器对结果进行处理" class="headerlink" title="过滤器对结果进行处理"></a>过滤器对结果进行处理</h2><ul><li>对结果进行处理</li><li>官方文档提供的 modifyResponseBody过滤器</li></ul><p><img src="/2022/02/22/springgateway/img12.png" alt="img12.png"></p><p>添加Java配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public RouteLocator routes(RouteLocatorBuilder builder,ObjectMapper mapper) &#123;</span><br><span class="line">return builder.routes()</span><br><span class="line">.route(&quot;id2&quot;, r -&gt; r.path(&quot;/modify/**&quot;)</span><br><span class="line">.filters(gatewayFilterSpec-&gt; &#123;</span><br><span class="line">gatewayFilterSpec.modifyResponseBody(String.class,String.class,(exchange,s) -&gt;&#123;</span><br><span class="line">String result = s;</span><br><span class="line">try&#123;</span><br><span class="line">Map map = mapper.readValue(s, Map.class);</span><br><span class="line">map.put(&quot;add&quot;,&quot;this is modify&quot;);</span><br><span class="line">result = mapper.writeValueAsString(map);</span><br><span class="line">&#125;catch (Exception e)&#123;</span><br><span class="line">&#125;</span><br><span class="line">return  Mono.just(result); &#125;</span><br><span class="line">);</span><br><span class="line">return gatewayFilterSpec;</span><br><span class="line">&#125;).uri(URI.create(&quot;http://localhost:8760&quot;))).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><p><img src="/2022/02/22/springgateway/img13.png" alt="img13.png"></p><h2 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h2><h3 id="自定义全局过滤器"><a href="#自定义全局过滤器" class="headerlink" title="自定义全局过滤器"></a>自定义全局过滤器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@Order(-1)</span><br><span class="line">public GlobalFilter a() &#123;</span><br><span class="line">    return (exchange, chain) -&gt; &#123;</span><br><span class="line">        if (exchange.getRequest().getQueryParams().containsKey(&quot;token&quot;))&#123;</span><br><span class="line">            return chain.filter(exchange).doOnSuccess(s-&gt;&#123;</span><br><span class="line">            exchange.getResponse().getHeaders().add(&quot;token&quot;,exchange.getRequest().getQueryParams().get(&quot;token&quot;).get(0));</span><br><span class="line">        &#125;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者实现GlobalFilter、 Order接口<br><img src="/2022/02/22/springgateway/img14.png" alt="img14.png"><br><img src="/2022/02/22/springgateway/img15.png" alt="img15.png"></p><h2 id="接入actuator"><a href="#接入actuator" class="headerlink" title="接入actuator"></a>接入actuator</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">management.endpoint.gateway.enabled=true</span><br><span class="line">management.endpoints.web.exposure.include=gateway</span><br></pre></td></tr></table></figure><h2 id="访问地址"><a href="#访问地址" class="headerlink" title="访问地址"></a>访问地址</h2><ul><li>/actuator/gateway/globalfilters</li><li>/actuator/gateway/routefilters</li><li>/actuator/gateway/refresh</li><li>/actuator/gateway/routes</li><li>/actuator/gateway/routes/{id}</li><li>POST request to /gateway/routes/{id_route_to_create}</li><li>DELETE request to /gateway/routes/{id_route_to_delete}.</li></ul><h3 id="自定义Filter"><a href="#自定义Filter" class="headerlink" title="自定义Filter"></a>自定义Filter</h3><ul><li>实现GatewayFilterFactory 或者继承AbstractGatewayFilterFactory<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class AddResponseHeaderGatewayFilterFactory extends AbstractNameValueGatewayFilterFactory &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public GatewayFilter apply(NameValueConfig config) &#123;</span><br><span class="line">return new GatewayFilter() &#123;</span><br><span class="line">@Override</span><br><span class="line">public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;</span><br><span class="line">String value = ServerWebExchangeUtils.expand(exchange, config.getValue());</span><br><span class="line">exchange.getResponse().getHeaders().add(config.getName(), value);</span><br><span class="line"></span><br><span class="line">            return chain.filter(exchange);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         @Override</span><br><span class="line">         public String toString() &#123;</span><br><span class="line">            return filterToStringCreator(AddResponseHeaderGatewayFilterFactory.this)</span><br><span class="line">                  .append(config.getName(), config.getValue()).toString();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;gateway&quot;&gt;&lt;a href=&quot;#gateway&quot; class=&quot;headerlink&quot; title=&quot;gateway&quot;&gt;&lt;/a&gt;gateway&lt;/h1&gt;&lt;h2 id=&quot;文档地址&quot;&gt;&lt;a href=&quot;#文档地址&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="Springcloud" scheme="https://blog.imder.top/categories/Springcloud/"/>
    
    
    <category term="Springcloud" scheme="https://blog.imder.top/tags/Springcloud/"/>
    
  </entry>
  
  <entry>
    <title>ExceptionHandler和ControllerAdvice注解分析</title>
    <link href="https://blog.imder.top/2022/02/21/@ControllerAdvice%E4%B8%8E@ModelAttribute%E3%80%81@InitBinder%E6%B3%A8%E8%A7%A3%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8/"/>
    <id>https://blog.imder.top/2022/02/21/@ControllerAdvice%E4%B8%8E@ModelAttribute%E3%80%81@InitBinder%E6%B3%A8%E8%A7%A3%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8/</id>
    <published>2022-02-21T19:59:29.000Z</published>
    <updated>2024-03-28T16:43:20.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ControllerAdvice与-ModelAttribute、-InitBinder注解混合使用"><a href="#ControllerAdvice与-ModelAttribute、-InitBinder注解混合使用" class="headerlink" title="@ControllerAdvice与@ModelAttribute、@InitBinder注解混合使用"></a>@ControllerAdvice与@ModelAttribute、@InitBinder注解混合使用</h1><h2 id="ModelAttribute注解的作用"><a href="#ModelAttribute注解的作用" class="headerlink" title="@ModelAttribute注解的作用"></a>@ModelAttribute注解的作用</h2><ul><li>用在方法的参数上<ul><li>注解在参数上，会将客户端传递过来的参数按名称注入到指定对象中，</li><li>并且会将这个对象自动加入ModelMap中</li></ul></li><li>用在Controller的方法上<ul><li>注解在方法上，会在每一个@RequestMapping标注的方法前执行，</li><li>如果有返回值，则自动将该返回值加入到ModelMap中</li></ul></li></ul><h2 id="InitBinder注解混合使用"><a href="#InitBinder注解混合使用" class="headerlink" title="@InitBinder注解混合使用"></a>@InitBinder注解混合使用</h2><ul><li>对数据绑定进行设置<br>  WebDataBinder中有很多方法可以对数据绑定进行具体的设置<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@InitBinder</span><br><span class="line">public void initBinder(WebDataBinder binder) &#123;</span><br><span class="line">binder.setDisallowedFields(&quot;name&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>注册已有封装好的编辑器<ul><li>由于前台传到controller里的值是String类型的，当往Model里Set这个值的时候，如果set的这个属性是个对象，Spring就会去找到对应的editor进行转换，然后再set进去</li><li>Spring自己提供了大量的实现类（如下图所示的在org.springframwork.beans.propertyEditors下的所有editor），诸如CustomDateEditor ，CustomBooleanEditor，CustomNumberEditor等许多，基本上够用</li></ul></li></ul><h2 id="如何加载-RequestMappingHandlerAdapter？"><a href="#如何加载-RequestMappingHandlerAdapter？" class="headerlink" title="如何加载    RequestMappingHandlerAdapter？"></a>如何加载    RequestMappingHandlerAdapter？</h2><p>自己注入或者使用默认的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private void initHandlerAdapters(ApplicationContext context) &#123;</span><br><span class="line">this.handlerAdapters = null;</span><br><span class="line"></span><br><span class="line">if (this.detectAllHandlerAdapters) &#123; //true</span><br><span class="line">// Find all HandlerAdapters in the ApplicationContext, including ancestor contexts.</span><br><span class="line">Map&lt;String, HandlerAdapter&gt; matchingBeans =</span><br><span class="line">BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, true, false);//从容器中获取HandlerAdapter.class</span><br><span class="line">if (!matchingBeans.isEmpty()) &#123;</span><br><span class="line">this.handlerAdapters = new ArrayList&lt;&gt;(matchingBeans.values());</span><br><span class="line">// We keep HandlerAdapters in sorted order.</span><br><span class="line">AnnotationAwareOrderComparator.sort(this.handlerAdapters);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">try &#123;</span><br><span class="line">HandlerAdapter ha = context.getBean(HANDLER_ADAPTER_BEAN_NAME, HandlerAdapter.class);</span><br><span class="line">this.handlerAdapters = Collections.singletonList(ha);</span><br><span class="line">&#125;</span><br><span class="line">catch (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">// Ignore, we&#x27;ll add a default HandlerAdapter later.</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Ensure we have at least some HandlerAdapters, by registering</span><br><span class="line">// default HandlerAdapters if no other adapters are found.</span><br><span class="line">if (this.handlerAdapters == null) &#123;</span><br><span class="line">this.handlerAdapters = getDefaultStrategies(context, HandlerAdapter.class);//从DispatchServlet.properties中获取</span><br><span class="line">if (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(&quot;No HandlerAdapters declared for servlet &#x27;&quot; + getServletName() +</span><br><span class="line">&quot;&#x27;: using default strategies from DispatcherServlet.properties&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="DispatchServlet-properties中获取HandlerAdapter"><a href="#DispatchServlet-properties中获取HandlerAdapter" class="headerlink" title="DispatchServlet.properties中获取HandlerAdapter"></a>DispatchServlet.properties中获取HandlerAdapter</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\</span><br><span class="line">org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\</span><br><span class="line">org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter,\</span><br><span class="line">org.springframework.web.servlet.function.support.HandlerFunctionAdapter</span><br></pre></td></tr></table></figure><h2 id="何时加载-ControllerAdvice与-ModelAttribute、-InitBinder注解？"><a href="#何时加载-ControllerAdvice与-ModelAttribute、-InitBinder注解？" class="headerlink" title="何时加载@ControllerAdvice与@ModelAttribute、@InitBinder注解？"></a>何时加载@ControllerAdvice与@ModelAttribute、@InitBinder注解？</h2><p>RequestMappingHandlerAdapter类实现了InitializingBean接口，在afterPropertiesSet方法中initControllerAdviceCache方法中加载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public static final MethodFilter INIT_BINDER_METHODS = method -&gt;</span><br><span class="line">AnnotatedElementUtils.hasAnnotation(method, InitBinder.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static final MethodFilter MODEL_ATTRIBUTE_METHODS = method -&gt;</span><br><span class="line">(!AnnotatedElementUtils.hasAnnotation(method, RequestMapping.class) &amp;&amp;</span><br><span class="line">AnnotatedElementUtils.hasAnnotation(method, ModelAttribute.class));</span><br><span class="line"></span><br><span class="line">private void initControllerAdviceCache() &#123;</span><br><span class="line">if (getApplicationContext() == null) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//从容器中获取ControllerAdvice注解的bean</span><br><span class="line">List&lt;ControllerAdviceBean&gt; adviceBeans = ControllerAdviceBean.findAnnotatedBeans(getApplicationContext());</span><br><span class="line"></span><br><span class="line">List&lt;Object&gt; requestResponseBodyAdviceBeans = new ArrayList&lt;&gt;();</span><br><span class="line">//遍历每个bean,找出InitBinder注解的方法放入initBinderAdviceCache里，找出ModelAttribute注解的方法放入modelAttributeAdviceCache</span><br><span class="line">for (ControllerAdviceBean adviceBean : adviceBeans) &#123;</span><br><span class="line">Class&lt;?&gt; beanType = adviceBean.getBeanType();</span><br><span class="line">if (beanType == null) &#123;</span><br><span class="line">throw new IllegalStateException(&quot;Unresolvable type for ControllerAdviceBean: &quot; + adviceBean);</span><br><span class="line">&#125;</span><br><span class="line">Set&lt;Method&gt; attrMethods = MethodIntrospector.selectMethods(beanType, MODEL_ATTRIBUTE_METHODS);</span><br><span class="line">if (!attrMethods.isEmpty()) &#123;</span><br><span class="line">this.modelAttributeAdviceCache.put(adviceBean, attrMethods);</span><br><span class="line">&#125;</span><br><span class="line">Set&lt;Method&gt; binderMethods = MethodIntrospector.selectMethods(beanType, INIT_BINDER_METHODS);</span><br><span class="line">if (!binderMethods.isEmpty()) &#123;</span><br><span class="line">this.initBinderAdviceCache.put(adviceBean, binderMethods);</span><br><span class="line">&#125;</span><br><span class="line">if (RequestBodyAdvice.class.isAssignableFrom(beanType) || ResponseBodyAdvice.class.isAssignableFrom(beanType)) &#123;</span><br><span class="line">requestResponseBodyAdviceBeans.add(adviceBean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...省略</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="何时调用-ModelAttribute、-InitBinder注解的方法或参数？"><a href="#何时调用-ModelAttribute、-InitBinder注解的方法或参数？" class="headerlink" title="何时调用 @ModelAttribute、@InitBinder注解的方法或参数？"></a>何时调用 @ModelAttribute、@InitBinder注解的方法或参数？</h2><ul><li>在RequestMappingHandlerAdapter对象调用handle方法中调用</li><li>handle方法调用handleInternal方法,handleInternal方法调用invokeHandlerMethod方法</li><li>invokeHandlerMethod 方法中getDataBinderFactory方法获取InitBinder注解的方法</li><li>invokeHandlerMethod 方法中getModelFactory方法获取ModelAttribute注解的方法</li><li>调用ModelFactory对象的initModel方法，initModel方法中调用invokeModelAttributeMethods方法，调用@ModelAttribute注解的方法</li><li>调用ModelFactory对象的initModel方法，initModel方法中调用findSessionAttributeArguments方法，对@ModelAttribute注解的参数赋值</li><li>invocableMethod.invokeAndHandle(webRequest, mavContainer)，在这个方法中调用invokeForRequest(),invokeForRequest()中调用getMethodArgumentValues()方法对参数进行了绑定</li></ul><h2 id="getDataBinderFactory方法-getModelFactory方法"><a href="#getDataBinderFactory方法-getModelFactory方法" class="headerlink" title="getDataBinderFactory方法 getModelFactory方法"></a>getDataBinderFactory方法 getModelFactory方法</h2><ul><li>先从controller类获取@InitBinder注解的方法</li><li>在从@ControllerAdvice注解的bean上获取@InitBinder注解的方法</li><li>上述的方法组合并返回ModelFactory</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private WebDataBinderFactory getDataBinderFactory(HandlerMethod handlerMethod) throws Exception &#123;</span><br><span class="line">Class&lt;?&gt; handlerType = handlerMethod.getBeanType();</span><br><span class="line">Set&lt;Method&gt; methods = this.initBinderCache.get(handlerType);</span><br><span class="line">if (methods == null) &#123;</span><br><span class="line">methods = MethodIntrospector.selectMethods(handlerType, INIT_BINDER_METHODS);</span><br><span class="line">this.initBinderCache.put(handlerType, methods);</span><br><span class="line">&#125;</span><br><span class="line">List&lt;InvocableHandlerMethod&gt; initBinderMethods = new ArrayList&lt;&gt;();</span><br><span class="line">// Global methods first</span><br><span class="line">this.initBinderAdviceCache.forEach((controllerAdviceBean, methodSet) -&gt; &#123;</span><br><span class="line">if (controllerAdviceBean.isApplicableToBeanType(handlerType)) &#123;</span><br><span class="line">Object bean = controllerAdviceBean.resolveBean();</span><br><span class="line">for (Method method : methodSet) &#123;</span><br><span class="line">initBinderMethods.add(createInitBinderMethod(bean, method));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">for (Method method : methods) &#123;</span><br><span class="line">Object bean = handlerMethod.getBean();</span><br><span class="line">initBinderMethods.add(createInitBinderMethod(bean, method));</span><br><span class="line">&#125;</span><br><span class="line">return createDataBinderFactory(initBinderMethods);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>先从controller类获取@ModelAttribute注解的方法</li><li>在从@ControllerAdvice注解的bean上获取@ModelAttribute注解的方法</li><li>上述的方法组合并返回ModelFactory<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private ModelFactory getModelFactory(HandlerMethod handlerMethod, WebDataBinderFactory binderFactory) &#123;</span><br><span class="line">SessionAttributesHandler sessionAttrHandler = getSessionAttributesHandler(handlerMethod);</span><br><span class="line">Class&lt;?&gt; handlerType = handlerMethod.getBeanType();</span><br><span class="line">Set&lt;Method&gt; methods = this.modelAttributeCache.get(handlerType);</span><br><span class="line">if (methods == null) &#123;</span><br><span class="line">methods = MethodIntrospector.selectMethods(handlerType, MODEL_ATTRIBUTE_METHODS);</span><br><span class="line">this.modelAttributeCache.put(handlerType, methods);</span><br><span class="line">&#125;</span><br><span class="line">List&lt;InvocableHandlerMethod&gt; attrMethods = new ArrayList&lt;&gt;();</span><br><span class="line">// Global methods first</span><br><span class="line">this.modelAttributeAdviceCache.forEach((controllerAdviceBean, methodSet) -&gt; &#123;</span><br><span class="line">if (controllerAdviceBean.isApplicableToBeanType(handlerType)) &#123;</span><br><span class="line">Object bean = controllerAdviceBean.resolveBean();</span><br><span class="line">for (Method method : methodSet) &#123;</span><br><span class="line">attrMethods.add(createModelAttributeMethod(binderFactory, bean, method));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">for (Method method : methods) &#123;</span><br><span class="line">Object bean = handlerMethod.getBean();</span><br><span class="line">attrMethods.add(createModelAttributeMethod(binderFactory, bean, method));</span><br><span class="line">&#125;</span><br><span class="line">return new ModelFactory(attrMethods, binderFactory, sessionAttrHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="invokeModelAttributeMethods方法"><a href="#invokeModelAttributeMethods方法" class="headerlink" title="invokeModelAttributeMethods方法"></a>invokeModelAttributeMethods方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private void invokeModelAttributeMethods(NativeWebRequest request, ModelAndViewContainer container)</span><br><span class="line">throws Exception &#123;</span><br><span class="line"></span><br><span class="line">while (!this.modelMethods.isEmpty()) &#123;</span><br><span class="line">InvocableHandlerMethod modelMethod = getNextModelMethod(container).getHandlerMethod();</span><br><span class="line">ModelAttribute ann = modelMethod.getMethodAnnotation(ModelAttribute.class);</span><br><span class="line">Assert.state(ann != null, &quot;No ModelAttribute annotation&quot;);</span><br><span class="line">if (container.containsAttribute(ann.name())) &#123;</span><br><span class="line">if (!ann.binding()) &#123;</span><br><span class="line">container.setBindingDisabled(ann.name());</span><br><span class="line">&#125;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object returnValue = modelMethod.invokeForRequest(request, container);</span><br><span class="line">if (modelMethod.isVoid()) &#123;</span><br><span class="line">if (StringUtils.hasText(ann.value())) &#123;</span><br><span class="line">if (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(&quot;Name in @ModelAttribute is ignored because method returns void: &quot; +</span><br><span class="line">modelMethod.getShortLogMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String returnValueName = getNameForReturnValue(returnValue, modelMethod.getReturnType());</span><br><span class="line">if (!ann.binding()) &#123;</span><br><span class="line">container.setBindingDisabled(returnValueName);</span><br><span class="line">&#125;</span><br><span class="line">if (!container.containsAttribute(returnValueName)) &#123;</span><br><span class="line">container.addAttribute(returnValueName, returnValue);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="findSessionAttributeArguments方法"><a href="#findSessionAttributeArguments方法" class="headerlink" title="findSessionAttributeArguments方法"></a>findSessionAttributeArguments方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;String&gt; findSessionAttributeArguments(HandlerMethod handlerMethod) &#123;</span><br><span class="line">List&lt;String&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">for (MethodParameter parameter : handlerMethod.getMethodParameters()) &#123;</span><br><span class="line">if (parameter.hasParameterAnnotation(ModelAttribute.class)) &#123;</span><br><span class="line">String name = getNameForParameter(parameter);</span><br><span class="line">Class&lt;?&gt; paramType = parameter.getParameterType();</span><br><span class="line">if (this.sessionAttributesHandler.isHandlerSessionAttribute(name, paramType)) &#123;</span><br><span class="line">result.add(name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="getMethodArgumentValues方法"><a href="#getMethodArgumentValues方法" class="headerlink" title="getMethodArgumentValues方法"></a>getMethodArgumentValues方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">protected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,</span><br><span class="line">Object... providedArgs) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">MethodParameter[] parameters = getMethodParameters();</span><br><span class="line">if (ObjectUtils.isEmpty(parameters)) &#123;</span><br><span class="line">return EMPTY_ARGS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object[] args = new Object[parameters.length];</span><br><span class="line">for (int i = 0; i &lt; parameters.length; i++) &#123;</span><br><span class="line">MethodParameter parameter = parameters[i];</span><br><span class="line">parameter.initParameterNameDiscovery(this.parameterNameDiscoverer);</span><br><span class="line">args[i] = findProvidedArgument(parameter, providedArgs);</span><br><span class="line">if (args[i] != null) &#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">if (!this.resolvers.supportsParameter(parameter)) &#123;</span><br><span class="line">throw new IllegalStateException(formatArgumentError(parameter, &quot;No suitable resolver&quot;));</span><br><span class="line">&#125;</span><br><span class="line">try &#123;</span><br><span class="line">args[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);</span><br><span class="line">&#125;</span><br><span class="line">catch (Exception ex) &#123;</span><br><span class="line">// Leave stack trace for later, exception may actually be resolved and handled...</span><br><span class="line">if (logger.isDebugEnabled()) &#123;</span><br><span class="line">String exMsg = ex.getMessage();</span><br><span class="line">if (exMsg != null &amp;&amp; !exMsg.contains(parameter.getExecutable().toGenericString())) &#123;</span><br><span class="line">logger.debug(formatArgumentError(parameter, exMsg));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">throw ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return args;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ControllerAdvice与-ModelAttribute、-InitBinder注解混合使用&quot;&gt;&lt;a href=&quot;#ControllerAdvice与-ModelAttribute、-InitBinder注解混合使用&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="JAVA" scheme="https://blog.imder.top/categories/JAVA/"/>
    
    <category term="Spring" scheme="https://blog.imder.top/categories/JAVA/Spring/"/>
    
    
    <category term="JAVA" scheme="https://blog.imder.top/tags/JAVA/"/>
    
    <category term="Spring" scheme="https://blog.imder.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>ExceptionHandler和ControllerAdvice注解分析</title>
    <link href="https://blog.imder.top/2022/02/21/ExceptionHandler%E5%92%8CControllerAdvice%E6%B3%A8%E8%A7%A3%E5%88%86%E6%9E%90/"/>
    <id>https://blog.imder.top/2022/02/21/ExceptionHandler%E5%92%8CControllerAdvice%E6%B3%A8%E8%A7%A3%E5%88%86%E6%9E%90/</id>
    <published>2022-02-21T18:59:29.000Z</published>
    <updated>2024-03-28T16:43:20.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ExceptionHandler和ControllerAdvice注解分析"><a href="#ExceptionHandler和ControllerAdvice注解分析" class="headerlink" title="ExceptionHandler和ControllerAdvice注解分析"></a>ExceptionHandler和ControllerAdvice注解分析</h1><h2 id="DispatcherServlet如何加载HandlerExceptionResolver？"><a href="#DispatcherServlet如何加载HandlerExceptionResolver？" class="headerlink" title="DispatcherServlet如何加载HandlerExceptionResolver？"></a>DispatcherServlet如何加载HandlerExceptionResolver？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private void initHandlerExceptionResolvers(ApplicationContext context) &#123;</span><br><span class="line">this.handlerExceptionResolvers = null;</span><br><span class="line"></span><br><span class="line">if (this.detectAllHandlerExceptionResolvers) &#123; //默认为true</span><br><span class="line">// Find all HandlerExceptionResolvers in the ApplicationContext, including ancestor contexts.</span><br><span class="line">Map&lt;String, HandlerExceptionResolver&gt; matchingBeans = BeanFactoryUtils</span><br><span class="line">.beansOfTypeIncludingAncestors(context, HandlerExceptionResolver.class, true, false);</span><br><span class="line">if (!matchingBeans.isEmpty()) &#123;</span><br><span class="line">this.handlerExceptionResolvers = new ArrayList&lt;&gt;(matchingBeans.values());</span><br><span class="line">// We keep HandlerExceptionResolvers in sorted order.</span><br><span class="line">AnnotationAwareOrderComparator.sort(this.handlerExceptionResolvers);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">try &#123;</span><br><span class="line">HandlerExceptionResolver her =</span><br><span class="line">context.getBean(HANDLER_EXCEPTION_RESOLVER_BEAN_NAME, HandlerExceptionResolver.class);</span><br><span class="line">this.handlerExceptionResolvers = Collections.singletonList(her);</span><br><span class="line">&#125;</span><br><span class="line">catch (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">// Ignore, no HandlerExceptionResolver is fine too.</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Ensure we have at least some HandlerExceptionResolvers, by registering</span><br><span class="line">// default HandlerExceptionResolvers if no other resolvers are found.</span><br><span class="line">if (this.handlerExceptionResolvers == null) &#123;</span><br><span class="line">this.handlerExceptionResolvers = getDefaultStrategies(context, HandlerExceptionResolver.class); //从默认的DispatcherServlet.properties取</span><br><span class="line">if (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(&quot;No HandlerExceptionResolvers declared in servlet &#x27;&quot; + getServletName() +</span><br><span class="line">&quot;&#x27;: using default strategies from DispatcherServlet.properties&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DispatcherServlet-properties里的HandlerExceptionResolver配置"><a href="#DispatcherServlet-properties里的HandlerExceptionResolver配置" class="headerlink" title="DispatcherServlet.properties里的HandlerExceptionResolver配置"></a>DispatcherServlet.properties里的HandlerExceptionResolver配置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver,\</span><br><span class="line">org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\</span><br><span class="line">org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</span><br></pre></td></tr></table></figure><h2 id="何时加载-ControllerAdvice注解的bean、-ExceptionHandler注解的方法"><a href="#何时加载-ControllerAdvice注解的bean、-ExceptionHandler注解的方法" class="headerlink" title="何时加载@ControllerAdvice注解的bean、@ExceptionHandler注解的方法?"></a>何时加载@ControllerAdvice注解的bean、@ExceptionHandler注解的方法?</h2><ul><li>ExceptionHandlerExceptionResolver实现InitializingBean接口，在afterPropertiesSet方法里调用initExceptionHandlerAdviceCache()方法</li><li>在initExceptionHandlerAdviceCache()方法里对@ControllerAdvice注解的bean、@ExceptionHandler注解的方法进行处理</li><li>找出所有带有@ControllerAdvice注解的bean，用ExceptionHandlerMethodResolver类判断bean上是否有@ExceptionHandler，有加入exceptionHandlerAdviceCache里</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private void initExceptionHandlerAdviceCache() &#123;</span><br><span class="line">if (getApplicationContext() == null) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;ControllerAdviceBean&gt; adviceBeans = ControllerAdviceBean.findAnnotatedBeans(getApplicationContext()); //找出所有带有@ControllerAdvice注解的bean</span><br><span class="line">for (ControllerAdviceBean adviceBean : adviceBeans) &#123;</span><br><span class="line">Class&lt;?&gt; beanType = adviceBean.getBeanType();</span><br><span class="line">if (beanType == null) &#123;</span><br><span class="line">throw new IllegalStateException(&quot;Unresolvable type for ControllerAdviceBean: &quot; + adviceBean);</span><br><span class="line">&#125;</span><br><span class="line">ExceptionHandlerMethodResolver resolver = new ExceptionHandlerMethodResolver(beanType);</span><br><span class="line">if (resolver.hasExceptionMappings()) &#123;</span><br><span class="line">this.exceptionHandlerAdviceCache.put(adviceBean, resolver);</span><br><span class="line">&#125;</span><br><span class="line">if (ResponseBodyAdvice.class.isAssignableFrom(beanType)) &#123;</span><br><span class="line">this.responseBodyAdvice.add(adviceBean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (logger.isDebugEnabled()) &#123;</span><br><span class="line">int handlerSize = this.exceptionHandlerAdviceCache.size();</span><br><span class="line">int adviceSize = this.responseBodyAdvice.size();</span><br><span class="line">if (handlerSize == 0 &amp;&amp; adviceSize == 0) &#123;</span><br><span class="line">logger.debug(&quot;ControllerAdvice beans: none&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">logger.debug(&quot;ControllerAdvice beans: &quot; +</span><br><span class="line">handlerSize + &quot; @ExceptionHandler, &quot; + adviceSize + &quot; ResponseBodyAdvice&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>将@ControllerAdvice注解的bean解析方法上ExceptionHandler注解并放入mappedMethods中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static final MethodFilter EXCEPTION_HANDLER_METHODS = method -&gt;</span><br><span class="line">AnnotatedElementUtils.hasAnnotation(method, ExceptionHandler.class);</span><br><span class="line"></span><br><span class="line">public ExceptionHandlerMethodResolver(Class&lt;?&gt; handlerType) &#123;</span><br><span class="line">for (Method method : MethodIntrospector.selectMethods(handlerType, EXCEPTION_HANDLER_METHODS)) &#123;</span><br><span class="line">for (Class&lt;? extends Throwable&gt; exceptionType : detectExceptionMappings(method)) &#123;</span><br><span class="line">addExceptionMapping(exceptionType, method);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">private void addExceptionMapping(Class&lt;? extends Throwable&gt; exceptionType, Method method) &#123;</span><br><span class="line">Method oldMethod = this.mappedMethods.put(exceptionType, method);</span><br><span class="line">if (oldMethod != null &amp;&amp; !oldMethod.equals(method)) &#123;</span><br><span class="line">throw new IllegalStateException(&quot;Ambiguous @ExceptionHandler method mapped for [&quot; +</span><br><span class="line">exceptionType + &quot;]: &#123;&quot; + oldMethod + &quot;, &quot; + method + &quot;&#125;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public boolean hasExceptionMappings() &#123;</span><br><span class="line">return !this.mappedMethods.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="何时调用到ExceptionHandlerExceptionResolver"><a href="#何时调用到ExceptionHandlerExceptionResolver" class="headerlink" title="何时调用到ExceptionHandlerExceptionResolver?"></a>何时调用到ExceptionHandlerExceptionResolver?</h2><p>– 在DispatcherServlet的doDispatch方法中try-catch的catch代码中调用processDispatchResult方法(),这个方法中调用了processHandlerException方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">HttpServletRequest processedRequest = request;</span><br><span class="line">HandlerExecutionChain mappedHandler = null;</span><br><span class="line">boolean multipartRequestParsed = false;</span><br><span class="line"></span><br><span class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">ModelAndView mv = null;</span><br><span class="line">Exception dispatchException = null;</span><br><span class="line">....省略</span><br><span class="line">catch (Exception ex) &#123;</span><br><span class="line">dispatchException = ex;</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable err) &#123;</span><br><span class="line">// As of 4.3, we&#x27;re processing Errors thrown from handler methods as well,</span><br><span class="line">// making them available for @ExceptionHandler methods and other scenarios.</span><br><span class="line">dispatchException = new NestedServletException(&quot;Handler dispatch failed&quot;, err);</span><br><span class="line">&#125;</span><br><span class="line">processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,</span><br><span class="line">@Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,</span><br><span class="line">@Nullable Exception exception) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">boolean errorView = false;</span><br><span class="line"></span><br><span class="line">if (exception != null) &#123;</span><br><span class="line">if (exception instanceof ModelAndViewDefiningException) &#123;</span><br><span class="line">logger.debug(&quot;ModelAndViewDefiningException encountered&quot;, exception);</span><br><span class="line">mv = ((ModelAndViewDefiningException) exception).getModelAndView();</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);</span><br><span class="line">mv = processHandlerException(request, response, handler, exception);</span><br><span class="line">errorView = (mv != null);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">....省略</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response,</span><br><span class="line">@Nullable Object handler, Exception ex) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">// Success and error responses may use different content types</span><br><span class="line">request.removeAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">// Check registered HandlerExceptionResolvers...</span><br><span class="line">ModelAndView exMv = null;</span><br><span class="line">//遍历所有的handlerExceptionResolvers，能resolveException返回不空为空跳出循环</span><br><span class="line">if (this.handlerExceptionResolvers != null) &#123;</span><br><span class="line">for (HandlerExceptionResolver resolver : this.handlerExceptionResolvers) &#123;</span><br><span class="line">exMv = resolver.resolveException(request, response, handler, ex);//此处调用ExceptionHandlerExceptionResolver的resolveException方法</span><br><span class="line">if (exMv != null) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">....省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用ExceptionHandlerExceptionResolver的resolveException方法如何处理异常"><a href="#调用ExceptionHandlerExceptionResolver的resolveException方法如何处理异常" class="headerlink" title="调用ExceptionHandlerExceptionResolver的resolveException方法如何处理异常"></a>调用ExceptionHandlerExceptionResolver的resolveException方法如何处理异常</h2><ul><li>resolveException方法会调用doResolveHandlerMethodException方法</li><li>在doResolveHandlerMethodException方法里<ul><li>调用getExceptionHandlerMethod方法里<ul><li>从当前controller类找ExceptionHandler注解的方法，若找到并匹配异常类型返回ServletInvocableHandlerMethod</li><li>从exceptionHandlerAdviceCache 里面找到方法并匹配异常类型返回ServletInvocableHandlerMethod</li></ul></li><li>对返回的getExceptionHandlerMethod方法返回值进行判断<ul><li>不为空 exceptionHandlerMethod.invokeAndHandle(webRequest, mavContainer, arguments);</li><li>为空 return null</li></ul></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">protected ModelAndView doResolveHandlerMethodException(HttpServletRequest request,</span><br><span class="line">HttpServletResponse response, @Nullable HandlerMethod handlerMethod, Exception exception) &#123;</span><br><span class="line"></span><br><span class="line">ServletInvocableHandlerMethod exceptionHandlerMethod = getExceptionHandlerMethod(handlerMethod, exception);</span><br><span class="line">if (exceptionHandlerMethod == null) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...省略</span><br><span class="line">ServletWebRequest webRequest = new ServletWebRequest(request, response);</span><br><span class="line">ModelAndViewContainer mavContainer = new ModelAndViewContainer();</span><br><span class="line"></span><br><span class="line">ArrayList&lt;Throwable&gt; exceptions = new ArrayList&lt;&gt;();</span><br><span class="line">try &#123;</span><br><span class="line">...省略</span><br><span class="line">exceptionHandlerMethod.invokeAndHandle(webRequest, mavContainer, arguments);</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable invocationEx) &#123;</span><br><span class="line">// Any other than the original exception (or a cause) is unintended here,</span><br><span class="line">// probably an accident (e.g. failed assertion or the like).</span><br><span class="line">if (!exceptions.contains(invocationEx) &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(&quot;Failure in @ExceptionHandler &quot; + exceptionHandlerMethod, invocationEx);</span><br><span class="line">&#125;</span><br><span class="line">// Continue with default processing of the original exception...</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (mavContainer.isRequestHandled()) &#123;</span><br><span class="line">return new ModelAndView();</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">ModelMap model = mavContainer.getModel();</span><br><span class="line">HttpStatus status = mavContainer.getStatus();</span><br><span class="line">ModelAndView mav = new ModelAndView(mavContainer.getViewName(), model, status);</span><br><span class="line">mav.setViewName(mavContainer.getViewName());</span><br><span class="line">if (!mavContainer.isViewReference()) &#123;</span><br><span class="line">mav.setView((View) mavContainer.getView());</span><br><span class="line">&#125;</span><br><span class="line">if (model instanceof RedirectAttributes) &#123;</span><br><span class="line">Map&lt;String, ?&gt; flashAttributes = ((RedirectAttributes) model).getFlashAttributes();</span><br><span class="line">RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes);</span><br><span class="line">&#125;</span><br><span class="line">return mav;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">protected ServletInvocableHandlerMethod getExceptionHandlerMethod(</span><br><span class="line">@Nullable HandlerMethod handlerMethod, Exception exception) &#123;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; handlerType = null;</span><br><span class="line"></span><br><span class="line">if (handlerMethod != null) &#123;</span><br><span class="line">// Local exception handler methods on the controller class itself.</span><br><span class="line">// To be invoked through the proxy, even in case of an interface-based proxy.</span><br><span class="line">handlerType = handlerMethod.getBeanType();</span><br><span class="line">ExceptionHandlerMethodResolver resolver = this.exceptionHandlerCache.get(handlerType);</span><br><span class="line">if (resolver == null) &#123;</span><br><span class="line">resolver = new ExceptionHandlerMethodResolver(handlerType);</span><br><span class="line">this.exceptionHandlerCache.put(handlerType, resolver);</span><br><span class="line">&#125;</span><br><span class="line">Method method = resolver.resolveMethod(exception);//从当前controller类找ExceptionHandler注解的方法</span><br><span class="line">if (method != null) &#123;</span><br><span class="line">return new ServletInvocableHandlerMethod(handlerMethod.getBean(), method, this.applicationContext);</span><br><span class="line">&#125;</span><br><span class="line">// For advice applicability check below (involving base packages, assignable types</span><br><span class="line">// and annotation presence), use target class instead of interface-based proxy.</span><br><span class="line">if (Proxy.isProxyClass(handlerType)) &#123;</span><br><span class="line">handlerType = AopUtils.getTargetClass(handlerMethod.getBean());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (Map.Entry&lt;ControllerAdviceBean, ExceptionHandlerMethodResolver&gt; entry : this.exceptionHandlerAdviceCache.entrySet()) &#123;</span><br><span class="line">ControllerAdviceBean advice = entry.getKey();</span><br><span class="line">if (advice.isApplicableToBeanType(handlerType)) &#123;</span><br><span class="line">ExceptionHandlerMethodResolver resolver = entry.getValue();</span><br><span class="line">Method method = resolver.resolveMethod(exception);//从exceptionHandlerAdviceCache 里面找到并匹配异常类型</span><br><span class="line">if (method != null) &#123;</span><br><span class="line">return new ServletInvocableHandlerMethod(advice.resolveBean(), method, this.applicationContext);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,</span><br><span class="line">Object... providedArgs) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line">setResponseStatus(webRequest);</span><br><span class="line"></span><br><span class="line">if (returnValue == null) &#123;</span><br><span class="line">if (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) &#123;</span><br><span class="line">disableContentCachingIfNecessary(webRequest);</span><br><span class="line">mavContainer.setRequestHandled(true);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else if (StringUtils.hasText(getResponseStatusReason())) &#123;</span><br><span class="line">mavContainer.setRequestHandled(true);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mavContainer.setRequestHandled(false);</span><br><span class="line">Assert.state(this.returnValueHandlers != null, &quot;No return value handlers&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">this.returnValueHandlers.handleReturnValue(</span><br><span class="line">returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class="line">&#125;</span><br><span class="line">catch (Exception ex) &#123;</span><br><span class="line">if (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(formatErrorForReturnValue(returnValue), ex);</span><br><span class="line">&#125;</span><br><span class="line">throw ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ExceptionHandler和ControllerAdvice注解分析&quot;&gt;&lt;a href=&quot;#ExceptionHandler和ControllerAdvice注解分析&quot; class=&quot;headerlink&quot; title=&quot;ExceptionHandler和C</summary>
      
    
    
    
    <category term="JAVA" scheme="https://blog.imder.top/categories/JAVA/"/>
    
    <category term="Spring" scheme="https://blog.imder.top/categories/JAVA/Spring/"/>
    
    
    <category term="JAVA" scheme="https://blog.imder.top/tags/JAVA/"/>
    
    <category term="Spring" scheme="https://blog.imder.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>拦截器链式调用</title>
    <link href="https://blog.imder.top/2022/02/21/%E6%8B%A6%E6%88%AA%E5%99%A8%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8/"/>
    <id>https://blog.imder.top/2022/02/21/%E6%8B%A6%E6%88%AA%E5%99%A8%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8/</id>
    <published>2022-02-21T16:59:29.000Z</published>
    <updated>2024-03-28T16:43:20.083Z</updated>
    
    <content type="html"><![CDATA[<h1 id="拦截器链式调用"><a href="#拦截器链式调用" class="headerlink" title="拦截器链式调用"></a>拦截器链式调用</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><ul><li>声明一个接口（校验）</li><li>定义校验规则</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>针对每个规则实现接口</li><li>每个规则有校验的先后顺序，继承order接口</li></ul><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ul><li>写一个抽象类：把公共的校验规则写在抽象类</li></ul><h2 id="链类"><a href="#链类" class="headerlink" title="链类"></a>链类</h2><ul><li>创建一个规则链对象，依赖规则对象</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;拦截器链式调用&quot;&gt;&lt;a href=&quot;#拦截器链式调用&quot; class=&quot;headerlink&quot; title=&quot;拦截器链式调用&quot;&gt;&lt;/a&gt;拦截器链式调用&lt;/h1&gt;&lt;h2 id=&quot;声明&quot;&gt;&lt;a href=&quot;#声明&quot; class=&quot;headerlink&quot; title=&quot;声</summary>
      
    
    
    
    <category term="JAVA" scheme="https://blog.imder.top/categories/JAVA/"/>
    
    
    <category term="JAVA" scheme="https://blog.imder.top/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>Springmvc之DispatcherServlet</title>
    <link href="https://blog.imder.top/2022/02/21/springmvc/"/>
    <id>https://blog.imder.top/2022/02/21/springmvc/</id>
    <published>2022-02-21T14:59:29.000Z</published>
    <updated>2024-03-28T16:43:20.075Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Springmvc之DispatcherServlet"><a href="#Springmvc之DispatcherServlet" class="headerlink" title="Springmvc之DispatcherServlet"></a>Springmvc之DispatcherServlet</h1><h2 id="初始化图"><a href="#初始化图" class="headerlink" title="初始化图"></a>初始化图</h2><p><img src="/springmvc%E5%88%9D%E5%A7%8B%E5%8C%96.png" alt="springmvc初始化"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Springmvc之DispatcherServlet&quot;&gt;&lt;a href=&quot;#Springmvc之DispatcherServlet&quot; class=&quot;headerlink&quot; title=&quot;Springmvc之DispatcherServlet&quot;&gt;&lt;/a&gt;Sprin</summary>
      
    
    
    
    <category term="Spring" scheme="https://blog.imder.top/categories/Spring/"/>
    
    
    <category term="JAVA" scheme="https://blog.imder.top/tags/JAVA/"/>
    
    <category term="Spring" scheme="https://blog.imder.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring循环依赖</title>
    <link href="https://blog.imder.top/2022/02/18/spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    <id>https://blog.imder.top/2022/02/18/spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</id>
    <published>2022-02-18T14:59:29.000Z</published>
    <updated>2024-03-28T16:43:20.075Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring循环依赖"><a href="#Spring循环依赖" class="headerlink" title="Spring循环依赖"></a>Spring循环依赖</h1><h2 id="循环依赖图"><a href="#循环依赖图" class="headerlink" title="循环依赖图"></a>循环依赖图</h2><p><img src="/2022/02/18/spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98.png" alt="spring循环依赖"></p><h2 id="aop创建proxy对象时机"><a href="#aop创建proxy对象时机" class="headerlink" title="aop创建proxy对象时机"></a>aop创建proxy对象时机</h2><ul><li>常规一点的就是在BeanFactory.initializeBean()方法里面调用初始化方法之后，调用applyBeanPostProcessorsAfterInitialization() –&gt; AbstractAutoProxyCreator.wrapIfNecessary()生成proxy对象。</li><li>还有就是在存在循环依赖的时候，在doCreateBean() –&gt; addSingletonFactory(beanName, () –&gt; getEarlyBeanReference(beanName, mbd, bean)); –&gt; 然后在getSingleton()的时候从三级缓存中取对象的时候，会调用getEarlyBeanReference() –&gt; AbstractAutoProxyCreator.wrapIfNecessary()生成proxy对象。</li></ul><h2 id="aop创建案例"><a href="#aop创建案例" class="headerlink" title="aop创建案例"></a>aop创建案例</h2><ul><li>第一种情况，Student是代理对象，但是getBean(“teacher”)。</li></ul><ol><li>创建Teacher bean</li><li>开始populateBean(“student”)</li><li>开始创建Student的bean实例</li><li>在创建完bean实例的之后也开始populateBean(“teacher”)</li><li>开始创建Teacher的bean实例 </li><li>这时候doGetBean(“teacher”)–&gt;getSingleton(“teacher”)的时候会从三级缓存中获取bean对象，直接返回。</li><li>Student继续下面步骤，即initializeBean()–&gt;applyBeanPostProcessorsAfterInitialization()开始为Student创建Proxy对象(因为Teacher是正常的singleton bean)</li><li>再返回到Teacher的创建，Teacher设置的就是Student的Proxy对象</li><li>然后Teacher继续调用initializeBean()完成初始化。</li></ol><ul><li>第二种情况，Student是代理对象，同时getBean(“student”)。</li></ul><ol><li>这种情况下就先开始创建Student对象的bean，</li><li>同样的开始populateBean(“teacher”)，</li><li>开始创建Teacher的bean，</li><li>创建完Teacher bean之后，接着开始populateBean(“student”)，</li><li>循环依赖开始创建student的bean， </li><li>那么这个时候这时候doGetBean(“student”)–&gt;getSingleton(“student”)的时候会从三级缓存中获取bean对象，</li><li>跟第一种情况不一样的是，Student是需要被AOP代理的，那么这时候从三级缓存中取出的是getEarlyBeanReference()方法返回的代理对象Proxy，</li><li>然后将这个proxy对象放到二级缓存earlySingletonObjects中。</li><li>后面Teacher populateBean(“student”)就拿到了Student的代理Proxy，完成Teacher的initializeBean()完成初始化， </li><li>然后回到创建student的bean创建，populateBean(“teacher”)设置好Teacher之后，</li><li>开始完成student的initializeBean()初始化，</li><li>这里applyBeanPostProcessorsAfterInitialization()–&gt;wrapIfNecessary()不会再创建代理对象，</li><li>因为缓存earlyProxyReferences里面已经存在student的proxy对象，这也就导致exposedObject = initializeBean(beanName, exposedObject, mbd)这个exposedObject不是代理对象proxy，而是真实对象，如果这样返回就有问题了，所以这里二级缓存的作用就体现出来了，在initializeBean()之后会再次调用getSingleton()去检查二级缓存，此时拿到earlySingletonReference是student对象的proxy对象，那么此时就将exposedObject从真实对象换成proxy代理对象，然后返回。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (earlySingletonExposure) &#123;</span><br><span class="line">    //再次检查二级缓存的值</span><br><span class="line">    Object earlySingletonReference = getSingleton(beanName, false);</span><br><span class="line">    if (earlySingletonReference != null) &#123;</span><br><span class="line">         if (exposedObject == bean) &#123;</span><br><span class="line">        //将真实对象转换成代理Proxy对象</span><br><span class="line">        exposedObject = earlySingletonReference;</span><br><span class="line">        &#125;</span><br><span class="line">        。。。省略代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="processon地址"><a href="#processon地址" class="headerlink" title="processon地址"></a>processon地址</h2><a href="https://www.processon.com/diagraming/620f41cbe0b34d5aaa947aec">https://www.processon.com/diagraming/620f41cbe0b34d5aaa947aec</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring循环依赖&quot;&gt;&lt;a href=&quot;#Spring循环依赖&quot; class=&quot;headerlink&quot; title=&quot;Spring循环依赖&quot;&gt;&lt;/a&gt;Spring循环依赖&lt;/h1&gt;&lt;h2 id=&quot;循环依赖图&quot;&gt;&lt;a href=&quot;#循环依赖图&quot; class=&quot;he</summary>
      
    
    
    
    <category term="Spring" scheme="https://blog.imder.top/categories/Spring/"/>
    
    
    <category term="JAVA" scheme="https://blog.imder.top/tags/JAVA/"/>
    
    <category term="Spring" scheme="https://blog.imder.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 对象头情况分析</title>
    <link href="https://blog.imder.top/2021/12/08/java-object-header/"/>
    <id>https://blog.imder.top/2021/12/08/java-object-header/</id>
    <published>2021-12-08T16:14:00.000Z</published>
    <updated>2024-03-28T16:43:20.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象头情况分析"><a href="#对象头情况分析" class="headerlink" title="对象头情况分析"></a>对象头情况分析</h2><ul><li>32位系统</li><li>64位系统</li></ul><h2 id="32位系统"><a href="#32位系统" class="headerlink" title="32位系统"></a>32位系统</h2><table><tr><th rowspan="2">锁状态</th> <th colspan="2">25bit</th> <th rowspan="2">4bit</th> <th>1bit</th> <th>2bit</th></tr><tr> <th>23bit</th> <th >2bit</th> <th>是否偏向锁</th> <th>锁标志位</th></tr><tr> <td>无锁</td>  <td colspan="2">对象的hashcode</td> <td>分代年龄</td> <td>0</td> <td>01</td></tr><tr> <td>偏向锁</td>  <td>线程ID</td> <td>Epoch</td> <td>分代年龄</td>  <td>1</td> <td>01</td></tr><tr> <td>轻量级锁</td>  <td colspan="4">指向栈中的锁记录的指针</td> <td>00</td></tr><tr> <td>重量级锁</td>  <td colspan="4">指向重量级锁的指针</td> <td>10</td></tr><tr> <td>GC标记</td>  <td colspan="4">空</td> <td>11</td></tr></table><h2 id="64位系统"><a href="#64位系统" class="headerlink" title="64位系统"></a>64位系统</h2><table><tr><th >锁状态</th> <th colspan="4">61bit</th> <th >是否偏向锁 1bit</th> <th>锁标志 2bit</th></tr><tr> <td>无锁</td> <td>unused 25bit</td> <td >对象的hashcode 31bit</td> <td>unused 1bit </td> <td>分代年龄 4bit</td> <td>0</td> <td>01</td></tr><tr> <td>偏向锁</td>  <td>线程ID 54bit</td> <td>Epoch 2bit </td> <td>unused 1bit </td> <td>分代年龄 4bit</td>  <td>1</td> <td>01</td></tr><tr> <td>轻量级锁</td>  <td colspan="5">指向栈中的锁记录的指针</td> <td>00</td></tr><tr> <td>重量级锁</td>  <td colspan="5">指向重量级锁的指针</td> <td>10</td></tr><tr> <td>GC标记</td>  <td colspan="5">空</td> <td>11</td></tr></table><h2 id="jvm是如何使用锁和markword"><a href="#jvm是如何使用锁和markword" class="headerlink" title="jvm是如何使用锁和markword?"></a>jvm是如何使用锁和markword?</h2><ol><li>当对象没有被加锁，一个普通的对象，MarkWord记录对象的hashcode，锁标志位01，是否偏向锁0</li><li>当对象被当做同步锁并有一个线程A抢到锁时，锁标志位 01 偏向锁改成1，前23bit记录抢到锁的线程id,表示进入偏向状态</li><li>当线程A再次试图来获得锁时，JVM发现同步锁对象的标志位是01，是否偏向锁是1，也就是偏向状态，Mark Word中记录的线程id就是线程A自己的id，表示线程A已经获得了这个偏向锁，可以执行同步锁的代码</li><li>当线程B试图获得这个锁时，JVM发现同步锁处于偏向状态，但是Mark Word中的线程id记录的不是B，那么线程B会先用CAS操作试图获得锁，这里的获得锁操作是有可能成功的，因为线程A一般不会自动释放偏向锁。如果抢锁成功，就把Mark Word里的线程id改为线程B的id，代表线程B获得了这个偏向锁，可以执行同步锁代码。如果抢锁失败，则继续执行步骤5。</li><li>偏向锁状态抢锁失败，代表当前锁有一定的竞争，偏向锁将升级为轻量级锁。JVM会在当前线程的线程栈中开辟一块单独的空间，里面保存指向对象锁Mark Word的指针，同时在对象锁Mark Word中保存指向这片空间的指针。上述两个保存操作都是CAS操作，如果保存成功，代表线程抢到了同步锁，就把Mark Word中的锁标志位改成00，可以执行同步锁代码。如果保存失败，表示抢锁失败，竞争太激烈，继续执行步骤6。</li><li>轻量级锁抢锁失败，JVM会使用自旋锁，自旋锁不是一个锁状态，只是代表不断的重试，尝试抢锁。从JDK1.7开始，自旋锁默认启用，自旋次数由JVM决定。如果抢锁成功则执行同步锁代码，如果失败则继续执行步骤7。</li><li>自旋锁重试之后如果抢锁依然失败，同步锁会升级至重量级锁，锁标志位改为10。在这个状态下，未抢到锁的线程都会被阻塞。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;对象头情况分析&quot;&gt;&lt;a href=&quot;#对象头情况分析&quot; class=&quot;headerlink&quot; title=&quot;对象头情况分析&quot;&gt;&lt;/a&gt;对象头情况分析&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;32位系统&lt;/li&gt;
&lt;li&gt;64位系统&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;32位系</summary>
      
    
    
    
    <category term="java对象" scheme="https://blog.imder.top/categories/java%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="内存" scheme="https://blog.imder.top/tags/%E5%86%85%E5%AD%98/"/>
    
    <category term="java" scheme="https://blog.imder.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>LJ16购物单</title>
    <link href="https://blog.imder.top/2021/11/30/huawei_lj16/"/>
    <id>https://blog.imder.top/2021/11/30/huawei_lj16/</id>
    <published>2021-11-30T11:43:00.000Z</published>
    <updated>2024-03-28T16:43:20.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="购物单"><a href="#购物单" class="headerlink" title="购物单"></a>购物单</h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>王强今天很开心，公司发给N元的年终奖。王强决定把年终奖用于购物，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：</p><table><thead><tr><th align="center">主件</th><th align="center">附件</th></tr></thead><tbody><tr><td align="center">电脑</td><td align="center">打印机，扫描仪</td></tr><tr><td align="center">书柜</td><td align="center">图书</td></tr><tr><td align="center">书桌</td><td align="center">台灯文具</td></tr><tr><td align="center">工作椅</td><td align="center">无</td></tr></tbody></table><p>如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有 0 个、 1 个或 2 个附件。附件不再有从属于自己的附件。王强想买的东西很多，为了不超出预算，他把每件物品规定了一个重要度，分为 5 等：用整数 1 ~ 5 表示，第 5 等最重要。他还从因特网上查到了每件物品的价格（都是 10 元的整数倍）。他希望在不超过 N 元（可以等于 N 元）的前提下，使每件物品的价格与重要度的乘积的总和最大。<br>    设第 j 件物品的价格为 v[j] ，重要度为 w[j] ，共选中了 k 件物品，编号依次为 j 1 ， j 2 ，……， j k ，则所求的总和为：<br>v[j 1 ]*w[j 1 ]+v[j 2 ]*w[j 2 ]+ … +v[j k ]*w[j k ] 。（其中 * 为乘号）<br>    请你帮助王强设计一个满足要求的购物单。</p><h2 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h2><p>输入的第 1 行，为两个正整数，用一个空格隔开：N m<br>（其中 N （ &lt;32000 ）表示总钱数， m （ &lt;60 ）为希望购买物品的个数。）</p><p>从第 2 行到第 m+1 行，第 j 行给出了编号为 j-1 的物品的基本数据，每行有 3 个非负整数 v p q</p><p>（其中 v 表示该物品的价格（ v&lt;10000 ）， p 表示该物品的重要度（ 1 ~ 5 ）， q 表示该物品是主件还是附件。如果 q=0 ，表示该物品为主件，如果 q&gt;0 ，表示该物品为附件， q 是所属主件的编号）</p><h2 id="输出描述："><a href="#输出描述：" class="headerlink" title="输出描述："></a>输出描述：</h2><p> 输出文件只有一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（ &lt;200000 ）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;购物单&quot;&gt;&lt;a href=&quot;#购物单&quot; class=&quot;headerlink&quot; title=&quot;购物单&quot;&gt;&lt;/a&gt;购物单&lt;/h1&gt;&lt;h1 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h1&gt;&lt;p</summary>
      
    
    
    
    <category term="华为面试题" scheme="https://blog.imder.top/categories/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="面试题" scheme="https://blog.imder.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
</feed>
